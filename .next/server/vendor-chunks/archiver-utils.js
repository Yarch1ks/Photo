/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/archiver-utils";
exports.ids = ["vendor-chunks/archiver-utils"];
exports.modules = {

/***/ "(rsc)/./node_modules/archiver-utils/file.js":
/*!*********************************************!*\
  !*** ./node_modules/archiver-utils/file.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\n */ var fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar flatten = __webpack_require__(/*! lodash/flatten */ \"lodash/flatten\");\nvar difference = __webpack_require__(/*! lodash/difference */ \"lodash/difference\");\nvar union = __webpack_require__(/*! lodash/union */ \"lodash/union\");\nvar isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ \"lodash/isPlainObject\");\nvar glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/dist/commonjs/index.js\");\nvar file = module.exports = {};\nvar pathSeparatorRe = /[\\/\\\\]/g;\n// Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\nvar processPatterns = function(patterns, fn) {\n    // Filepaths to return.\n    var result = [];\n    // Iterate over flattened patterns array.\n    flatten(patterns).forEach(function(pattern) {\n        // If the first character is ! it should be omitted\n        var exclusion = pattern.indexOf(\"!\") === 0;\n        // If the pattern is an exclusion, remove the !\n        if (exclusion) {\n            pattern = pattern.slice(1);\n        }\n        // Find all matching files for this pattern.\n        var matches = fn(pattern);\n        if (exclusion) {\n            // If an exclusion, remove matching files.\n            result = difference(result, matches);\n        } else {\n            // Otherwise add matching files.\n            result = union(result, matches);\n        }\n    });\n    return result;\n};\n// True if the file path exists.\nfile.exists = function() {\n    var filepath = path.join.apply(path, arguments);\n    return fs.existsSync(filepath);\n};\n// Return an array of all file paths that match the given wildcard patterns.\nfile.expand = function(...args) {\n    // If the first argument is an options object, save those options to pass\n    // into the File.prototype.glob.sync method.\n    var options = isPlainObject(args[0]) ? args.shift() : {};\n    // Use the first argument if it's an Array, otherwise convert the arguments\n    // object to an array and use that.\n    var patterns = Array.isArray(args[0]) ? args[0] : args;\n    // Return empty set if there are no patterns or filepaths.\n    if (patterns.length === 0) {\n        return [];\n    }\n    // Return all matching filepaths.\n    var matches = processPatterns(patterns, function(pattern) {\n        // Find all matching files for this pattern.\n        return glob.sync(pattern, options);\n    });\n    // Filter result set?\n    if (options.filter) {\n        matches = matches.filter(function(filepath) {\n            filepath = path.join(options.cwd || \"\", filepath);\n            try {\n                if (typeof options.filter === \"function\") {\n                    return options.filter(filepath);\n                } else {\n                    // If the file is of the right type and exists, this should work.\n                    return fs.statSync(filepath)[options.filter]();\n                }\n            } catch (e) {\n                // Otherwise, it's probably not the right type.\n                return false;\n            }\n        });\n    }\n    return matches;\n};\n// Build a multi task \"files\" object dynamically.\nfile.expandMapping = function(patterns, destBase, options) {\n    options = Object.assign({\n        rename: function(destBase, destPath) {\n            return path.join(destBase || \"\", destPath);\n        }\n    }, options);\n    var files = [];\n    var fileByDest = {};\n    // Find all files matching pattern, using passed-in options.\n    file.expand(options, patterns).forEach(function(src) {\n        var destPath = src;\n        // Flatten?\n        if (options.flatten) {\n            destPath = path.basename(destPath);\n        }\n        // Change the extension?\n        if (options.ext) {\n            destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\n        }\n        // Generate destination filename.\n        var dest = options.rename(destBase, destPath, options);\n        // Prepend cwd to src path if necessary.\n        if (options.cwd) {\n            src = path.join(options.cwd, src);\n        }\n        // Normalize filepaths to be unix-style.\n        dest = dest.replace(pathSeparatorRe, \"/\");\n        src = src.replace(pathSeparatorRe, \"/\");\n        // Map correct src path to dest path.\n        if (fileByDest[dest]) {\n            // If dest already exists, push this src onto that dest's src array.\n            fileByDest[dest].src.push(src);\n        } else {\n            // Otherwise create a new src-dest file mapping object.\n            files.push({\n                src: [\n                    src\n                ],\n                dest: dest\n            });\n            // And store a reference for later use.\n            fileByDest[dest] = files[files.length - 1];\n        }\n    });\n    return files;\n};\n// reusing bits of grunt's multi-task source normalization\nfile.normalizeFilesArray = function(data) {\n    var files = [];\n    data.forEach(function(obj) {\n        var prop;\n        if (\"src\" in obj || \"dest\" in obj) {\n            files.push(obj);\n        }\n    });\n    if (files.length === 0) {\n        return [];\n    }\n    files = _(files).chain().forEach(function(obj) {\n        if (!(\"src\" in obj) || !obj.src) {\n            return;\n        }\n        // Normalize .src properties to flattened array.\n        if (Array.isArray(obj.src)) {\n            obj.src = flatten(obj.src);\n        } else {\n            obj.src = [\n                obj.src\n            ];\n        }\n    }).map(function(obj) {\n        // Build options object, removing unwanted properties.\n        var expandOptions = Object.assign({}, obj);\n        delete expandOptions.src;\n        delete expandOptions.dest;\n        // Expand file mappings.\n        if (obj.expand) {\n            return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\n                // Copy obj properties to result.\n                var result = Object.assign({}, obj);\n                // Make a clone of the orig obj available.\n                result.orig = Object.assign({}, obj);\n                // Set .src and .dest, processing both as templates.\n                result.src = mapObj.src;\n                result.dest = mapObj.dest;\n                // Remove unwanted properties.\n                [\n                    \"expand\",\n                    \"cwd\",\n                    \"flatten\",\n                    \"rename\",\n                    \"ext\"\n                ].forEach(function(prop) {\n                    delete result[prop];\n                });\n                return result;\n            });\n        }\n        // Copy obj properties to result, adding an .orig property.\n        var result = Object.assign({}, obj);\n        // Make a clone of the orig obj available.\n        result.orig = Object.assign({}, obj);\n        if (\"src\" in result) {\n            // Expose an expand-on-demand getter method as .src.\n            Object.defineProperty(result, \"src\", {\n                enumerable: true,\n                get: function fn() {\n                    var src;\n                    if (!(\"result\" in fn)) {\n                        src = obj.src;\n                        // If src is an array, flatten it. Otherwise, make it into an array.\n                        src = Array.isArray(src) ? flatten(src) : [\n                            src\n                        ];\n                        // Expand src files, memoizing result.\n                        fn.result = file.expand(expandOptions, src);\n                    }\n                    return fn.result;\n                }\n            });\n        }\n        if (\"dest\" in result) {\n            result.dest = obj.dest;\n        }\n        return result;\n    }).flatten().value();\n    return files;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUMsR0FDRCxJQUFJQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNqQixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUVuQixJQUFJRSxVQUFVRixtQkFBT0EsQ0FBQztBQUN0QixJQUFJRyxhQUFhSCxtQkFBT0EsQ0FBQztBQUN6QixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxnQkFBZ0JMLG1CQUFPQSxDQUFDO0FBRTVCLElBQUlNLE9BQU9OLG1CQUFPQSxDQUFDO0FBRW5CLElBQUlPLE9BQU9DLE9BQU9DLE9BQU8sR0FBRyxDQUFDO0FBRTdCLElBQUlDLGtCQUFrQjtBQUV0QixrRUFBa0U7QUFDbEUsNERBQTREO0FBQzVELElBQUlDLGtCQUFrQixTQUFTQyxRQUFRLEVBQUVDLEVBQUU7SUFDekMsdUJBQXVCO0lBQ3ZCLElBQUlDLFNBQVMsRUFBRTtJQUNmLHlDQUF5QztJQUN6Q1osUUFBUVUsVUFBVUcsT0FBTyxDQUFDLFNBQVNDLE9BQU87UUFDeEMsbURBQW1EO1FBQ25ELElBQUlDLFlBQVlELFFBQVFFLE9BQU8sQ0FBQyxTQUFTO1FBQ3pDLCtDQUErQztRQUMvQyxJQUFJRCxXQUFXO1lBQUVELFVBQVVBLFFBQVFHLEtBQUssQ0FBQztRQUFJO1FBQzdDLDRDQUE0QztRQUM1QyxJQUFJQyxVQUFVUCxHQUFHRztRQUNqQixJQUFJQyxXQUFXO1lBQ2IsMENBQTBDO1lBQzFDSCxTQUFTWCxXQUFXVyxRQUFRTTtRQUM5QixPQUFPO1lBQ0wsZ0NBQWdDO1lBQ2hDTixTQUFTVixNQUFNVSxRQUFRTTtRQUN6QjtJQUNGO0lBQ0EsT0FBT047QUFDVDtBQUVBLGdDQUFnQztBQUNoQ1AsS0FBS2MsTUFBTSxHQUFHO0lBQ1osSUFBSUMsV0FBV3JCLEtBQUtzQixJQUFJLENBQUNDLEtBQUssQ0FBQ3ZCLE1BQU13QjtJQUNyQyxPQUFPMUIs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QUN4QjtRQUVBLE9BQU9yQztJQUNULEdBQUdaLE9BQU8sR0FBR2dFLEtBQUs7SUFFbEIsT0FBT3JCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2ZpbGUuanM/YjA0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGFyY2hpdmVyLXV0aWxzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQ2hyaXMgVGFsa2luZ3RvbiwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9ibG9iL21hc3Rlci9MSUNFTlNFLU1JVFxuICovXG52YXIgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnbG9kYXNoL2ZsYXR0ZW4nKTtcbnZhciBkaWZmZXJlbmNlID0gcmVxdWlyZSgnbG9kYXNoL2RpZmZlcmVuY2UnKTtcbnZhciB1bmlvbiA9IHJlcXVpcmUoJ2xvZGFzaC91bmlvbicpO1xudmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcblxudmFyIGZpbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgcGF0aFNlcGFyYXRvclJlID0gL1tcXC9cXFxcXS9nO1xuXG4vLyBQcm9jZXNzIHNwZWNpZmllZCB3aWxkY2FyZCBnbG9iIHBhdHRlcm5zIG9yIGZpbGVuYW1lcyBhZ2FpbnN0IGFcbi8vIGNhbGxiYWNrLCBleGNsdWRpbmcgYW5kIHVuaXF1aW5nIGZpbGVzIGluIHRoZSByZXN1bHQgc2V0LlxudmFyIHByb2Nlc3NQYXR0ZXJucyA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBmbikge1xuICAvLyBGaWxlcGF0aHMgdG8gcmV0dXJuLlxuICB2YXIgcmVzdWx0ID0gW107XG4gIC8vIEl0ZXJhdGUgb3ZlciBmbGF0dGVuZWQgcGF0dGVybnMgYXJyYXkuXG4gIGZsYXR0ZW4ocGF0dGVybnMpLmZvckVhY2goZnVuY3Rpb24ocGF0dGVybikge1xuICAgIC8vIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgISBpdCBzaG91bGQgYmUgb21pdHRlZFxuICAgIHZhciBleGNsdXNpb24gPSBwYXR0ZXJuLmluZGV4T2YoJyEnKSA9PT0gMDtcbiAgICAvLyBJZiB0aGUgcGF0dGVybiBpcyBhbiBleGNsdXNpb24sIHJlbW92ZSB0aGUgIVxuICAgIGlmIChleGNsdXNpb24pIHsgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSk7IH1cbiAgICAvLyBGaW5kIGFsbCBtYXRjaGluZyBmaWxlcyBmb3IgdGhpcyBwYXR0ZXJuLlxuICAgIHZhciBtYXRjaGVzID0gZm4ocGF0dGVybik7XG4gICAgaWYgKGV4Y2x1c2lvbikge1xuICAgICAgLy8gSWYgYW4gZXhjbHVzaW9uLCByZW1vdmUgbWF0Y2hpbmcgZmlsZXMuXG4gICAgICByZXN1bHQgPSBkaWZmZXJlbmNlKHJlc3VsdCwgbWF0Y2hlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBhZGQgbWF0Y2hpbmcgZmlsZXMuXG4gICAgICByZXN1bHQgPSB1bmlvbihyZXN1bHQsIG1hdGNoZXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBUcnVlIGlmIHRoZSBmaWxlIHBhdGggZXhpc3RzLlxuZmlsZS5leGlzdHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbGVwYXRoID0gcGF0aC5qb2luLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBmcy5leGlzdHNTeW5jKGZpbGVwYXRoKTtcbn07XG5cbi8vIFJldHVybiBhbiBhcnJheSBvZiBhbGwgZmlsZSBwYXRocyB0aGF0IG1hdGNoIHRoZSBnaXZlbiB3aWxkY2FyZCBwYXR0ZXJucy5cbmZpbGUuZXhwYW5kID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb3B0aW9ucyBvYmplY3QsIHNhdmUgdGhvc2Ugb3B0aW9ucyB0byBwYXNzXG4gIC8vIGludG8gdGhlIEZpbGUucHJvdG90eXBlLmdsb2Iuc3luYyBtZXRob2QuXG4gIHZhciBvcHRpb25zID0gaXNQbGFpbk9iamVjdChhcmdzWzBdKSA/IGFyZ3Muc2hpZnQoKSA6IHt9O1xuICAvLyBVc2UgdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0J3MgYW4gQXJyYXksIG90aGVyd2lzZSBjb252ZXJ0IHRoZSBhcmd1bWVudHNcbiAgLy8gb2JqZWN0IHRvIGFuIGFycmF5IGFuZCB1c2UgdGhhdC5cbiAgdmFyIHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICAvLyBSZXR1cm4gZW1wdHkgc2V0IGlmIHRoZXJlIGFyZSBubyBwYXR0ZXJucyBvciBmaWxlcGF0aHMuXG4gIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gIC8vIFJldHVybiBhbGwgbWF0Y2hpbmcgZmlsZXBhdGhzLlxuICB2YXIgbWF0Y2hlcyA9IHByb2Nlc3NQYXR0ZXJucyhwYXR0ZXJucywgZnVuY3Rpb24ocGF0dGVybikge1xuICAgIC8vIEZpbmQgYWxsIG1hdGNoaW5nIGZpbGVzIGZvciB0aGlzIHBhdHRlcm4uXG4gICAgcmV0dXJuIGdsb2Iuc3luYyhwYXR0ZXJuLCBvcHRpb25zKTtcbiAgfSk7XG4gIC8vIEZpbHRlciByZXN1bHQgc2V0P1xuICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hlcy5maWx0ZXIoZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgICAgIGZpbGVwYXRoID0gcGF0aC5qb2luKG9wdGlvbnMuY3dkIHx8ICcnLCBmaWxlcGF0aCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmlsdGVyKGZpbGVwYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZmlsZSBpcyBvZiB0aGUgcmlnaHQgdHlwZSBhbmQgZXhpc3RzLCB0aGlzIHNob3VsZCB3b3JrLlxuICAgICAgICAgIHJldHVybiBmcy5zdGF0U3luYyhmaWxlcGF0aClbb3B0aW9ucy5maWx0ZXJdKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGl0J3MgcHJvYmFibHkgbm90IHRoZSByaWdodCB0eXBlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG4vLyBCdWlsZCBhIG11bHRpIHRhc2sgXCJmaWxlc1wiIG9iamVjdCBkeW5hbWljYWxseS5cbmZpbGUuZXhwYW5kTWFwcGluZyA9IGZ1bmN0aW9uKHBhdHRlcm5zLCBkZXN0QmFzZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcmVuYW1lOiBmdW5jdGlvbihkZXN0QmFzZSwgZGVzdFBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4oZGVzdEJhc2UgfHwgJycsIGRlc3RQYXRoKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpO1xuICB2YXIgZmlsZXMgPSBbXTtcbiAgdmFyIGZpbGVCeURlc3QgPSB7fTtcbiAgLy8gRmluZCBhbGwgZmlsZXMgbWF0Y2hpbmcgcGF0dGVybiwgdXNpbmcgcGFzc2VkLWluIG9wdGlvbnMuXG4gIGZpbGUuZXhwYW5kKG9wdGlvbnMsIHBhdHRlcm5zKS5mb3JFYWNoKGZ1bmN0aW9uKHNyYykge1xuICAgIHZhciBkZXN0UGF0aCA9IHNyYztcbiAgICAvLyBGbGF0dGVuP1xuICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgIGRlc3RQYXRoID0gcGF0aC5iYXNlbmFtZShkZXN0UGF0aCk7XG4gICAgfVxuICAgIC8vIENoYW5nZSB0aGUgZXh0ZW5zaW9uP1xuICAgIGlmIChvcHRpb25zLmV4dCkge1xuICAgICAgZGVzdFBhdGggPSBkZXN0UGF0aC5yZXBsYWNlKC8oXFwuW15cXC9dKik/JC8sIG9wdGlvbnMuZXh0KTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgZGVzdGluYXRpb24gZmlsZW5hbWUuXG4gICAgdmFyIGRlc3QgPSBvcHRpb25zLnJlbmFtZShkZXN0QmFzZSwgZGVzdFBhdGgsIG9wdGlvbnMpO1xuICAgIC8vIFByZXBlbmQgY3dkIHRvIHNyYyBwYXRoIGlmIG5lY2Vzc2FyeS5cbiAgICBpZiAob3B0aW9ucy5jd2QpIHsgc3JjID0gcGF0aC5qb2luKG9wdGlvbnMuY3dkLCBzcmMpOyB9XG4gICAgLy8gTm9ybWFsaXplIGZpbGVwYXRocyB0byBiZSB1bml4LXN0eWxlLlxuICAgIGRlc3QgPSBkZXN0LnJlcGxhY2UocGF0aFNlcGFyYXRvclJlLCAnLycpO1xuICAgIHNyYyA9IHNyYy5yZXBsYWNlKHBhdGhTZXBhcmF0b3JSZSwgJy8nKTtcbiAgICAvLyBNYXAgY29ycmVjdCBzcmMgcGF0aCB0byBkZXN0IHBhdGguXG4gICAgaWYgKGZpbGVCeURlc3RbZGVzdF0pIHtcbiAgICAgIC8vIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsIHB1c2ggdGhpcyBzcmMgb250byB0aGF0IGRlc3QncyBzcmMgYXJyYXkuXG4gICAgICBmaWxlQnlEZXN0W2Rlc3RdLnNyYy5wdXNoKHNyYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgc3JjLWRlc3QgZmlsZSBtYXBwaW5nIG9iamVjdC5cbiAgICAgIGZpbGVzLnB1c2goe1xuICAgICAgICBzcmM6IFtzcmNdLFxuICAgICAgICBkZXN0OiBkZXN0LFxuICAgICAgfSk7XG4gICAgICAvLyBBbmQgc3RvcmUgYSByZWZlcmVuY2UgZm9yIGxhdGVyIHVzZS5cbiAgICAgIGZpbGVCeURlc3RbZGVzdF0gPSBmaWxlc1tmaWxlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmlsZXM7XG59O1xuXG4vLyByZXVzaW5nIGJpdHMgb2YgZ3J1bnQncyBtdWx0aS10YXNrIHNvdXJjZSBub3JtYWxpemF0aW9uXG5maWxlLm5vcm1hbGl6ZUZpbGVzQXJyYXkgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBmaWxlcyA9IFtdO1xuXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcHJvcDtcbiAgICBpZiAoJ3NyYycgaW4gb2JqIHx8ICdkZXN0JyBpbiBvYmopIHtcbiAgICAgIGZpbGVzLnB1c2gob2JqKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBmaWxlcyA9IF8oZmlsZXMpLmNoYWluKCkuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoISgnc3JjJyBpbiBvYmopIHx8ICFvYmouc3JjKSB7IHJldHVybjsgfVxuICAgIC8vIE5vcm1hbGl6ZSAuc3JjIHByb3BlcnRpZXMgdG8gZmxhdHRlbmVkIGFycmF5LlxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5zcmMpKSB7XG4gICAgICBvYmouc3JjID0gZmxhdHRlbihvYmouc3JjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLnNyYyA9IFtvYmouc3JjXTtcbiAgICB9XG4gIH0pLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAvLyBCdWlsZCBvcHRpb25zIG9iamVjdCwgcmVtb3ZpbmcgdW53YW50ZWQgcHJvcGVydGllcy5cbiAgICB2YXIgZXhwYW5kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgZGVsZXRlIGV4cGFuZE9wdGlvbnMuc3JjO1xuICAgIGRlbGV0ZSBleHBhbmRPcHRpb25zLmRlc3Q7XG5cbiAgICAvLyBFeHBhbmQgZmlsZSBtYXBwaW5ncy5cbiAgICBpZiAob2JqLmV4cGFuZCkge1xuICAgICAgcmV0dXJuIGZpbGUuZXhwYW5kTWFwcGluZyhvYmouc3JjLCBvYmouZGVzdCwgZXhwYW5kT3B0aW9ucykubWFwKGZ1bmN0aW9uKG1hcE9iaikge1xuICAgICAgICAvLyBDb3B5IG9iaiBwcm9wZXJ0aWVzIHRvIHJlc3VsdC5cbiAgICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgb3JpZyBvYmogYXZhaWxhYmxlLlxuICAgICAgICByZXN1bHQub3JpZyA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIC8vIFNldCAuc3JjIGFuZCAuZGVzdCwgcHJvY2Vzc2luZyBib3RoIGFzIHRlbXBsYXRlcy5cbiAgICAgICAgcmVzdWx0LnNyYyA9IG1hcE9iai5zcmM7XG4gICAgICAgIHJlc3VsdC5kZXN0ID0gbWFwT2JqLmRlc3Q7XG4gICAgICAgIC8vIFJlbW92ZSB1bndhbnRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICBbJ2V4cGFuZCcsICdjd2QnLCAnZmxhdHRlbicsICdyZW5hbWUnLCAnZXh0J10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IG9iaiBwcm9wZXJ0aWVzIHRvIHJlc3VsdCwgYWRkaW5nIGFuIC5vcmlnIHByb3BlcnR5LlxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgb3JpZyBvYmogYXZhaWxhYmxlLlxuICAgIHJlc3VsdC5vcmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmICgnc3JjJyBpbiByZXN1bHQpIHtcbiAgICAgIC8vIEV4cG9zZSBhbiBleHBhbmQtb24tZGVtYW5kIGdldHRlciBtZXRob2QgYXMgLnNyYy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdzcmMnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgICAgdmFyIHNyYztcbiAgICAgICAgICBpZiAoISgncmVzdWx0JyBpbiBmbikpIHtcbiAgICAgICAgICAgIHNyYyA9IG9iai5zcmM7XG4gICAgICAgICAgICAvLyBJZiBzcmMgaXMgYW4gYXJyYXksIGZsYXR0ZW4gaXQuIE90aGVyd2lzZSwgbWFrZSBpdCBpbnRvIGFuIGFycmF5LlxuICAgICAgICAgICAgc3JjID0gQXJyYXkuaXNBcnJheShzcmMpID8gZmxhdHRlbihzcmMpIDogW3NyY107XG4gICAgICAgICAgICAvLyBFeHBhbmQgc3JjIGZpbGVzLCBtZW1vaXppbmcgcmVzdWx0LlxuICAgICAgICAgICAgZm4ucmVzdWx0ID0gZmlsZS5leHBhbmQoZXhwYW5kT3B0aW9ucywgc3JjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZuLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCdkZXN0JyBpbiByZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kZXN0ID0gb2JqLmRlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSkuZmxhdHRlbigpLnZhbHVlKCk7XG5cbiAgcmV0dXJuIGZpbGVzO1xufTtcbiJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwiZmxhdHRlbiIsImRpZmZlcmVuY2UiLCJ1bmlvbiIsImlzUGxhaW5PYmplY3QiLCJnbG9iIiwiZmlsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJwYXRoU2VwYXJhdG9yUmUiLCJwcm9jZXNzUGF0dGVybnMiLCJwYXR0ZXJucyIsImZuIiwicmVzdWx0IiwiZm9yRWFjaCIsInBhdHRlcm4iLCJleGNsdXNpb24iLCJpbmRleE9mIiwic2xpY2UiLCJtYXRjaGVzIiwiZXhpc3RzIiwiZmlsZXBhdGgiLCJqb2luIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJleGlzdHNTeW5jIiwiZXhwYW5kIiwiYXJncyIsIm9wdGlvbnMiLCJzaGlmdCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInN5bmMiLCJmaWx0ZXIiLCJjd2QiLCJzdGF0U3luYyIsImUiLCJleHBhbmRNYXBwaW5nIiwiZGVzdEJhc2UiLCJPYmplY3QiLCJhc3NpZ24iLCJyZW5hbWUiLCJkZXN0UGF0aCIsImZpbGVzIiwiZmlsZUJ5RGVzdCIsInNyYyIsImJhc2VuYW1lIiwiZXh0IiwicmVwbGFjZSIsImRlc3QiLCJwdXNoIiwibm9ybWFsaXplRmlsZXNBcnJheSIsImRhdGEiLCJvYmoiLCJwcm9wIiwiXyIsImNoYWluIiwibWFwIiwiZXhwYW5kT3B0aW9ucyIsIm1hcE9iaiIsIm9yaWciLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/archiver-utils/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/archiver-utils/index.js":
/*!**********************************************!*\
  !*** ./node_modules/archiver-utils/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * archiver-utils\n *\n * Copyright (c) 2015 Chris Talkington.\n * Licensed under the MIT license.\n * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE\n */ var fs = __webpack_require__(/*! graceful-fs */ \"(rsc)/./node_modules/graceful-fs/graceful-fs.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar isStream = __webpack_require__(/*! is-stream */ \"(rsc)/./node_modules/is-stream/index.js\");\nvar lazystream = __webpack_require__(/*! lazystream */ \"(rsc)/./node_modules/lazystream/lib/lazystream.js\");\nvar normalizePath = __webpack_require__(/*! normalize-path */ \"(rsc)/./node_modules/normalize-path/index.js\");\nvar defaults = __webpack_require__(/*! lodash/defaults */ \"lodash/defaults\");\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nvar PassThrough = (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/lib/ours/index.js\").PassThrough);\nvar utils = module.exports = {};\nutils.file = __webpack_require__(/*! ./file.js */ \"(rsc)/./node_modules/archiver-utils/file.js\");\nutils.collectStream = function(source, callback) {\n    var collection = [];\n    var size = 0;\n    source.on(\"error\", callback);\n    source.on(\"data\", function(chunk) {\n        collection.push(chunk);\n        size += chunk.length;\n    });\n    source.on(\"end\", function() {\n        var buf = Buffer.alloc(size);\n        var offset = 0;\n        collection.forEach(function(data) {\n            data.copy(buf, offset);\n            offset += data.length;\n        });\n        callback(null, buf);\n    });\n};\nutils.dateify = function(dateish) {\n    dateish = dateish || new Date();\n    if (dateish instanceof Date) {\n        dateish = dateish;\n    } else if (typeof dateish === \"string\") {\n        dateish = new Date(dateish);\n    } else {\n        dateish = new Date();\n    }\n    return dateish;\n};\n// this is slightly different from lodash version\nutils.defaults = function(object, source, guard) {\n    var args = arguments;\n    args[0] = args[0] || {};\n    return defaults(...args);\n};\nutils.isStream = function(source) {\n    return isStream(source);\n};\nutils.lazyReadStream = function(filepath) {\n    return new lazystream.Readable(function() {\n        return fs.createReadStream(filepath);\n    });\n};\nutils.normalizeInputSource = function(source) {\n    if (source === null) {\n        return Buffer.alloc(0);\n    } else if (typeof source === \"string\") {\n        return Buffer.from(source);\n    } else if (utils.isStream(source)) {\n        // Always pipe through a PassThrough stream to guarantee pausing the stream if it's already flowing,\n        // since it will only be processed in a (distant) future iteration of the event loop, and will lose\n        // data if already flowing now.\n        return source.pipe(new PassThrough());\n    }\n    return source;\n};\nutils.sanitizePath = function(filepath) {\n    return normalizePath(filepath, false).replace(/^\\w+:/, \"\").replace(/^(\\.\\.\\/|\\/)+/, \"\");\n};\nutils.trailingSlashIt = function(str) {\n    return str.slice(-1) !== \"/\" ? str + \"/\" : str;\n};\nutils.unixifyPath = function(filepath) {\n    return normalizePath(filepath, false).replace(/^\\w+:/, \"\");\n};\nutils.walkdir = function(dirpath, base, callback) {\n    var results = [];\n    if (typeof base === \"function\") {\n        callback = base;\n        base = dirpath;\n    }\n    fs.readdir(dirpath, function(err, list) {\n        var i = 0;\n        var file;\n        var filepath;\n        if (err) {\n            return callback(err);\n        }\n        (function next() {\n            file = list[i++];\n            if (!file) {\n                return callback(null, results);\n            }\n            filepath = path.join(dirpath, file);\n            fs.stat(filepath, function(err, stats) {\n                results.push({\n                    path: filepath,\n                    relative: path.relative(base, filepath).replace(/\\\\/g, \"/\"),\n                    stats: stats\n                });\n                if (stats && stats.isDirectory()) {\n                    utils.walkdir(filepath, base, function(err, res) {\n                        if (err) {\n                            return callback(err);\n                        }\n                        res.forEach(function(dirEntry) {\n                            results.push(dirEntry);\n                        });\n                        next();\n                    });\n                } else {\n                    next();\n                }\n            });\n        })();\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBQ0QsSUFBSUEsS0FBS0MsbUJBQU9BLENBQUM7QUFDakIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsV0FBV0YsbUJBQU9BLENBQUM7QUFDdkIsSUFBSUcsYUFBYUgsbUJBQU9BLENBQUM7QUFDekIsSUFBSUksZ0JBQWdCSixtQkFBT0EsQ0FBQztBQUM1QixJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQztBQUV2QixJQUFJTSxTQUFTTixvREFBd0I7QUFDckMsSUFBSU8sY0FBY1Asa0hBQXNDO0FBRXhELElBQUlRLFFBQVFDLE9BQU9DLE9BQU8sR0FBRyxDQUFDO0FBQzlCRixNQUFNRyxJQUFJLEdBQUdYLG1CQUFPQSxDQUFDO0FBRXJCUSxNQUFNSSxhQUFhLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxRQUFRO0lBQzdDLElBQUlDLGFBQWEsRUFBRTtJQUNuQixJQUFJQyxPQUFPO0lBRVhILE9BQU9JLEVBQUUsQ0FBQyxTQUFTSDtJQUVuQkQsT0FBT0ksRUFBRSxDQUFDLFFBQVEsU0FBU0MsS0FBSztRQUM5QkgsV0FBV0ksSUFBSSxDQUFDRDtRQUNoQkYsUUFBUUUsTUFBTUUsTUFBTTtJQUN0QjtJQUVBUCxPQUFPSSxFQUFFLENBQUMsT0FBTztRQUNmLElBQUlJLE1BQU1DLE9BQU9DLEtBQUssQ0FBQ1A7UUFDdkIsSUFBSVEsU0FBUztRQUViVCxXQUFXVSxPQUFPLENBQUMsU0FBU0MsSUFBSTtZQUM5QkEsS0FBS0MsSUFBSSxDQUFDTixLQUFLRztZQUNmQSxVQUFVRSxLQUFLTixNQUFNO1FBQ3ZCO1FBRUFOLFNBQVMsTUFBTU87SUFDakI7QUFDRjtBQUVBYixNQUFNb0IsT0FBTyxHQUFHLFNBQVNDLE9BQU87SUFDOUJBLFVBQVVBLFdBQVcsSUFBSUM7SUFFekIsSUFBSUQsbUJBQW1CQyxNQUFNO1FBQzNCRCxVQUFVQTtJ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QUFDNEM7d0JBQ2Y7d0JBRUFQO29CQUNGO2dCQUNGLE9BQU87b0JBQ0xBO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL2FyY2hpdmVyLXV0aWxzL2luZGV4LmpzPzBmMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBhcmNoaXZlci11dGlsc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaHJpcyBUYWxraW5ndG9uLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvYXJjaGl2ZXItdXRpbHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG52YXIgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbnZhciBsYXp5c3RyZWFtID0gcmVxdWlyZSgnbGF6eXN0cmVhbScpO1xudmFyIG5vcm1hbGl6ZVBhdGggPSByZXF1aXJlKCdub3JtYWxpemUtcGF0aCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnbG9kYXNoL2RlZmF1bHRzJyk7XG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5QYXNzVGhyb3VnaDtcblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnV0aWxzLmZpbGUgPSByZXF1aXJlKCcuL2ZpbGUuanMnKTtcblxudXRpbHMuY29sbGVjdFN0cmVhbSA9IGZ1bmN0aW9uKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBbXTtcbiAgdmFyIHNpemUgPSAwO1xuXG4gIHNvdXJjZS5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cbiAgc291cmNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb2xsZWN0aW9uLnB1c2goY2h1bmspO1xuICAgIHNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICB9KTtcblxuICBzb3VyY2Uub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGF0YS5jb3B5KGJ1Ziwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBkYXRhLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIGNhbGxiYWNrKG51bGwsIGJ1Zik7XG4gIH0pO1xufTtcblxudXRpbHMuZGF0ZWlmeSA9IGZ1bmN0aW9uKGRhdGVpc2gpIHtcbiAgZGF0ZWlzaCA9IGRhdGVpc2ggfHwgbmV3IERhdGUoKTtcblxuICBpZiAoZGF0ZWlzaCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBkYXRlaXNoID0gZGF0ZWlzaDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0ZWlzaCA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRlaXNoID0gbmV3IERhdGUoZGF0ZWlzaCk7XG4gIH0gZWxzZSB7XG4gICAgZGF0ZWlzaCA9IG5ldyBEYXRlKCk7XG4gIH1cblxuICByZXR1cm4gZGF0ZWlzaDtcbn07XG5cbi8vIHRoaXMgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gbG9kYXNoIHZlcnNpb25cbnV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICBhcmdzWzBdID0gYXJnc1swXSB8fCB7fTtcblxuICByZXR1cm4gZGVmYXVsdHMoLi4uYXJncyk7XG59O1xuXG51dGlscy5pc1N0cmVhbSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICByZXR1cm4gaXNTdHJlYW0oc291cmNlKTtcbn07XG5cbnV0aWxzLmxhenlSZWFkU3RyZWFtID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgcmV0dXJuIG5ldyBsYXp5c3RyZWFtLlJlYWRhYmxlKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVwYXRoKTtcbiAgfSk7XG59O1xuXG51dGlscy5ub3JtYWxpemVJbnB1dFNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzb3VyY2UpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzU3RyZWFtKHNvdXJjZSkpIHtcbiAgICAvLyBBbHdheXMgcGlwZSB0aHJvdWdoIGEgUGFzc1Rocm91Z2ggc3RyZWFtIHRvIGd1YXJhbnRlZSBwYXVzaW5nIHRoZSBzdHJlYW0gaWYgaXQncyBhbHJlYWR5IGZsb3dpbmcsXG4gICAgLy8gc2luY2UgaXQgd2lsbCBvbmx5IGJlIHByb2Nlc3NlZCBpbiBhIChkaXN0YW50KSBmdXR1cmUgaXRlcmF0aW9uIG9mIHRoZSBldmVudCBsb29wLCBhbmQgd2lsbCBsb3NlXG4gICAgLy8gZGF0YSBpZiBhbHJlYWR5IGZsb3dpbmcgbm93LlxuICAgIHJldHVybiBzb3VyY2UucGlwZShuZXcgUGFzc1Rocm91Z2goKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufTtcblxudXRpbHMuc2FuaXRpemVQYXRoID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIGZhbHNlKS5yZXBsYWNlKC9eXFx3KzovLCAnJykucmVwbGFjZSgvXihcXC5cXC5cXC98XFwvKSsvLCAnJyk7XG59O1xuXG51dGlscy50cmFpbGluZ1NsYXNoSXQgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgtMSkgIT09ICcvJyA/IHN0ciArICcvJyA6IHN0cjtcbn07XG5cbnV0aWxzLnVuaXhpZnlQYXRoID0gZnVuY3Rpb24oZmlsZXBhdGgpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIGZhbHNlKS5yZXBsYWNlKC9eXFx3KzovLCAnJyk7XG59O1xuXG51dGlscy53YWxrZGlyID0gZnVuY3Rpb24oZGlycGF0aCwgYmFzZSwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAodHlwZW9mIGJhc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJhc2U7XG4gICAgYmFzZSA9IGRpcnBhdGg7XG4gIH1cblxuICBmcy5yZWFkZGlyKGRpcnBhdGgsIGZ1bmN0aW9uKGVyciwgbGlzdCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZmlsZTtcbiAgICB2YXIgZmlsZXBhdGg7XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICAoZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGZpbGUgPSBsaXN0W2krK107XG5cbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICB9XG5cbiAgICAgIGZpbGVwYXRoID0gcGF0aC5qb2luKGRpcnBhdGgsIGZpbGUpO1xuXG4gICAgICBmcy5zdGF0KGZpbGVwYXRoLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgcGF0aDogZmlsZXBhdGgsXG4gICAgICAgICAgcmVsYXRpdmU6IHBhdGgucmVsYXRpdmUoYmFzZSwgZmlsZXBhdGgpLnJlcGxhY2UoL1xcXFwvZywgJy8nKSxcbiAgICAgICAgICBzdGF0czogc3RhdHNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICB1dGlscy53YWxrZGlyKGZpbGVwYXRoLCBiYXNlLCBmdW5jdGlvbihlcnIsIHJlcykge1xuXHQgICAgaWYoZXJyKXtcblx0ICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cdCAgICB9XG5cbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uKGRpckVudHJ5KSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkaXJFbnRyeSk7XG4gICAgICAgICAgICB9KTtcblx0XHQgIFxuICAgICAgICAgICAgbmV4dCgpOyAgXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwicGF0aCIsImlzU3RyZWFtIiwibGF6eXN0cmVhbSIsIm5vcm1hbGl6ZVBhdGgiLCJkZWZhdWx0cyIsIlN0cmVhbSIsIlBhc3NUaHJvdWdoIiwidXRpbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwiZmlsZSIsImNvbGxlY3RTdHJlYW0iLCJzb3VyY2UiLCJjYWxsYmFjayIsImNvbGxlY3Rpb24iLCJzaXplIiwib24iLCJjaHVuayIsInB1c2giLCJsZW5ndGgiLCJidWYiLCJCdWZmZXIiLCJhbGxvYyIsIm9mZnNldCIsImZvckVhY2giLCJkYXRhIiwiY29weSIsImRhdGVpZnkiLCJkYXRlaXNoIiwiRGF0ZSIsIm9iamVjdCIsImd1YXJkIiwiYXJncyIsImFyZ3VtZW50cyIsImxhenlSZWFkU3RyZWFtIiwiZmlsZXBhdGgiLCJSZWFkYWJsZSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJub3JtYWxpemVJbnB1dFNvdXJjZSIsImZyb20iLCJwaXBlIiwic2FuaXRpemVQYXRoIiwicmVwbGFjZSIsInRyYWlsaW5nU2xhc2hJdCIsInN0ciIsInNsaWNlIiwidW5peGlmeVBhdGgiLCJ3YWxrZGlyIiwiZGlycGF0aCIsImJhc2UiLCJyZXN1bHRzIiwicmVhZGRpciIsImVyciIsImxpc3QiLCJpIiwibmV4dCIsImpvaW4iLCJzdGF0Iiwic3RhdHMiLCJyZWxhdGl2ZSIsImlzRGlyZWN0b3J5IiwicmVzIiwiZGlyRW50cnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/archiver-utils/index.js\n");

/***/ })

};
;