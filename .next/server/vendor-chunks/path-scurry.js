"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/path-scurry";
exports.ids = ["vendor-chunks/path-scurry"];
exports.modules = {

/***/ "(rsc)/./node_modules/path-scurry/dist/commonjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/path-scurry/dist/commonjs/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/dist/commonjs/index.js\");\nconst node_path_1 = __webpack_require__(/*! node:path */ \"node:path\");\nconst node_url_1 = __webpack_require__(/*! node:url */ \"node:url\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst actualFS = __importStar(__webpack_require__(/*! node:fs */ \"node:fs\"));\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nconst minipass_1 = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/commonjs/index.js\");\nconst defaultFS = {\n    lstatSync: fs_1.lstatSync,\n    readdir: fs_1.readdir,\n    readdirSync: fs_1.readdirSync,\n    readlinkSync: fs_1.readlinkSync,\n    realpathSync,\n    promises: {\n        lstat: promises_1.lstat,\n        readdir: promises_1.readdir,\n        readlink: promises_1.readlink,\n        realpath: promises_1.realpath\n    }\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption)=>!fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n            ...defaultFS.promises,\n            ...fsOption.promises || {}\n        }\n    };\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = (rootPath)=>rootPath.replace(/\\//g, \"\\\\\").replace(uncDriveRegexp, \"$1\\\\\");\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 1;\nconst IFCHR = 2;\nconst IFDIR = 4;\nconst IFBLK = 6;\nconst IFREG = 8;\nconst IFLNK = 10;\nconst IFSOCK = 12;\nconst IFMT = 15;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 16;\n// set after a successful lstat()\nconst LSTAT_CALLED = 32;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 64;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 128;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 256;\n// set if we know realpath() will fail\nconst ENOREALPATH = 512;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 1023;\nconst entToType = (s)=>s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = (s)=>{\n    const c = normalizeCache.get(s);\n    if (c) return c;\n    const n = s.normalize(\"NFKD\");\n    normalizeCache.set(s, n);\n    return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = (s)=>{\n    const c = normalizeNocaseCache.get(s);\n    if (c) return c;\n    const n = normalize(s.toLowerCase());\n    normalizeNocaseCache.set(s, n);\n    return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */ class ResolveCache extends lru_cache_1.LRUCache {\n    constructor(){\n        super({\n            max: 256\n        });\n    }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */ class ChildrenCache extends lru_cache_1.LRUCache {\n    constructor(maxSize = 16 * 1024){\n        super({\n            maxSize,\n            // parent + children\n            sizeCalculation: (a)=>a.length + 1\n        });\n    }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol(\"PathScurry setAsCwd\");\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */ class PathBase {\n    // potential default fs override\n    #fs;\n    // Stats fields\n    #dev;\n    get dev() {\n        return this.#dev;\n    }\n    #mode;\n    get mode() {\n        return this.#mode;\n    }\n    #nlink;\n    get nlink() {\n        return this.#nlink;\n    }\n    #uid;\n    get uid() {\n        return this.#uid;\n    }\n    #gid;\n    get gid() {\n        return this.#gid;\n    }\n    #rdev;\n    get rdev() {\n        return this.#rdev;\n    }\n    #blksize;\n    get blksize() {\n        return this.#blksize;\n    }\n    #ino;\n    get ino() {\n        return this.#ino;\n    }\n    #size;\n    get size() {\n        return this.#size;\n    }\n    #blocks;\n    get blocks() {\n        return this.#blocks;\n    }\n    #atimeMs;\n    get atimeMs() {\n        return this.#atimeMs;\n    }\n    #mtimeMs;\n    get mtimeMs() {\n        return this.#mtimeMs;\n    }\n    #ctimeMs;\n    get ctimeMs() {\n        return this.#ctimeMs;\n    }\n    #birthtimeMs;\n    get birthtimeMs() {\n        return this.#birthtimeMs;\n    }\n    #atime;\n    get atime() {\n        return this.#atime;\n    }\n    #mtime;\n    get mtime() {\n        return this.#mtime;\n    }\n    #ctime;\n    get ctime() {\n        return this.#ctime;\n    }\n    #birthtime;\n    get birthtime() {\n        return this.#birthtime;\n    }\n    #matchName;\n    #depth;\n    #fullpath;\n    #fullpathPosix;\n    #relative;\n    #relativePosix;\n    #type;\n    #children;\n    #linkTarget;\n    #realpath;\n    /**\n     * This property is for compatibility with the Dirent class as of\n     * Node v20, where Dirent['parentPath'] refers to the path of the\n     * directory that was passed to readdir. For root entries, it's the path\n     * to the entry itself.\n     */ get parentPath() {\n        return (this.parent || this).fullpath();\n    }\n    /**\n     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n     * this property refers to the *parent* path, not the path object itself.\n     */ get path() {\n        return this.parentPath;\n    }\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){\n        /**\n     * boolean indicating that this path is the current working directory\n     * of the PathScurry collection that contains it.\n     */ this.isCWD = false;\n        this.#onReaddirCB = [];\n        this.#readdirCBInFlight = false;\n        this.name = name;\n        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n        this.#type = type & TYPEMASK;\n        this.nocase = nocase;\n        this.roots = roots;\n        this.root = root || this;\n        this.#children = children;\n        this.#fullpath = opts.fullpath;\n        this.#relative = opts.relative;\n        this.#relativePosix = opts.relativePosix;\n        this.parent = opts.parent;\n        if (this.parent) {\n            this.#fs = this.parent.#fs;\n        } else {\n            this.#fs = fsFromOption(opts.fs);\n        }\n    }\n    /**\n     * Returns the depth of the Path object from its root.\n     *\n     * For example, a path at `/foo/bar` would have a depth of 2.\n     */ depth() {\n        if (this.#depth !== undefined) return this.#depth;\n        if (!this.parent) return this.#depth = 0;\n        return this.#depth = this.parent.depth() + 1;\n    }\n    /**\n     * @internal\n     */ childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Get the Path object referenced by the string path, resolved from this Path\n     */ resolve(path) {\n        if (!path) {\n            return this;\n        }\n        const rootPath = this.getRootString(path);\n        const dir = path.substring(rootPath.length);\n        const dirParts = dir.split(this.splitSep);\n        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);\n        return result;\n    }\n    #resolveParts(dirParts) {\n        let p = this;\n        for (const part of dirParts){\n            p = p.child(part);\n        }\n        return p;\n    }\n    /**\n     * Returns the cached children Path objects, if still available.  If they\n     * have fallen out of the cache, then returns an empty array, and resets the\n     * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n     * lookup.\n     *\n     * @internal\n     */ children() {\n        const cached = this.#children.get(this);\n        if (cached) {\n            return cached;\n        }\n        const children = Object.assign([], {\n            provisional: 0\n        });\n        this.#children.set(this, children);\n        this.#type &= ~READDIR_CALLED;\n        return children;\n    }\n    /**\n     * Resolves a path portion and returns or creates the child Path.\n     *\n     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n     * `'..'`.\n     *\n     * This should not be called directly.  If `pathPart` contains any path\n     * separators, it will lead to unsafe undefined behavior.\n     *\n     * Use `Path.resolve()` instead.\n     *\n     * @internal\n     */ child(pathPart, opts) {\n        if (pathPart === \"\" || pathPart === \".\") {\n            return this;\n        }\n        if (pathPart === \"..\") {\n            return this.parent || this;\n        }\n        // find the child\n        const children = this.children();\n        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n        for (const p of children){\n            if (p.#matchName === name) {\n                return p;\n            }\n        }\n        // didn't find it, create provisional child, since it might not\n        // actually exist.  If we know the parent isn't a dir, then\n        // in fact it CAN'T exist.\n        const s = this.parent ? this.sep : \"\";\n        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n        const pchild = this.newChild(pathPart, UNKNOWN, {\n            ...opts,\n            parent: this,\n            fullpath\n        });\n        if (!this.canReaddir()) {\n            pchild.#type |= ENOENT;\n        }\n        // don't have to update provisional, because if we have real children,\n        // then provisional is set to children.length, otherwise a lower number\n        children.push(pchild);\n        return pchild;\n    }\n    /**\n     * The relative path from the cwd. If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpath()\n     */ relative() {\n        if (this.isCWD) return \"\";\n        if (this.#relative !== undefined) {\n            return this.#relative;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return this.#relative = this.name;\n        }\n        const pv = p.relative();\n        return pv + (!pv || !p.parent ? \"\" : this.sep) + name;\n    }\n    /**\n     * The relative path from the cwd, using / as the path separator.\n     * If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpathPosix()\n     * On posix systems, this is identical to relative().\n     */ relativePosix() {\n        if (this.sep === \"/\") return this.relative();\n        if (this.isCWD) return \"\";\n        if (this.#relativePosix !== undefined) return this.#relativePosix;\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return this.#relativePosix = this.fullpathPosix();\n        }\n        const pv = p.relativePosix();\n        return pv + (!pv || !p.parent ? \"\" : \"/\") + name;\n    }\n    /**\n     * The fully resolved path string for this Path entry\n     */ fullpath() {\n        if (this.#fullpath !== undefined) {\n            return this.#fullpath;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return this.#fullpath = this.name;\n        }\n        const pv = p.fullpath();\n        const fp = pv + (!p.parent ? \"\" : this.sep) + name;\n        return this.#fullpath = fp;\n    }\n    /**\n     * On platforms other than windows, this is identical to fullpath.\n     *\n     * On windows, this is overridden to return the forward-slash form of the\n     * full UNC path.\n     */ fullpathPosix() {\n        if (this.#fullpathPosix !== undefined) return this.#fullpathPosix;\n        if (this.sep === \"/\") return this.#fullpathPosix = this.fullpath();\n        if (!this.parent) {\n            const p = this.fullpath().replace(/\\\\/g, \"/\");\n            if (/^[a-z]:\\//i.test(p)) {\n                return this.#fullpathPosix = `//?/${p}`;\n            } else {\n                return this.#fullpathPosix = p;\n            }\n        }\n        const p = this.parent;\n        const pfpp = p.fullpathPosix();\n        const fpp = pfpp + (!pfpp || !p.parent ? \"\" : \"/\") + this.name;\n        return this.#fullpathPosix = fpp;\n    }\n    /**\n     * Is the Path of an unknown type?\n     *\n     * Note that we might know *something* about it if there has been a previous\n     * filesystem operation, for example that it does not exist, or is not a\n     * link, or whether it has child entries.\n     */ isUnknown() {\n        return (this.#type & IFMT) === UNKNOWN;\n    }\n    isType(type) {\n        return this[`is${type}`]();\n    }\n    getType() {\n        return this.isUnknown() ? \"Unknown\" : this.isDirectory() ? \"Directory\" : this.isFile() ? \"File\" : this.isSymbolicLink() ? \"SymbolicLink\" : this.isFIFO() ? \"FIFO\" : this.isCharacterDevice() ? \"CharacterDevice\" : this.isBlockDevice() ? \"BlockDevice\" : /* c8 ignore start */ this.isSocket() ? \"Socket\" : \"Unknown\";\n    /* c8 ignore stop */ }\n    /**\n     * Is the Path a regular file?\n     */ isFile() {\n        return (this.#type & IFMT) === IFREG;\n    }\n    /**\n     * Is the Path a directory?\n     */ isDirectory() {\n        return (this.#type & IFMT) === IFDIR;\n    }\n    /**\n     * Is the path a character device?\n     */ isCharacterDevice() {\n        return (this.#type & IFMT) === IFCHR;\n    }\n    /**\n     * Is the path a block device?\n     */ isBlockDevice() {\n        return (this.#type & IFMT) === IFBLK;\n    }\n    /**\n     * Is the path a FIFO pipe?\n     */ isFIFO() {\n        return (this.#type & IFMT) === IFIFO;\n    }\n    /**\n     * Is the path a socket?\n     */ isSocket() {\n        return (this.#type & IFMT) === IFSOCK;\n    }\n    /**\n     * Is the path a symbolic link?\n     */ isSymbolicLink() {\n        return (this.#type & IFLNK) === IFLNK;\n    }\n    /**\n     * Return the entry if it has been subject of a successful lstat, or\n     * undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* simply\n     * mean that we haven't called lstat on it.\n     */ lstatCached() {\n        return this.#type & LSTAT_CALLED ? this : undefined;\n    }\n    /**\n     * Return the cached link target if the entry has been the subject of a\n     * successful readlink, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readlink() has been called at some point.\n     */ readlinkCached() {\n        return this.#linkTarget;\n    }\n    /**\n     * Returns the cached realpath target if the entry has been the subject\n     * of a successful realpath, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * realpath() has been called at some point.\n     */ realpathCached() {\n        return this.#realpath;\n    }\n    /**\n     * Returns the cached child Path entries array if the entry has been the\n     * subject of a successful readdir(), or [] otherwise.\n     *\n     * Does not read the filesystem, so an empty array *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readdir() has been called recently enough to still be valid.\n     */ readdirCached() {\n        const children = this.children();\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n     * any indication that readlink will definitely fail.\n     *\n     * Returns false if the path is known to not be a symlink, if a previous\n     * readlink failed, or if the entry does not exist.\n     */ canReadlink() {\n        if (this.#linkTarget) return true;\n        if (!this.parent) return false;\n        // cases where it cannot possibly succeed\n        const ifmt = this.#type & IFMT;\n        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);\n    }\n    /**\n     * Return true if readdir has previously been successfully called on this\n     * path, indicating that cachedReaddir() is likely valid.\n     */ calledReaddir() {\n        return !!(this.#type & READDIR_CALLED);\n    }\n    /**\n     * Returns true if the path is known to not exist. That is, a previous lstat\n     * or readdir failed to verify its existence when that would have been\n     * expected, or a parent entry was marked either enoent or enotdir.\n     */ isENOENT() {\n        return !!(this.#type & ENOENT);\n    }\n    /**\n     * Return true if the path is a match for the given path name.  This handles\n     * case sensitivity and unicode normalization.\n     *\n     * Note: even on case-sensitive systems, it is **not** safe to test the\n     * equality of the `.name` property to determine whether a given pathname\n     * matches, due to unicode normalization mismatches.\n     *\n     * Always use this method instead of testing the `path.name` property\n     * directly.\n     */ isNamed(n) {\n        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);\n    }\n    /**\n     * Return the Path object corresponding to the target of a symbolic link.\n     *\n     * If the Path is not a symbolic link, or if the readlink call fails for any\n     * reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     */ async readlink() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */ // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */ try {\n            const read = await this.#fs.promises.readlink(this.fullpath());\n            const linkTarget = (await this.parent.realpath())?.resolve(read);\n            if (linkTarget) {\n                return this.#linkTarget = linkTarget;\n            }\n        } catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    /**\n     * Synchronous {@link PathBase.readlink}\n     */ readlinkSync() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */ // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */ try {\n            const read = this.#fs.readlinkSync(this.fullpath());\n            const linkTarget = this.parent.realpathSync()?.resolve(read);\n            if (linkTarget) {\n                return this.#linkTarget = linkTarget;\n            }\n        } catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    #readdirSuccess(children) {\n        // succeeded, mark readdir called bit\n        this.#type |= READDIR_CALLED;\n        // mark all remaining provisional children as ENOENT\n        for(let p = children.provisional; p < children.length; p++){\n            const c = children[p];\n            if (c) c.#markENOENT();\n        }\n    }\n    #markENOENT() {\n        // mark as UNKNOWN and ENOENT\n        if (this.#type & ENOENT) return;\n        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n        this.#markChildrenENOENT();\n    }\n    #markChildrenENOENT() {\n        // all children are provisional and do not exist\n        const children = this.children();\n        children.provisional = 0;\n        for (const p of children){\n            p.#markENOENT();\n        }\n    }\n    #markENOREALPATH() {\n        this.#type |= ENOREALPATH;\n        this.#markENOTDIR();\n    }\n    // save the information when we know the entry is not a dir\n    #markENOTDIR() {\n        // entry is not a directory, so any children can't exist.\n        // this *should* be impossible, since any children created\n        // after it's been marked ENOTDIR should be marked ENOENT,\n        // so it won't even get to this point.\n        /* c8 ignore start */ if (this.#type & ENOTDIR) return;\n        /* c8 ignore stop */ let t = this.#type;\n        // this could happen if we stat a dir, then delete it,\n        // then try to read it or one of its children.\n        if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN;\n        this.#type = t | ENOTDIR;\n        this.#markChildrenENOENT();\n    }\n    #readdirFail(code = \"\") {\n        // markENOTDIR and markENOENT also set provisional=0\n        if (code === \"ENOTDIR\" || code === \"EPERM\") {\n            this.#markENOTDIR();\n        } else if (code === \"ENOENT\") {\n            this.#markENOENT();\n        } else {\n            this.children().provisional = 0;\n        }\n    }\n    #lstatFail(code = \"\") {\n        // Windows just raises ENOENT in this case, disable for win CI\n        /* c8 ignore start */ if (code === \"ENOTDIR\") {\n            // already know it has a parent by this point\n            const p = this.parent;\n            p.#markENOTDIR();\n        } else if (code === \"ENOENT\") {\n            /* c8 ignore stop */ this.#markENOENT();\n        }\n    }\n    #readlinkFail(code = \"\") {\n        let ter = this.#type;\n        ter |= ENOREADLINK;\n        if (code === \"ENOENT\") ter |= ENOENT;\n        // windows gets a weird error when you try to readlink a file\n        if (code === \"EINVAL\" || code === \"UNKNOWN\") {\n            // exists, but not a symlink, we don't know WHAT it is, so remove\n            // all IFMT bits.\n            ter &= IFMT_UNKNOWN;\n        }\n        this.#type = ter;\n        // windows just gets ENOENT in this case.  We do cover the case,\n        // just disabled because it's impossible on Windows CI\n        /* c8 ignore start */ if (code === \"ENOTDIR\" && this.parent) {\n            this.parent.#markENOTDIR();\n        }\n    /* c8 ignore stop */ }\n    #readdirAddChild(e, c) {\n        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);\n    }\n    #readdirAddNewChild(e, c) {\n        // alloc new entry at head, so it's never provisional\n        const type = entToType(e);\n        const child = this.newChild(e.name, type, {\n            parent: this\n        });\n        const ifmt = child.#type & IFMT;\n        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n            child.#type |= ENOTDIR;\n        }\n        c.unshift(child);\n        c.provisional++;\n        return child;\n    }\n    #readdirMaybePromoteChild(e, c) {\n        for(let p = c.provisional; p < c.length; p++){\n            const pchild = c[p];\n            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n            if (name !== pchild.#matchName) {\n                continue;\n            }\n            return this.#readdirPromoteChild(e, pchild, p, c);\n        }\n    }\n    #readdirPromoteChild(e, p, index, c) {\n        const v = p.name;\n        // retain any other flags, but set ifmt from dirent\n        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);\n        // case sensitivity fixing when we learn the true name.\n        if (v !== e.name) p.name = e.name;\n        // just advance provisional index (potentially off the list),\n        // otherwise we have to splice/pop it out and re-insert at head\n        if (index !== c.provisional) {\n            if (index === c.length - 1) c.pop();\n            else c.splice(index, 1);\n            c.unshift(p);\n        }\n        c.provisional++;\n        return p;\n    }\n    /**\n     * Call lstat() on this Path, and update all known information that can be\n     * determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */ async lstat() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n                return this;\n            } catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    /**\n     * synchronous {@link PathBase.lstat}\n     */ lstatSync() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n                return this;\n            } catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    #applyStat(st) {\n        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;\n        this.#atime = atime;\n        this.#atimeMs = atimeMs;\n        this.#birthtime = birthtime;\n        this.#birthtimeMs = birthtimeMs;\n        this.#blksize = blksize;\n        this.#blocks = blocks;\n        this.#ctime = ctime;\n        this.#ctimeMs = ctimeMs;\n        this.#dev = dev;\n        this.#gid = gid;\n        this.#ino = ino;\n        this.#mode = mode;\n        this.#mtime = mtime;\n        this.#mtimeMs = mtimeMs;\n        this.#nlink = nlink;\n        this.#rdev = rdev;\n        this.#size = size;\n        this.#uid = uid;\n        const ifmt = entToType(st);\n        // retain any other flags, but set the ifmt\n        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;\n        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n            this.#type |= ENOTDIR;\n        }\n    }\n    #onReaddirCB;\n    #readdirCBInFlight;\n    #callOnReaddirCB(children) {\n        this.#readdirCBInFlight = false;\n        const cbs = this.#onReaddirCB.slice();\n        this.#onReaddirCB.length = 0;\n        cbs.forEach((cb)=>cb(null, children));\n    }\n    /**\n     * Standard node-style callback interface to get list of directory entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     *\n     * @param cb The callback called with (er, entries).  Note that the `er`\n     * param is somewhat extraneous, as all readdir() errors are handled and\n     * simply result in an empty set of entries being returned.\n     * @param allowZalgo Boolean indicating that immediately known results should\n     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n     * zalgo at your peril, the dark pony lord is devious and unforgiving.\n     */ readdirCB(cb, allowZalgo = false) {\n        if (!this.canReaddir()) {\n            if (allowZalgo) cb(null, []);\n            else queueMicrotask(()=>cb(null, []));\n            return;\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            const c = children.slice(0, children.provisional);\n            if (allowZalgo) cb(null, c);\n            else queueMicrotask(()=>cb(null, c));\n            return;\n        }\n        // don't have to worry about zalgo at this point.\n        this.#onReaddirCB.push(cb);\n        if (this.#readdirCBInFlight) {\n            return;\n        }\n        this.#readdirCBInFlight = true;\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        this.#fs.readdir(fullpath, {\n            withFileTypes: true\n        }, (er, entries)=>{\n            if (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            } else {\n                // if we didn't get an error, we always get entries.\n                //@ts-ignore\n                for (const e of entries){\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            this.#callOnReaddirCB(children.slice(0, children.provisional));\n            return;\n        });\n    }\n    #asyncReaddirInFlight;\n    /**\n     * Return an array of known child entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */ async readdir() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        if (this.#asyncReaddirInFlight) {\n            await this.#asyncReaddirInFlight;\n        } else {\n            /* c8 ignore start */ let resolve = ()=>{};\n            /* c8 ignore stop */ this.#asyncReaddirInFlight = new Promise((res)=>resolve = res);\n            try {\n                for (const e of (await this.#fs.promises.readdir(fullpath, {\n                    withFileTypes: true\n                }))){\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            } catch (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            this.#asyncReaddirInFlight = undefined;\n            resolve();\n        }\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * synchronous {@link PathBase.readdir}\n     */ readdirSync() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        try {\n            for (const e of this.#fs.readdirSync(fullpath, {\n                withFileTypes: true\n            })){\n                this.#readdirAddChild(e, children);\n            }\n            this.#readdirSuccess(children);\n        } catch (er) {\n            this.#readdirFail(er.code);\n            children.provisional = 0;\n        }\n        return children.slice(0, children.provisional);\n    }\n    canReaddir() {\n        if (this.#type & ENOCHILD) return false;\n        const ifmt = IFMT & this.#type;\n        // we always set ENOTDIR when setting IFMT, so should be impossible\n        /* c8 ignore start */ if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n            return false;\n        }\n        /* c8 ignore stop */ return true;\n    }\n    shouldWalk(dirs, walkFilter) {\n        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));\n    }\n    /**\n     * Return the Path object corresponding to path as resolved\n     * by realpath(3).\n     *\n     * If the realpath call fails for any reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     * On success, returns a Path object.\n     */ async realpath() {\n        if (this.#realpath) return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n        try {\n            const rp = await this.#fs.promises.realpath(this.fullpath());\n            return this.#realpath = this.resolve(rp);\n        } catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Synchronous {@link realpath}\n     */ realpathSync() {\n        if (this.#realpath) return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n        try {\n            const rp = this.#fs.realpathSync(this.fullpath());\n            return this.#realpath = this.resolve(rp);\n        } catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Internal method to mark this Path object as the scurry cwd,\n     * called by {@link PathScurry#chdir}\n     *\n     * @internal\n     */ [setAsCwd](oldCwd) {\n        if (oldCwd === this) return;\n        oldCwd.isCWD = false;\n        this.isCWD = true;\n        const changed = new Set([]);\n        let rp = [];\n        let p = this;\n        while(p && p.parent){\n            changed.add(p);\n            p.#relative = rp.join(this.sep);\n            p.#relativePosix = rp.join(\"/\");\n            p = p.parent;\n            rp.push(\"..\");\n        }\n        // now un-memoize parents of old cwd\n        p = oldCwd;\n        while(p && p.parent && !changed.has(p)){\n            p.#relative = undefined;\n            p.#relativePosix = undefined;\n            p = p.parent;\n        }\n    }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */ class PathWin32 extends PathBase {\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){\n        super(name, type, root, roots, nocase, children, opts);\n        /**\n     * Separator for generating path strings.\n     */ this.sep = \"\\\\\";\n        /**\n     * Separator for parsing path strings.\n     */ this.splitSep = eitherSep;\n    }\n    /**\n     * @internal\n     */ newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n    /**\n     * @internal\n     */ getRootString(path) {\n        return node_path_1.win32.parse(path).root;\n    }\n    /**\n     * @internal\n     */ getRoot(rootPath) {\n        rootPath = uncToDrive(rootPath.toUpperCase());\n        if (rootPath === this.root.name) {\n            return this.root;\n        }\n        // ok, not that one, check if it matches another we know about\n        for (const [compare, root] of Object.entries(this.roots)){\n            if (this.sameRoot(rootPath, compare)) {\n                return this.roots[rootPath] = root;\n            }\n        }\n        // otherwise, have to create a new one.\n        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;\n    }\n    /**\n     * @internal\n     */ sameRoot(rootPath, compare = this.root.name) {\n        // windows can (rarely) have case-sensitive filesystem, but\n        // UNC and drive letters are always case-insensitive, and canonically\n        // represented uppercase.\n        rootPath = rootPath.toUpperCase().replace(/\\//g, \"\\\\\").replace(uncDriveRegexp, \"$1\\\\\");\n        return rootPath === compare;\n    }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */ class PathPosix extends PathBase {\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){\n        super(name, type, root, roots, nocase, children, opts);\n        /**\n     * separator for parsing path strings\n     */ this.splitSep = \"/\";\n        /**\n     * separator for generating path strings\n     */ this.sep = \"/\";\n    }\n    /**\n     * @internal\n     */ getRootString(path) {\n        return path.startsWith(\"/\") ? \"/\" : \"\";\n    }\n    /**\n     * @internal\n     */ getRoot(_rootPath) {\n        return this.root;\n    }\n    /**\n     * @internal\n     */ newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */ class PathScurryBase {\n    #resolveCache;\n    #resolvePosixCache;\n    #children;\n    #fs;\n    /**\n     * This class should not be instantiated directly.\n     *\n     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n     *\n     * @internal\n     */ constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}){\n        this.#fs = fsFromOption(fs);\n        if (cwd instanceof URL || cwd.startsWith(\"file://\")) {\n            cwd = (0, node_url_1.fileURLToPath)(cwd);\n        }\n        // resolve and split root, and then add to the store.\n        // this is the only time we call path.resolve()\n        const cwdPath = pathImpl.resolve(cwd);\n        this.roots = Object.create(null);\n        this.rootPath = this.parseRootPath(cwdPath);\n        this.#resolveCache = new ResolveCache();\n        this.#resolvePosixCache = new ResolveCache();\n        this.#children = new ChildrenCache(childrenCacheSize);\n        const split = cwdPath.substring(this.rootPath.length).split(sep);\n        // resolve('/') leaves '', splits to [''], we don't want that.\n        if (split.length === 1 && !split[0]) {\n            split.pop();\n        }\n        /* c8 ignore start */ if (nocase === undefined) {\n            throw new TypeError(\"must provide nocase setting to PathScurryBase ctor\");\n        }\n        /* c8 ignore stop */ this.nocase = nocase;\n        this.root = this.newRoot(this.#fs);\n        this.roots[this.rootPath] = this.root;\n        let prev = this.root;\n        let len = split.length - 1;\n        const joinSep = pathImpl.sep;\n        let abs = this.rootPath;\n        let sawFirst = false;\n        for (const part of split){\n            const l = len--;\n            prev = prev.child(part, {\n                relative: new Array(l).fill(\"..\").join(joinSep),\n                relativePosix: new Array(l).fill(\"..\").join(\"/\"),\n                fullpath: abs += (sawFirst ? \"\" : joinSep) + part\n            });\n            sawFirst = true;\n        }\n        this.cwd = prev;\n    }\n    /**\n     * Get the depth of a provided path, string, or the cwd\n     */ depth(path = this.cwd) {\n        if (typeof path === \"string\") {\n            path = this.cwd.resolve(path);\n        }\n        return path.depth();\n    }\n    /**\n     * Return the cache of child entries.  Exposed so subclasses can create\n     * child Path objects in a platform-specific way.\n     *\n     * @internal\n     */ childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */ resolve(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = \"\";\n        for(let i = paths.length - 1; i >= 0; i--){\n            const p = paths[i];\n            if (!p || p === \".\") continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolveCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpath();\n        this.#resolveCache.set(r, result);\n        return result;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string, returning\n     * the posix path.  Identical to .resolve() on posix systems, but on\n     * windows will return a forward-slash separated UNC path.\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */ resolvePosix(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = \"\";\n        for(let i = paths.length - 1; i >= 0; i--){\n            const p = paths[i];\n            if (!p || p === \".\") continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolvePosixCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpathPosix();\n        this.#resolvePosixCache.set(r, result);\n        return result;\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or entry\n     */ relative(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relative();\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or\n     * entry, using / as the path delimiter, even on Windows.\n     */ relativePosix(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relativePosix();\n    }\n    /**\n     * Return the basename for the provided string or Path object\n     */ basename(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.name;\n    }\n    /**\n     * Return the dirname for the provided string or Path object\n     */ dirname(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return (entry.parent || entry).fullpath();\n    }\n    async readdir(entry = this.cwd, opts = {\n        withFileTypes: true\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        } else {\n            const p = await entry.readdir();\n            return withFileTypes ? p : p.map((e)=>e.name);\n        }\n    }\n    readdirSync(entry = this.cwd, opts = {\n        withFileTypes: true\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        } else if (withFileTypes) {\n            return entry.readdirSync();\n        } else {\n            return entry.readdirSync().map((e)=>e.name);\n        }\n    }\n    /**\n     * Call lstat() on the string or Path object, and update all known\n     * information that can be determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */ async lstat(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstat();\n    }\n    /**\n     * synchronous {@link PathScurryBase.lstat}\n     */ lstatSync(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstatSync();\n    }\n    async readlink(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.readlink();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    readlinkSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.readlinkSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async realpath(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.realpath();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    realpathSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.realpathSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async walk(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const walk = (dir, cb)=>{\n            dirs.add(dir);\n            dir.readdirCB((er, entries)=>{\n                /* c8 ignore start */ if (er) {\n                    return cb(er);\n                }\n                /* c8 ignore stop */ let len = entries.length;\n                if (!len) return cb();\n                const next = ()=>{\n                    if (--len === 0) {\n                        cb();\n                    }\n                };\n                for (const e of entries){\n                    if (!filter || filter(e)) {\n                        results.push(withFileTypes ? e : e.fullpath());\n                    }\n                    if (follow && e.isSymbolicLink()) {\n                        e.realpath().then((r)=>r?.isUnknown() ? r.lstat() : r).then((r)=>r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n                    } else {\n                        if (e.shouldWalk(dirs, walkFilter)) {\n                            walk(e, next);\n                        } else {\n                            next();\n                        }\n                    }\n                }\n            }, true); // zalgooooooo\n        };\n        const start = entry;\n        return new Promise((res, rej)=>{\n            walk(start, (er)=>{\n                /* c8 ignore start */ if (er) return rej(er);\n                /* c8 ignore stop */ res(results);\n            });\n        });\n    }\n    walkSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set([\n            entry\n        ]);\n        for (const dir of dirs){\n            const entries = dir.readdirSync();\n            for (const e of entries){\n                if (!filter || filter(e)) {\n                    results.push(withFileTypes ? e : e.fullpath());\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync()))) continue;\n                    if (r.isUnknown()) r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Support for `for await`\n     *\n     * Alias for {@link PathScurryBase.iterate}\n     *\n     * Note: As of Node 19, this is very slow, compared to other methods of\n     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n     */ [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate(entry = this.cwd, options = {}) {\n        // iterating async over the stream is significantly more performant,\n        // especially in the warm-cache scenario, because it buffers up directory\n        // entries in the background instead of waiting for a yield for each one.\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            options = entry;\n            entry = this.cwd;\n        }\n        return this.stream(entry, options)[Symbol.asyncIterator]();\n    }\n    /**\n     * Iterating over a PathScurry performs a synchronous walk.\n     *\n     * Alias for {@link PathScurryBase.iterateSync}\n     */ [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    *iterateSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        if (!filter || filter(entry)) {\n            yield withFileTypes ? entry : entry.fullpath();\n        }\n        const dirs = new Set([\n            entry\n        ]);\n        for (const dir of dirs){\n            const entries = dir.readdirSync();\n            for (const e of entries){\n                if (!filter || filter(e)) {\n                    yield withFileTypes ? e : e.fullpath();\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync()))) continue;\n                    if (r.isUnknown()) r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n    }\n    stream(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = new minipass_1.Minipass({\n            objectMode: true\n        });\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const queue = [\n            entry\n        ];\n        let processing = 0;\n        const process1 = ()=>{\n            let paused = false;\n            while(!paused){\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0) results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const onReaddir = (er, entries, didRealpaths = false)=>{\n                    /* c8 ignore start */ if (er) return results.emit(\"error\", er);\n                    /* c8 ignore stop */ if (follow && !didRealpaths) {\n                        const promises = [];\n                        for (const e of entries){\n                            if (e.isSymbolicLink()) {\n                                promises.push(e.realpath().then((r)=>r?.isUnknown() ? r.lstat() : r));\n                            }\n                        }\n                        if (promises.length) {\n                            Promise.all(promises).then(()=>onReaddir(null, entries, true));\n                            return;\n                        }\n                    }\n                    for (const e of entries){\n                        if (e && (!filter || filter(e))) {\n                            if (!results.write(withFileTypes ? e : e.fullpath())) {\n                                paused = true;\n                            }\n                        }\n                    }\n                    processing--;\n                    for (const e of entries){\n                        const r = e.realpathCached() || e;\n                        if (r.shouldWalk(dirs, walkFilter)) {\n                            queue.push(r);\n                        }\n                    }\n                    if (paused && !results.flowing) {\n                        results.once(\"drain\", process1);\n                    } else if (!sync) {\n                        process1();\n                    }\n                };\n                // zalgo containment\n                let sync = true;\n                dir.readdirCB(onReaddir, true);\n                sync = false;\n            }\n        };\n        process1();\n        return results;\n    }\n    streamSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = new minipass_1.Minipass({\n            objectMode: true\n        });\n        const dirs = new Set();\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const queue = [\n            entry\n        ];\n        let processing = 0;\n        const process1 = ()=>{\n            let paused = false;\n            while(!paused){\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0) results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const entries = dir.readdirSync();\n                for (const e of entries){\n                    if (!filter || filter(e)) {\n                        if (!results.write(withFileTypes ? e : e.fullpath())) {\n                            paused = true;\n                        }\n                    }\n                }\n                processing--;\n                for (const e of entries){\n                    let r = e;\n                    if (e.isSymbolicLink()) {\n                        if (!(follow && (r = e.realpathSync()))) continue;\n                        if (r.isUnknown()) r.lstatSync();\n                    }\n                    if (r.shouldWalk(dirs, walkFilter)) {\n                        queue.push(r);\n                    }\n                }\n            }\n            if (paused && !results.flowing) results.once(\"drain\", process1);\n        };\n        process1();\n        return results;\n    }\n    chdir(path = this.cwd) {\n        const oldCwd = this.cwd;\n        this.cwd = typeof path === \"string\" ? this.cwd.resolve(path) : path;\n        this.cwd[setAsCwd](oldCwd);\n    }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */ class PathScurryWin32 extends PathScurryBase {\n    constructor(cwd = process.cwd(), opts = {}){\n        const { nocase = true } = opts;\n        super(cwd, node_path_1.win32, \"\\\\\", {\n            ...opts,\n            nocase\n        });\n        /**\n     * separator for generating path strings\n     */ this.sep = \"\\\\\";\n        this.nocase = nocase;\n        for(let p = this.cwd; p; p = p.parent){\n            p.nocase = this.nocase;\n        }\n    }\n    /**\n     * @internal\n     */ parseRootPath(dir) {\n        // if the path starts with a single separator, it's not a UNC, and we'll\n        // just get separator as the root, and driveFromUNC will return \\\n        // In that case, mount \\ on the root from the cwd.\n        return node_path_1.win32.parse(dir).root.toUpperCase();\n    }\n    /**\n     * @internal\n     */ newRoot(fs) {\n        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n            fs\n        });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */ isAbsolute(p) {\n        return p.startsWith(\"/\") || p.startsWith(\"\\\\\") || /^[a-z]:(\\/|\\\\)/i.test(p);\n    }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */ class PathScurryPosix extends PathScurryBase {\n    constructor(cwd = process.cwd(), opts = {}){\n        const { nocase = false } = opts;\n        super(cwd, node_path_1.posix, \"/\", {\n            ...opts,\n            nocase\n        });\n        /**\n     * separator for generating path strings\n     */ this.sep = \"/\";\n        this.nocase = nocase;\n    }\n    /**\n     * @internal\n     */ parseRootPath(_dir) {\n        return \"/\";\n    }\n    /**\n     * @internal\n     */ newRoot(fs) {\n        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n            fs\n        });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */ isAbsolute(p) {\n        return p.startsWith(\"/\");\n    }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */ class PathScurryDarwin extends PathScurryPosix {\n    constructor(cwd = process.cwd(), opts = {}){\n        const { nocase = true } = opts;\n        super(cwd, {\n            ...opts,\n            nocase\n        });\n    }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */ exports.Path = process.platform === \"win32\" ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */ exports.PathScurry = process.platform === \"win32\" ? PathScurryWin32 : process.platform === \"darwin\" ? PathScurryDarwin : PathScurryPosix; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGF0aC1zY3VycnkvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsSUFBSyxJQUFJLElBQUksQ0FBQ0Esa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLElBQUssSUFBSSxJQUFJLENBQUNBLFlBQVksSUFBSyxT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O0NBS0MsR0FDRFAsa0JBQWtCLEdBQUc0TixRQUFRNEQsUUFBUSxLQUFLLFVBQVVuUixrQkFDOUN1TixRQUFRNEQsUUFBUSxLQUFLLFdBQVdyUixtQkFDNUJDLGlCQUNWLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvcGF0aC1zY3VycnkvZGlzdC9jb21tb25qcy9pbmRleC5qcz81ZWY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGhTY3VycnkgPSBleHBvcnRzLlBhdGggPSBleHBvcnRzLlBhdGhTY3VycnlEYXJ3aW4gPSBleHBvcnRzLlBhdGhTY3VycnlQb3NpeCA9IGV4cG9ydHMuUGF0aFNjdXJyeVdpbjMyID0gZXhwb3J0cy5QYXRoU2N1cnJ5QmFzZSA9IGV4cG9ydHMuUGF0aFBvc2l4ID0gZXhwb3J0cy5QYXRoV2luMzIgPSBleHBvcnRzLlBhdGhCYXNlID0gZXhwb3J0cy5DaGlsZHJlbkNhY2hlID0gZXhwb3J0cy5SZXNvbHZlQ2FjaGUgPSB2b2lkIDA7XG5jb25zdCBscnVfY2FjaGVfMSA9IHJlcXVpcmUoXCJscnUtY2FjaGVcIik7XG5jb25zdCBub2RlX3BhdGhfMSA9IHJlcXVpcmUoXCJub2RlOnBhdGhcIik7XG5jb25zdCBub2RlX3VybF8xID0gcmVxdWlyZShcIm5vZGU6dXJsXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IGFjdHVhbEZTID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJub2RlOmZzXCIpKTtcbmNvbnN0IHJlYWxwYXRoU3luYyA9IGZzXzEucmVhbHBhdGhTeW5jLm5hdGl2ZTtcbi8vIFRPRE86IHRlc3QgcGVyZiBvZiBmcy9wcm9taXNlcyByZWFscGF0aCB2cyByZWFscGF0aENCLFxuLy8gc2luY2UgdGhlIHByb21pc2VzIG9uZSB1c2VzIHJlYWxwYXRoLm5hdGl2ZVxuY29uc3QgcHJvbWlzZXNfMSA9IHJlcXVpcmUoXCJub2RlOmZzL3Byb21pc2VzXCIpO1xuY29uc3QgbWluaXBhc3NfMSA9IHJlcXVpcmUoXCJtaW5pcGFzc1wiKTtcbmNvbnN0IGRlZmF1bHRGUyA9IHtcbiAgICBsc3RhdFN5bmM6IGZzXzEubHN0YXRTeW5jLFxuICAgIHJlYWRkaXI6IGZzXzEucmVhZGRpcixcbiAgICByZWFkZGlyU3luYzogZnNfMS5yZWFkZGlyU3luYyxcbiAgICByZWFkbGlua1N5bmM6IGZzXzEucmVhZGxpbmtTeW5jLFxuICAgIHJlYWxwYXRoU3luYyxcbiAgICBwcm9taXNlczoge1xuICAgICAgICBsc3RhdDogcHJvbWlzZXNfMS5sc3RhdCxcbiAgICAgICAgcmVhZGRpcjogcHJvbWlzZXNfMS5yZWFkZGlyLFxuICAgICAgICByZWFkbGluazogcHJvbWlzZXNfMS5yZWFkbGluayxcbiAgICAgICAgcmVhbHBhdGg6IHByb21pc2VzXzEucmVhbHBhdGgsXG4gICAgfSxcbn07XG4vLyBpZiB0aGV5IGp1c3QgZ2F2ZSB1cyByZXF1aXJlKCdmcycpIHRoZW4gdXNlIG91ciBkZWZhdWx0XG5jb25zdCBmc0Zyb21PcHRpb24gPSAoZnNPcHRpb24pID0+ICFmc09wdGlvbiB8fCBmc09wdGlvbiA9PT0gZGVmYXVsdEZTIHx8IGZzT3B0aW9uID09PSBhY3R1YWxGUyA/XG4gICAgZGVmYXVsdEZTXG4gICAgOiB7XG4gICAgICAgIC4uLmRlZmF1bHRGUyxcbiAgICAgICAgLi4uZnNPcHRpb24sXG4gICAgICAgIHByb21pc2VzOiB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0RlMucHJvbWlzZXMsXG4gICAgICAgICAgICAuLi4oZnNPcHRpb24ucHJvbWlzZXMgfHwge30pLFxuICAgICAgICB9LFxuICAgIH07XG4vLyB0dXJuIHNvbWV0aGluZyBsaWtlIC8vPy9jOi8gaW50byBjOlxcXG5jb25zdCB1bmNEcml2ZVJlZ2V4cCA9IC9eXFxcXFxcXFxcXD9cXFxcKFthLXpdOilcXFxcPyQvaTtcbmNvbnN0IHVuY1RvRHJpdmUgPSAocm9vdFBhdGgpID0+IHJvb3RQYXRoLnJlcGxhY2UoL1xcLy9nLCAnXFxcXCcpLnJlcGxhY2UodW5jRHJpdmVSZWdleHAsICckMVxcXFwnKTtcbi8vIHdpbmRvd3MgcGF0aHMgYXJlIHNlcGFyYXRlZCBieSBlaXRoZXIgLyBvciBcXFxuY29uc3QgZWl0aGVyU2VwID0gL1tcXFxcXFwvXS87XG5jb25zdCBVTktOT1dOID0gMDsgLy8gbWF5IG5vdCBldmVuIGV4aXN0LCBmb3IgYWxsIHdlIGtub3dcbmNvbnN0IElGSUZPID0gMGIwMDAxO1xuY29uc3QgSUZDSFIgPSAwYjAwMTA7XG5jb25zdCBJRkRJUiA9IDBiMDEwMDtcbmNvbnN0IElGQkxLID0gMGIwMTEwO1xuY29uc3QgSUZSRUcgPSAwYjEwMDA7XG5jb25zdCBJRkxOSyA9IDBiMTAxMDtcbmNvbnN0IElGU09DSyA9IDBiMTEwMDtcbmNvbnN0IElGTVQgPSAwYjExMTE7XG4vLyBtYXNrIHRvIHVuc2V0IGxvdyA0IGJpdHNcbmNvbnN0IElGTVRfVU5LTk9XTiA9IH5JRk1UO1xuLy8gc2V0IGFmdGVyIHN1Y2Nlc3NmdWxseSBjYWxsaW5nIHJlYWRkaXIoKSBhbmQgZ2V0dGluZyBlbnRyaWVzLlxuY29uc3QgUkVBRERJUl9DQUxMRUQgPSAwYjAwMDBfMDAwMV8wMDAwO1xuLy8gc2V0IGFmdGVyIGEgc3VjY2Vzc2Z1bCBsc3RhdCgpXG5jb25zdCBMU1RBVF9DQUxMRUQgPSAwYjAwMDBfMDAxMF8wMDAwO1xuLy8gc2V0IGlmIGFuIGVudHJ5IChvciBvbmUgb2YgaXRzIHBhcmVudHMpIGlzIGRlZmluaXRlbHkgbm90IGEgZGlyXG5jb25zdCBFTk9URElSID0gMGIwMDAwXzAxMDBfMDAwMDtcbi8vIHNldCBpZiBhbiBlbnRyeSAob3Igb25lIG9mIGl0cyBwYXJlbnRzKSBkb2VzIG5vdCBleGlzdFxuLy8gKGNhbiBhbHNvIGJlIHNldCBvbiBsc3RhdCBlcnJvcnMgbGlrZSBFQUNDRVMgb3IgRU5BTUVUT09MT05HKVxuY29uc3QgRU5PRU5UID0gMGIwMDAwXzEwMDBfMDAwMDtcbi8vIGNhbm5vdCBoYXZlIGNoaWxkIGVudHJpZXMgLS0gYWxzbyB2ZXJpZnkgJklGTVQgaXMgZWl0aGVyIElGRElSIG9yIElGTE5LXG4vLyBzZXQgaWYgd2UgZmFpbCB0byByZWFkbGlua1xuY29uc3QgRU5PUkVBRExJTksgPSAwYjAwMDFfMDAwMF8wMDAwO1xuLy8gc2V0IGlmIHdlIGtub3cgcmVhbHBhdGgoKSB3aWxsIGZhaWxcbmNvbnN0IEVOT1JFQUxQQVRIID0gMGIwMDEwXzAwMDBfMDAwMDtcbmNvbnN0IEVOT0NISUxEID0gRU5PVERJUiB8IEVOT0VOVCB8IEVOT1JFQUxQQVRIO1xuY29uc3QgVFlQRU1BU0sgPSAwYjAwMTFfMTExMV8xMTExO1xuY29uc3QgZW50VG9UeXBlID0gKHMpID0+IHMuaXNGaWxlKCkgPyBJRlJFR1xuICAgIDogcy5pc0RpcmVjdG9yeSgpID8gSUZESVJcbiAgICAgICAgOiBzLmlzU3ltYm9saWNMaW5rKCkgPyBJRkxOS1xuICAgICAgICAgICAgOiBzLmlzQ2hhcmFjdGVyRGV2aWNlKCkgPyBJRkNIUlxuICAgICAgICAgICAgICAgIDogcy5pc0Jsb2NrRGV2aWNlKCkgPyBJRkJMS1xuICAgICAgICAgICAgICAgICAgICA6IHMuaXNTb2NrZXQoKSA/IElGU09DS1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBzLmlzRklGTygpID8gSUZJRk9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFVOS05PV047XG4vLyBub3JtYWxpemUgdW5pY29kZSBwYXRoIG5hbWVzXG5jb25zdCBub3JtYWxpemVDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IG5vcm1hbGl6ZSA9IChzKSA9PiB7XG4gICAgY29uc3QgYyA9IG5vcm1hbGl6ZUNhY2hlLmdldChzKTtcbiAgICBpZiAoYylcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgY29uc3QgbiA9IHMubm9ybWFsaXplKCdORktEJyk7XG4gICAgbm9ybWFsaXplQ2FjaGUuc2V0KHMsIG4pO1xuICAgIHJldHVybiBuO1xufTtcbmNvbnN0IG5vcm1hbGl6ZU5vY2FzZUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qgbm9ybWFsaXplTm9jYXNlID0gKHMpID0+IHtcbiAgICBjb25zdCBjID0gbm9ybWFsaXplTm9jYXNlQ2FjaGUuZ2V0KHMpO1xuICAgIGlmIChjKVxuICAgICAgICByZXR1cm4gYztcbiAgICBjb25zdCBuID0gbm9ybWFsaXplKHMudG9Mb3dlckNhc2UoKSk7XG4gICAgbm9ybWFsaXplTm9jYXNlQ2FjaGUuc2V0KHMsIG4pO1xuICAgIHJldHVybiBuO1xufTtcbi8qKlxuICogQW4gTFJVQ2FjaGUgZm9yIHN0b3JpbmcgcmVzb2x2ZWQgcGF0aCBzdHJpbmdzIG9yIFBhdGggb2JqZWN0cy5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBSZXNvbHZlQ2FjaGUgZXh0ZW5kcyBscnVfY2FjaGVfMS5MUlVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHsgbWF4OiAyNTYgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZlQ2FjaGUgPSBSZXNvbHZlQ2FjaGU7XG4vLyBJbiBvcmRlciB0byBwcmV2ZW50IGJsb3dpbmcgb3V0IHRoZSBqcyBoZWFwIGJ5IGFsbG9jYXRpbmcgaHVuZHJlZHMgb2Zcbi8vIHRob3VzYW5kcyBvZiBQYXRoIGVudHJpZXMgd2hlbiB3YWxraW5nIGV4dHJlbWVseSBsYXJnZSB0cmVlcywgdGhlIFwiY2hpbGRyZW5cIlxuLy8gaW4gdGhpcyB0cmVlIGFyZSByZXByZXNlbnRlZCBieSBzdG9yaW5nIGFuIGFycmF5IG9mIFBhdGggZW50cmllcyBpbiBhblxuLy8gTFJVQ2FjaGUsIGluZGV4ZWQgYnkgdGhlIHBhcmVudC4gIEF0IGFueSB0aW1lLCBQYXRoLmNoaWxkcmVuKCkgbWF5IHJldHVybiBhblxuLy8gZW1wdHkgYXJyYXksIGluZGljYXRpbmcgdGhhdCBpdCBkb2Vzbid0IGtub3cgYWJvdXQgYW55IG9mIGl0cyBjaGlsZHJlbiwgYW5kXG4vLyB0aHVzIGhhcyB0byByZWJ1aWxkIHRoYXQgY2FjaGUuICBUaGlzIGlzIGZpbmUsIGl0IGp1c3QgbWVhbnMgdGhhdCB3ZSBkb24ndFxuLy8gYmVuZWZpdCBhcyBtdWNoIGZyb20gaGF2aW5nIHRoZSBjYWNoZWQgZW50cmllcywgYnV0IGh1Z2UgZGlyZWN0b3J5IHdhbGtzXG4vLyBkb24ndCBibG93IG91dCB0aGUgc3RhY2ssIGFuZCBzbWFsbGVyIG9uZXMgYXJlIHN0aWxsIGFzIGZhc3QgYXMgcG9zc2libGUuXG4vL1xuLy9JdCBkb2VzIGltcG9zZSBzb21lIGNvbXBsZXhpdHkgd2hlbiBidWlsZGluZyB1cCB0aGUgcmVhZGRpciBkYXRhLCBiZWNhdXNlIHdlXG4vL25lZWQgdG8gcGFzcyBhIHJlZmVyZW5jZSB0byB0aGUgY2hpbGRyZW4gYXJyYXkgdGhhdCB3ZSBzdGFydGVkIHdpdGguXG4vKipcbiAqIGFuIExSVUNhY2hlIGZvciBzdG9yaW5nIGNoaWxkIGVudHJpZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ2hpbGRyZW5DYWNoZSBleHRlbmRzIGxydV9jYWNoZV8xLkxSVUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhTaXplID0gMTYgKiAxMDI0KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG1heFNpemUsXG4gICAgICAgICAgICAvLyBwYXJlbnQgKyBjaGlsZHJlblxuICAgICAgICAgICAgc2l6ZUNhbGN1bGF0aW9uOiBhID0+IGEubGVuZ3RoICsgMSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGlsZHJlbkNhY2hlID0gQ2hpbGRyZW5DYWNoZTtcbmNvbnN0IHNldEFzQ3dkID0gU3ltYm9sKCdQYXRoU2N1cnJ5IHNldEFzQ3dkJyk7XG4vKipcbiAqIFBhdGggb2JqZWN0cyBhcmUgc29ydCBvZiBsaWtlIGEgc3VwZXItcG93ZXJlZFxuICoge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC9hcGkvZnMuaHRtbCNjbGFzcy1mc2RpcmVudCBmcy5EaXJlbnR9XG4gKlxuICogRWFjaCBvbmUgcmVwcmVzZW50cyBhIHNpbmdsZSBmaWxlc3lzdGVtIGVudHJ5IG9uIGRpc2ssIHdoaWNoIG1heSBvciBtYXkgbm90XG4gKiBleGlzdC4gSXQgaW5jbHVkZXMgbWV0aG9kcyBmb3IgcmVhZGluZyB2YXJpb3VzIHR5cGVzIG9mIGluZm9ybWF0aW9uIHZpYVxuICogbHN0YXQsIHJlYWRsaW5rLCBhbmQgcmVhZGRpciwgYW5kIGNhY2hlcyBhbGwgaW5mb3JtYXRpb24gdG8gdGhlIGdyZWF0ZXN0XG4gKiBkZWdyZWUgcG9zc2libGUuXG4gKlxuICogTm90ZSB0aGF0IGZzIG9wZXJhdGlvbnMgdGhhdCB3b3VsZCBub3JtYWxseSB0aHJvdyB3aWxsIGluc3RlYWQgcmV0dXJuIGFuXG4gKiBcImVtcHR5XCIgdmFsdWUuIFRoaXMgaXMgaW4gb3JkZXIgdG8gcHJldmVudCBleGNlc3NpdmUgb3ZlcmhlYWQgZnJvbSBlcnJvclxuICogc3RhY2sgdHJhY2VzLlxuICovXG5jbGFzcyBQYXRoQmFzZSB7XG4gICAgLyoqXG4gICAgICogdGhlIGJhc2VuYW1lIG9mIHRoaXMgcGF0aFxuICAgICAqXG4gICAgICogKipJbXBvcnRhbnQqKjogKmFsd2F5cyogdGVzdCB0aGUgcGF0aCBuYW1lIGFnYWluc3QgYW55IHRlc3Qgc3RyaW5nXG4gICAgICogdXNpbmd0aGUge0BsaW5rIGlzTmFtZWR9IG1ldGhvZCwgYW5kIG5vdCBieSBkaXJlY3RseSBjb21wYXJpbmcgdGhpc1xuICAgICAqIHN0cmluZy4gT3RoZXJ3aXNlLCB1bmljb2RlIHBhdGggc3RyaW5ncyB0aGF0IHRoZSBzeXN0ZW0gc2VlcyBhcyBpZGVudGljYWxcbiAgICAgKiB3aWxsIG5vdCBiZSBwcm9wZXJseSB0cmVhdGVkIGFzIHRoZSBzYW1lIHBhdGgsIGxlYWRpbmcgdG8gaW5jb3JyZWN0XG4gICAgICogYmVoYXZpb3IgYW5kIHBvc3NpYmxlIHNlY3VyaXR5IGlzc3Vlcy5cbiAgICAgKi9cbiAgICBuYW1lO1xuICAgIC8qKlxuICAgICAqIHRoZSBQYXRoIGVudHJ5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBhdGggcm9vdC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJvb3Q7XG4gICAgLyoqXG4gICAgICogQWxsIHJvb3RzIGZvdW5kIHdpdGhpbiB0aGUgY3VycmVudCBQYXRoU2N1cnJ5IGZhbWlseVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcm9vdHM7XG4gICAgLyoqXG4gICAgICogYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBwYXRoLCBvciB1bmRlZmluZWQgaW4gdGhlIGNhc2Ugb2Ygcm9vdCBlbnRyaWVzXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYXJlbnQ7XG4gICAgLyoqXG4gICAgICogYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgcGF0aHMgYXJlIGNvbXBhcmVkIGNhc2UtaW5zZW5zaXRpdmVseVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5vY2FzZTtcbiAgICAvKipcbiAgICAgKiBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGlzIHBhdGggaXMgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAgICAgKiBvZiB0aGUgUGF0aFNjdXJyeSBjb2xsZWN0aW9uIHRoYXQgY29udGFpbnMgaXQuXG4gICAgICovXG4gICAgaXNDV0QgPSBmYWxzZTtcbiAgICAvLyBwb3RlbnRpYWwgZGVmYXVsdCBmcyBvdmVycmlkZVxuICAgICNmcztcbiAgICAvLyBTdGF0cyBmaWVsZHNcbiAgICAjZGV2O1xuICAgIGdldCBkZXYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZXY7XG4gICAgfVxuICAgICNtb2RlO1xuICAgIGdldCBtb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbW9kZTtcbiAgICB9XG4gICAgI25saW5rO1xuICAgIGdldCBubGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI25saW5rO1xuICAgIH1cbiAgICAjdWlkO1xuICAgIGdldCB1aWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN1aWQ7XG4gICAgfVxuICAgICNnaWQ7XG4gICAgZ2V0IGdpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2dpZDtcbiAgICB9XG4gICAgI3JkZXY7XG4gICAgZ2V0IHJkZXYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZGV2O1xuICAgIH1cbiAgICAjYmxrc2l6ZTtcbiAgICBnZXQgYmxrc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jsa3NpemU7XG4gICAgfVxuICAgICNpbm87XG4gICAgZ2V0IGlubygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lubztcbiAgICB9XG4gICAgI3NpemU7XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzaXplO1xuICAgIH1cbiAgICAjYmxvY2tzO1xuICAgIGdldCBibG9ja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNibG9ja3M7XG4gICAgfVxuICAgICNhdGltZU1zO1xuICAgIGdldCBhdGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYXRpbWVNcztcbiAgICB9XG4gICAgI210aW1lTXM7XG4gICAgZ2V0IG10aW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtdGltZU1zO1xuICAgIH1cbiAgICAjY3RpbWVNcztcbiAgICBnZXQgY3RpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2N0aW1lTXM7XG4gICAgfVxuICAgICNiaXJ0aHRpbWVNcztcbiAgICBnZXQgYmlydGh0aW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNiaXJ0aHRpbWVNcztcbiAgICB9XG4gICAgI2F0aW1lO1xuICAgIGdldCBhdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2F0aW1lO1xuICAgIH1cbiAgICAjbXRpbWU7XG4gICAgZ2V0IG10aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbXRpbWU7XG4gICAgfVxuICAgICNjdGltZTtcbiAgICBnZXQgY3RpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjdGltZTtcbiAgICB9XG4gICAgI2JpcnRodGltZTtcbiAgICBnZXQgYmlydGh0aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmlydGh0aW1lO1xuICAgIH1cbiAgICAjbWF0Y2hOYW1lO1xuICAgICNkZXB0aDtcbiAgICAjZnVsbHBhdGg7XG4gICAgI2Z1bGxwYXRoUG9zaXg7XG4gICAgI3JlbGF0aXZlO1xuICAgICNyZWxhdGl2ZVBvc2l4O1xuICAgICN0eXBlO1xuICAgICNjaGlsZHJlbjtcbiAgICAjbGlua1RhcmdldDtcbiAgICAjcmVhbHBhdGg7XG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBEaXJlbnQgY2xhc3MgYXMgb2ZcbiAgICAgKiBOb2RlIHYyMCwgd2hlcmUgRGlyZW50WydwYXJlbnRQYXRoJ10gcmVmZXJzIHRvIHRoZSBwYXRoIG9mIHRoZVxuICAgICAqIGRpcmVjdG9yeSB0aGF0IHdhcyBwYXNzZWQgdG8gcmVhZGRpci4gRm9yIHJvb3QgZW50cmllcywgaXQncyB0aGUgcGF0aFxuICAgICAqIHRvIHRoZSBlbnRyeSBpdHNlbGYuXG4gICAgICovXG4gICAgZ2V0IHBhcmVudFBhdGgoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wYXJlbnQgfHwgdGhpcykuZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBhbGlhcyBmb3IgRGlyZW50WydwYXJlbnRQYXRoJ10gU29tZXdoYXQgY291bnRlcmludHVpdGl2ZWx5LFxuICAgICAqIHRoaXMgcHJvcGVydHkgcmVmZXJzIHRvIHRoZSAqcGFyZW50KiBwYXRoLCBub3QgdGhlIHBhdGggb2JqZWN0IGl0c2VsZi5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50UGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNyZWF0ZSBuZXcgUGF0aCBvYmplY3RzIGRpcmVjdGx5LiAgVGhleSBzaG91bGQgYWx3YXlzIGJlIGFjY2Vzc2VkXG4gICAgICogdmlhIHRoZSBQYXRoU2N1cnJ5IGNsYXNzIG9yIG90aGVyIG1ldGhvZHMgb24gdGhlIFBhdGggY2xhc3MuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gVU5LTk9XTiwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy4jbWF0Y2hOYW1lID0gbm9jYXNlID8gbm9ybWFsaXplTm9jYXNlKG5hbWUpIDogbm9ybWFsaXplKG5hbWUpO1xuICAgICAgICB0aGlzLiN0eXBlID0gdHlwZSAmIFRZUEVNQVNLO1xuICAgICAgICB0aGlzLm5vY2FzZSA9IG5vY2FzZTtcbiAgICAgICAgdGhpcy5yb290cyA9IHJvb3RzO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuI2NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuI2Z1bGxwYXRoID0gb3B0cy5mdWxscGF0aDtcbiAgICAgICAgdGhpcy4jcmVsYXRpdmUgPSBvcHRzLnJlbGF0aXZlO1xuICAgICAgICB0aGlzLiNyZWxhdGl2ZVBvc2l4ID0gb3B0cy5yZWxhdGl2ZVBvc2l4O1xuICAgICAgICB0aGlzLnBhcmVudCA9IG9wdHMucGFyZW50O1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZzID0gdGhpcy5wYXJlbnQuI2ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZnMgPSBmc0Zyb21PcHRpb24ob3B0cy5mcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVwdGggb2YgdGhlIFBhdGggb2JqZWN0IGZyb20gaXRzIHJvb3QuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgYSBwYXRoIGF0IGAvZm9vL2JhcmAgd291bGQgaGF2ZSBhIGRlcHRoIG9mIDIuXG4gICAgICovXG4gICAgZGVwdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLiNkZXB0aCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2RlcHRoO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNkZXB0aCA9IDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuI2RlcHRoID0gdGhpcy5wYXJlbnQuZGVwdGgoKSArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjaGlsZHJlbkNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hpbGRyZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgUGF0aCBvYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgc3RyaW5nIHBhdGgsIHJlc29sdmVkIGZyb20gdGhpcyBQYXRoXG4gICAgICovXG4gICAgcmVzb2x2ZShwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdFBhdGggPSB0aGlzLmdldFJvb3RTdHJpbmcocGF0aCk7XG4gICAgICAgIGNvbnN0IGRpciA9IHBhdGguc3Vic3RyaW5nKHJvb3RQYXRoLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRpclBhcnRzID0gZGlyLnNwbGl0KHRoaXMuc3BsaXRTZXApO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByb290UGF0aCA/XG4gICAgICAgICAgICB0aGlzLmdldFJvb3Qocm9vdFBhdGgpLiNyZXNvbHZlUGFydHMoZGlyUGFydHMpXG4gICAgICAgICAgICA6IHRoaXMuI3Jlc29sdmVQYXJ0cyhkaXJQYXJ0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgICNyZXNvbHZlUGFydHMoZGlyUGFydHMpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgZGlyUGFydHMpIHtcbiAgICAgICAgICAgIHAgPSBwLmNoaWxkKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWNoZWQgY2hpbGRyZW4gUGF0aCBvYmplY3RzLCBpZiBzdGlsbCBhdmFpbGFibGUuICBJZiB0aGV5XG4gICAgICogaGF2ZSBmYWxsZW4gb3V0IG9mIHRoZSBjYWNoZSwgdGhlbiByZXR1cm5zIGFuIGVtcHR5IGFycmF5LCBhbmQgcmVzZXRzIHRoZVxuICAgICAqIFJFQURESVJfQ0FMTEVEIGJpdCwgc28gdGhhdCBmdXR1cmUgY2FsbHMgdG8gcmVhZGRpcigpIHdpbGwgcmVxdWlyZSBhbiBmc1xuICAgICAqIGxvb2t1cC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNjaGlsZHJlbi5nZXQodGhpcyk7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBPYmplY3QuYXNzaWduKFtdLCB7IHByb3Zpc2lvbmFsOiAwIH0pO1xuICAgICAgICB0aGlzLiNjaGlsZHJlbi5zZXQodGhpcywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLiN0eXBlICY9IH5SRUFERElSX0NBTExFRDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHBhdGggcG9ydGlvbiBhbmQgcmV0dXJucyBvciBjcmVhdGVzIHRoZSBjaGlsZCBQYXRoLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdGhpc2AgaWYgcGF0aFBhcnQgaXMgYCcnYCBvciBgJy4nYCwgb3IgYHBhcmVudGAgaWYgcGF0aFBhcnQgaXNcbiAgICAgKiBgJy4uJ2AuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LiAgSWYgYHBhdGhQYXJ0YCBjb250YWlucyBhbnkgcGF0aFxuICAgICAqIHNlcGFyYXRvcnMsIGl0IHdpbGwgbGVhZCB0byB1bnNhZmUgdW5kZWZpbmVkIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogVXNlIGBQYXRoLnJlc29sdmUoKWAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaWxkKHBhdGhQYXJ0LCBvcHRzKSB7XG4gICAgICAgIGlmIChwYXRoUGFydCA9PT0gJycgfHwgcGF0aFBhcnQgPT09ICcuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhQYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHRoZSBjaGlsZFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubm9jYXNlID8gbm9ybWFsaXplTm9jYXNlKHBhdGhQYXJ0KSA6IG5vcm1hbGl6ZShwYXRoUGFydCk7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKHAuI21hdGNoTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBmaW5kIGl0LCBjcmVhdGUgcHJvdmlzaW9uYWwgY2hpbGQsIHNpbmNlIGl0IG1pZ2h0IG5vdFxuICAgICAgICAvLyBhY3R1YWxseSBleGlzdC4gIElmIHdlIGtub3cgdGhlIHBhcmVudCBpc24ndCBhIGRpciwgdGhlblxuICAgICAgICAvLyBpbiBmYWN0IGl0IENBTidUIGV4aXN0LlxuICAgICAgICBjb25zdCBzID0gdGhpcy5wYXJlbnQgPyB0aGlzLnNlcCA6ICcnO1xuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuI2Z1bGxwYXRoID8gdGhpcy4jZnVsbHBhdGggKyBzICsgcGF0aFBhcnQgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBjaGlsZCA9IHRoaXMubmV3Q2hpbGQocGF0aFBhcnQsIFVOS05PV04sIHtcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHBjaGlsZC4jdHlwZSB8PSBFTk9FTlQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byB1cGRhdGUgcHJvdmlzaW9uYWwsIGJlY2F1c2UgaWYgd2UgaGF2ZSByZWFsIGNoaWxkcmVuLFxuICAgICAgICAvLyB0aGVuIHByb3Zpc2lvbmFsIGlzIHNldCB0byBjaGlsZHJlbi5sZW5ndGgsIG90aGVyd2lzZSBhIGxvd2VyIG51bWJlclxuICAgICAgICBjaGlsZHJlbi5wdXNoKHBjaGlsZCk7XG4gICAgICAgIHJldHVybiBwY2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGN3ZC4gSWYgaXQgZG9lcyBub3Qgc2hhcmUgYW4gYW5jZXN0b3Igd2l0aFxuICAgICAqIHRoZSBjd2QsIHRoZW4gdGhpcyBlbmRzIHVwIGJlaW5nIGVxdWl2YWxlbnQgdG8gdGhlIGZ1bGxwYXRoKClcbiAgICAgKi9cbiAgICByZWxhdGl2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDV0QpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmICh0aGlzLiNyZWxhdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVsYXRpdmUgPSB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB2ID0gcC5yZWxhdGl2ZSgpO1xuICAgICAgICByZXR1cm4gcHYgKyAoIXB2IHx8ICFwLnBhcmVudCA/ICcnIDogdGhpcy5zZXApICsgbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgY3dkLCB1c2luZyAvIGFzIHRoZSBwYXRoIHNlcGFyYXRvci5cbiAgICAgKiBJZiBpdCBkb2VzIG5vdCBzaGFyZSBhbiBhbmNlc3RvciB3aXRoXG4gICAgICogdGhlIGN3ZCwgdGhlbiB0aGlzIGVuZHMgdXAgYmVpbmcgZXF1aXZhbGVudCB0byB0aGUgZnVsbHBhdGhQb3NpeCgpXG4gICAgICogT24gcG9zaXggc3lzdGVtcywgdGhpcyBpcyBpZGVudGljYWwgdG8gcmVsYXRpdmUoKS5cbiAgICAgKi9cbiAgICByZWxhdGl2ZVBvc2l4KCkge1xuICAgICAgICBpZiAodGhpcy5zZXAgPT09ICcvJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGF0aXZlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ1dEKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBpZiAodGhpcy4jcmVsYXRpdmVQb3NpeCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlbGF0aXZlUG9zaXg7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3JlbGF0aXZlUG9zaXggPSB0aGlzLmZ1bGxwYXRoUG9zaXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHYgPSBwLnJlbGF0aXZlUG9zaXgoKTtcbiAgICAgICAgcmV0dXJuIHB2ICsgKCFwdiB8fCAhcC5wYXJlbnQgPyAnJyA6ICcvJykgKyBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbHkgcmVzb2x2ZWQgcGF0aCBzdHJpbmcgZm9yIHRoaXMgUGF0aCBlbnRyeVxuICAgICAqL1xuICAgIGZ1bGxwYXRoKCkge1xuICAgICAgICBpZiAodGhpcy4jZnVsbHBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Z1bGxwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoID0gdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdiA9IHAuZnVsbHBhdGgoKTtcbiAgICAgICAgY29uc3QgZnAgPSBwdiArICghcC5wYXJlbnQgPyAnJyA6IHRoaXMuc2VwKSArIG5hbWU7XG4gICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGggPSBmcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIHBsYXRmb3JtcyBvdGhlciB0aGFuIHdpbmRvd3MsIHRoaXMgaXMgaWRlbnRpY2FsIHRvIGZ1bGxwYXRoLlxuICAgICAqXG4gICAgICogT24gd2luZG93cywgdGhpcyBpcyBvdmVycmlkZGVuIHRvIHJldHVybiB0aGUgZm9yd2FyZC1zbGFzaCBmb3JtIG9mIHRoZVxuICAgICAqIGZ1bGwgVU5DIHBhdGguXG4gICAgICovXG4gICAgZnVsbHBhdGhQb3NpeCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Z1bGxwYXRoUG9zaXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNmdWxscGF0aFBvc2l4O1xuICAgICAgICBpZiAodGhpcy5zZXAgPT09ICcvJylcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGhQb3NpeCA9IHRoaXMuZnVsbHBhdGgoKSk7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLmZ1bGxwYXRoKCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgICAgICAgaWYgKC9eW2Etel06XFwvL2kudGVzdChwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGhQb3NpeCA9IGAvLz8vJHtwfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNmdWxscGF0aFBvc2l4ID0gcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICBjb25zdCBwZnBwID0gcC5mdWxscGF0aFBvc2l4KCk7XG4gICAgICAgIGNvbnN0IGZwcCA9IHBmcHAgKyAoIXBmcHAgfHwgIXAucGFyZW50ID8gJycgOiAnLycpICsgdGhpcy5uYW1lO1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoUG9zaXggPSBmcHApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgUGF0aCBvZiBhbiB1bmtub3duIHR5cGU/XG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2UgbWlnaHQga25vdyAqc29tZXRoaW5nKiBhYm91dCBpdCBpZiB0aGVyZSBoYXMgYmVlbiBhIHByZXZpb3VzXG4gICAgICogZmlsZXN5c3RlbSBvcGVyYXRpb24sIGZvciBleGFtcGxlIHRoYXQgaXQgZG9lcyBub3QgZXhpc3QsIG9yIGlzIG5vdCBhXG4gICAgICogbGluaywgb3Igd2hldGhlciBpdCBoYXMgY2hpbGQgZW50cmllcy5cbiAgICAgKi9cbiAgICBpc1Vua25vd24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBVTktOT1dOO1xuICAgIH1cbiAgICBpc1R5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tgaXMke3R5cGV9YF0oKTtcbiAgICB9XG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzVW5rbm93bigpID8gJ1Vua25vd24nXG4gICAgICAgICAgICA6IHRoaXMuaXNEaXJlY3RvcnkoKSA/ICdEaXJlY3RvcnknXG4gICAgICAgICAgICAgICAgOiB0aGlzLmlzRmlsZSgpID8gJ0ZpbGUnXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc1N5bWJvbGljTGluaygpID8gJ1N5bWJvbGljTGluaydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc0ZJRk8oKSA/ICdGSUZPJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc0NoYXJhY3RlckRldmljZSgpID8gJ0NoYXJhY3RlckRldmljZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmlzQmxvY2tEZXZpY2UoKSA/ICdCbG9ja0RldmljZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLyogYzggaWdub3JlIHN0YXJ0ICovIHRoaXMuaXNTb2NrZXQoKSA/ICdTb2NrZXQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnVW5rbm93bicpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgUGF0aCBhIHJlZ3VsYXIgZmlsZT9cbiAgICAgKi9cbiAgICBpc0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRlJFRztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIFBhdGggYSBkaXJlY3Rvcnk/XG4gICAgICovXG4gICAgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRkRJUjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggYSBjaGFyYWN0ZXIgZGV2aWNlP1xuICAgICAqL1xuICAgIGlzQ2hhcmFjdGVyRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZDSFI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgYmxvY2sgZGV2aWNlP1xuICAgICAqL1xuICAgIGlzQmxvY2tEZXZpY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRkJMSztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggYSBGSUZPIHBpcGU/XG4gICAgICovXG4gICAgaXNGSUZPKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZJRk87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgc29ja2V0P1xuICAgICAqL1xuICAgIGlzU29ja2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZTT0NLO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcGF0aCBhIHN5bWJvbGljIGxpbms/XG4gICAgICovXG4gICAgaXNTeW1ib2xpY0xpbmsoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTE5LKSA9PT0gSUZMTks7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZW50cnkgaWYgaXQgaGFzIGJlZW4gc3ViamVjdCBvZiBhIHN1Y2Nlc3NmdWwgbHN0YXQsIG9yXG4gICAgICogdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHJlYWQgdGhlIGZpbGVzeXN0ZW0sIHNvIGFuIHVuZGVmaW5lZCByZXN1bHQgKmNvdWxkKiBzaW1wbHlcbiAgICAgKiBtZWFuIHRoYXQgd2UgaGF2ZW4ndCBjYWxsZWQgbHN0YXQgb24gaXQuXG4gICAgICovXG4gICAgbHN0YXRDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN0eXBlICYgTFNUQVRfQ0FMTEVEID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjYWNoZWQgbGluayB0YXJnZXQgaWYgdGhlIGVudHJ5IGhhcyBiZWVuIHRoZSBzdWJqZWN0IG9mIGFcbiAgICAgKiBzdWNjZXNzZnVsIHJlYWRsaW5rLCBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgcmVhZCB0aGUgZmlsZXN5c3RlbSwgc28gYW4gdW5kZWZpbmVkIHJlc3VsdCAqY291bGQqIGp1c3QgbWVhbiB3ZVxuICAgICAqIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhLiBPbmx5IHVzZSBpdCBpZiB5b3UgYXJlIHZlcnkgc3VyZSB0aGF0IGFcbiAgICAgKiByZWFkbGluaygpIGhhcyBiZWVuIGNhbGxlZCBhdCBzb21lIHBvaW50LlxuICAgICAqL1xuICAgIHJlYWRsaW5rQ2FjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbGlua1RhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIHJlYWxwYXRoIHRhcmdldCBpZiB0aGUgZW50cnkgaGFzIGJlZW4gdGhlIHN1YmplY3RcbiAgICAgKiBvZiBhIHN1Y2Nlc3NmdWwgcmVhbHBhdGgsIG9yIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWFkIHRoZSBmaWxlc3lzdGVtLCBzbyBhbiB1bmRlZmluZWQgcmVzdWx0ICpjb3VsZCoganVzdCBtZWFuIHdlXG4gICAgICogZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkIGRhdGEuIE9ubHkgdXNlIGl0IGlmIHlvdSBhcmUgdmVyeSBzdXJlIHRoYXQgYVxuICAgICAqIHJlYWxwYXRoKCkgaGFzIGJlZW4gY2FsbGVkIGF0IHNvbWUgcG9pbnQuXG4gICAgICovXG4gICAgcmVhbHBhdGhDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZWFscGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIGNoaWxkIFBhdGggZW50cmllcyBhcnJheSBpZiB0aGUgZW50cnkgaGFzIGJlZW4gdGhlXG4gICAgICogc3ViamVjdCBvZiBhIHN1Y2Nlc3NmdWwgcmVhZGRpcigpLCBvciBbXSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWFkIHRoZSBmaWxlc3lzdGVtLCBzbyBhbiBlbXB0eSBhcnJheSAqY291bGQqIGp1c3QgbWVhbiB3ZVxuICAgICAqIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhLiBPbmx5IHVzZSBpdCBpZiB5b3UgYXJlIHZlcnkgc3VyZSB0aGF0IGFcbiAgICAgKiByZWFkZGlyKCkgaGFzIGJlZW4gY2FsbGVkIHJlY2VudGx5IGVub3VnaCB0byBzdGlsbCBiZSB2YWxpZC5cbiAgICAgKi9cbiAgICByZWFkZGlyQ2FjaGVkKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgaXQncyB3b3J0aCB0cnlpbmcgdG8gcmVhZGxpbmsuICBJZSwgd2UgZG9uJ3QgKHlldCkgaGF2ZVxuICAgICAqIGFueSBpbmRpY2F0aW9uIHRoYXQgcmVhZGxpbmsgd2lsbCBkZWZpbml0ZWx5IGZhaWwuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBwYXRoIGlzIGtub3duIHRvIG5vdCBiZSBhIHN5bWxpbmssIGlmIGEgcHJldmlvdXNcbiAgICAgKiByZWFkbGluayBmYWlsZWQsIG9yIGlmIHRoZSBlbnRyeSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBjYW5SZWFkbGluaygpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpbmtUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gY2FzZXMgd2hlcmUgaXQgY2Fubm90IHBvc3NpYmx5IHN1Y2NlZWRcbiAgICAgICAgY29uc3QgaWZtdCA9IHRoaXMuI3R5cGUgJiBJRk1UO1xuICAgICAgICByZXR1cm4gISgoaWZtdCAhPT0gVU5LTk9XTiAmJiBpZm10ICE9PSBJRkxOSykgfHxcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgJiBFTk9SRUFETElOSyB8fFxuICAgICAgICAgICAgdGhpcy4jdHlwZSAmIEVOT0VOVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHJlYWRkaXIgaGFzIHByZXZpb3VzbHkgYmVlbiBzdWNjZXNzZnVsbHkgY2FsbGVkIG9uIHRoaXNcbiAgICAgKiBwYXRoLCBpbmRpY2F0aW5nIHRoYXQgY2FjaGVkUmVhZGRpcigpIGlzIGxpa2VseSB2YWxpZC5cbiAgICAgKi9cbiAgICBjYWxsZWRSZWFkZGlyKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy4jdHlwZSAmIFJFQURESVJfQ0FMTEVEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIGlzIGtub3duIHRvIG5vdCBleGlzdC4gVGhhdCBpcywgYSBwcmV2aW91cyBsc3RhdFxuICAgICAqIG9yIHJlYWRkaXIgZmFpbGVkIHRvIHZlcmlmeSBpdHMgZXhpc3RlbmNlIHdoZW4gdGhhdCB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBleHBlY3RlZCwgb3IgYSBwYXJlbnQgZW50cnkgd2FzIG1hcmtlZCBlaXRoZXIgZW5vZW50IG9yIGVub3RkaXIuXG4gICAgICovXG4gICAgaXNFTk9FTlQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLiN0eXBlICYgRU5PRU5UKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHBhdGggaXMgYSBtYXRjaCBmb3IgdGhlIGdpdmVuIHBhdGggbmFtZS4gIFRoaXMgaGFuZGxlc1xuICAgICAqIGNhc2Ugc2Vuc2l0aXZpdHkgYW5kIHVuaWNvZGUgbm9ybWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IGV2ZW4gb24gY2FzZS1zZW5zaXRpdmUgc3lzdGVtcywgaXQgaXMgKipub3QqKiBzYWZlIHRvIHRlc3QgdGhlXG4gICAgICogZXF1YWxpdHkgb2YgdGhlIGAubmFtZWAgcHJvcGVydHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBwYXRobmFtZVxuICAgICAqIG1hdGNoZXMsIGR1ZSB0byB1bmljb2RlIG5vcm1hbGl6YXRpb24gbWlzbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiB0ZXN0aW5nIHRoZSBgcGF0aC5uYW1lYCBwcm9wZXJ0eVxuICAgICAqIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGlzTmFtZWQobikge1xuICAgICAgICByZXR1cm4gIXRoaXMubm9jYXNlID9cbiAgICAgICAgICAgIHRoaXMuI21hdGNoTmFtZSA9PT0gbm9ybWFsaXplKG4pXG4gICAgICAgICAgICA6IHRoaXMuI21hdGNoTmFtZSA9PT0gbm9ybWFsaXplTm9jYXNlKG4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIFBhdGggb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRhcmdldCBvZiBhIHN5bWJvbGljIGxpbmsuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCBpcyBub3QgYSBzeW1ib2xpYyBsaW5rLCBvciBpZiB0aGUgcmVhZGxpbmsgY2FsbCBmYWlscyBmb3IgYW55XG4gICAgICogcmVhc29uLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdCBpcyBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXRkYXRlZCBpZiB0aGUgZmlsZXN5c3RlbSBpcyBtdXRhdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRsaW5rKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLiNsaW5rVGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkbGluaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAvLyBhbHJlYWR5IGNvdmVyZWQgYnkgdGhlIGNhblJlYWRsaW5rIHRlc3QsIGhlcmUgZm9yIHRzIGdydW1wbGVzXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWQgPSBhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5yZWFkbGluayh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgY29uc3QgbGlua1RhcmdldCA9IChhd2FpdCB0aGlzLnBhcmVudC5yZWFscGF0aCgpKT8ucmVzb2x2ZShyZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5rVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNsaW5rVGFyZ2V0ID0gbGlua1RhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFkbGlua0ZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzIHtAbGluayBQYXRoQmFzZS5yZWFkbGlua31cbiAgICAgKi9cbiAgICByZWFkbGlua1N5bmMoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuI2xpbmtUYXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNhblJlYWRsaW5rKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIC8vIGFscmVhZHkgY292ZXJlZCBieSB0aGUgY2FuUmVhZGxpbmsgdGVzdCwgaGVyZSBmb3IgdHMgZ3J1bXBsZXNcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVhZCA9IHRoaXMuI2ZzLnJlYWRsaW5rU3luYyh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgY29uc3QgbGlua1RhcmdldCA9IHRoaXMucGFyZW50LnJlYWxwYXRoU3luYygpPy5yZXNvbHZlKHJlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmtUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuI2xpbmtUYXJnZXQgPSBsaW5rVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYWRsaW5rRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3JlYWRkaXJTdWNjZXNzKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIHN1Y2NlZWRlZCwgbWFyayByZWFkZGlyIGNhbGxlZCBiaXRcbiAgICAgICAgdGhpcy4jdHlwZSB8PSBSRUFERElSX0NBTExFRDtcbiAgICAgICAgLy8gbWFyayBhbGwgcmVtYWluaW5nIHByb3Zpc2lvbmFsIGNoaWxkcmVuIGFzIEVOT0VOVFxuICAgICAgICBmb3IgKGxldCBwID0gY2hpbGRyZW4ucHJvdmlzaW9uYWw7IHAgPCBjaGlsZHJlbi5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGNoaWxkcmVuW3BdO1xuICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgYy4jbWFya0VOT0VOVCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNtYXJrRU5PRU5UKCkge1xuICAgICAgICAvLyBtYXJrIGFzIFVOS05PV04gYW5kIEVOT0VOVFxuICAgICAgICBpZiAodGhpcy4jdHlwZSAmIEVOT0VOVClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4jdHlwZSA9ICh0aGlzLiN0eXBlIHwgRU5PRU5UKSAmIElGTVRfVU5LTk9XTjtcbiAgICAgICAgdGhpcy4jbWFya0NoaWxkcmVuRU5PRU5UKCk7XG4gICAgfVxuICAgICNtYXJrQ2hpbGRyZW5FTk9FTlQoKSB7XG4gICAgICAgIC8vIGFsbCBjaGlsZHJlbiBhcmUgcHJvdmlzaW9uYWwgYW5kIGRvIG5vdCBleGlzdFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgY2hpbGRyZW4ucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHAuI21hcmtFTk9FTlQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjbWFya0VOT1JFQUxQQVRIKCkge1xuICAgICAgICB0aGlzLiN0eXBlIHw9IEVOT1JFQUxQQVRIO1xuICAgICAgICB0aGlzLiNtYXJrRU5PVERJUigpO1xuICAgIH1cbiAgICAvLyBzYXZlIHRoZSBpbmZvcm1hdGlvbiB3aGVuIHdlIGtub3cgdGhlIGVudHJ5IGlzIG5vdCBhIGRpclxuICAgICNtYXJrRU5PVERJUigpIHtcbiAgICAgICAgLy8gZW50cnkgaXMgbm90IGEgZGlyZWN0b3J5LCBzbyBhbnkgY2hpbGRyZW4gY2FuJ3QgZXhpc3QuXG4gICAgICAgIC8vIHRoaXMgKnNob3VsZCogYmUgaW1wb3NzaWJsZSwgc2luY2UgYW55IGNoaWxkcmVuIGNyZWF0ZWRcbiAgICAgICAgLy8gYWZ0ZXIgaXQncyBiZWVuIG1hcmtlZCBFTk9URElSIHNob3VsZCBiZSBtYXJrZWQgRU5PRU5ULFxuICAgICAgICAvLyBzbyBpdCB3b24ndCBldmVuIGdldCB0byB0aGlzIHBvaW50LlxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuI3R5cGUgJiBFTk9URElSKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBsZXQgdCA9IHRoaXMuI3R5cGU7XG4gICAgICAgIC8vIHRoaXMgY291bGQgaGFwcGVuIGlmIHdlIHN0YXQgYSBkaXIsIHRoZW4gZGVsZXRlIGl0LFxuICAgICAgICAvLyB0aGVuIHRyeSB0byByZWFkIGl0IG9yIG9uZSBvZiBpdHMgY2hpbGRyZW4uXG4gICAgICAgIGlmICgodCAmIElGTVQpID09PSBJRkRJUilcbiAgICAgICAgICAgIHQgJj0gSUZNVF9VTktOT1dOO1xuICAgICAgICB0aGlzLiN0eXBlID0gdCB8IEVOT1RESVI7XG4gICAgICAgIHRoaXMuI21hcmtDaGlsZHJlbkVOT0VOVCgpO1xuICAgIH1cbiAgICAjcmVhZGRpckZhaWwoY29kZSA9ICcnKSB7XG4gICAgICAgIC8vIG1hcmtFTk9URElSIGFuZCBtYXJrRU5PRU5UIGFsc28gc2V0IHByb3Zpc2lvbmFsPTBcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9URElSJyB8fCBjb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PVERJUigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PRU5UKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuKCkucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgICNsc3RhdEZhaWwoY29kZSA9ICcnKSB7XG4gICAgICAgIC8vIFdpbmRvd3MganVzdCByYWlzZXMgRU5PRU5UIGluIHRoaXMgY2FzZSwgZGlzYWJsZSBmb3Igd2luIENJXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGtub3cgaXQgaGFzIGEgcGFyZW50IGJ5IHRoaXMgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHAuI21hcmtFTk9URElSKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PRU5UKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3JlYWRsaW5rRmFpbChjb2RlID0gJycpIHtcbiAgICAgICAgbGV0IHRlciA9IHRoaXMuI3R5cGU7XG4gICAgICAgIHRlciB8PSBFTk9SRUFETElOSztcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgICAgICAgdGVyIHw9IEVOT0VOVDtcbiAgICAgICAgLy8gd2luZG93cyBnZXRzIGEgd2VpcmQgZXJyb3Igd2hlbiB5b3UgdHJ5IHRvIHJlYWRsaW5rIGEgZmlsZVxuICAgICAgICBpZiAoY29kZSA9PT0gJ0VJTlZBTCcgfHwgY29kZSA9PT0gJ1VOS05PV04nKSB7XG4gICAgICAgICAgICAvLyBleGlzdHMsIGJ1dCBub3QgYSBzeW1saW5rLCB3ZSBkb24ndCBrbm93IFdIQVQgaXQgaXMsIHNvIHJlbW92ZVxuICAgICAgICAgICAgLy8gYWxsIElGTVQgYml0cy5cbiAgICAgICAgICAgIHRlciAmPSBJRk1UX1VOS05PV047XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jdHlwZSA9IHRlcjtcbiAgICAgICAgLy8gd2luZG93cyBqdXN0IGdldHMgRU5PRU5UIGluIHRoaXMgY2FzZS4gIFdlIGRvIGNvdmVyIHRoZSBjYXNlLFxuICAgICAgICAvLyBqdXN0IGRpc2FibGVkIGJlY2F1c2UgaXQncyBpbXBvc3NpYmxlIG9uIFdpbmRvd3MgQ0lcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PVERJUicgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LiNtYXJrRU5PVERJUigpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgfVxuICAgICNyZWFkZGlyQWRkQ2hpbGQoZSwgYykge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3JlYWRkaXJNYXliZVByb21vdGVDaGlsZChlLCBjKSB8fFxuICAgICAgICAgICAgdGhpcy4jcmVhZGRpckFkZE5ld0NoaWxkKGUsIGMpKTtcbiAgICB9XG4gICAgI3JlYWRkaXJBZGROZXdDaGlsZChlLCBjKSB7XG4gICAgICAgIC8vIGFsbG9jIG5ldyBlbnRyeSBhdCBoZWFkLCBzbyBpdCdzIG5ldmVyIHByb3Zpc2lvbmFsXG4gICAgICAgIGNvbnN0IHR5cGUgPSBlbnRUb1R5cGUoZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5uZXdDaGlsZChlLm5hbWUsIHR5cGUsIHsgcGFyZW50OiB0aGlzIH0pO1xuICAgICAgICBjb25zdCBpZm10ID0gY2hpbGQuI3R5cGUgJiBJRk1UO1xuICAgICAgICBpZiAoaWZtdCAhPT0gSUZESVIgJiYgaWZtdCAhPT0gSUZMTksgJiYgaWZtdCAhPT0gVU5LTk9XTikge1xuICAgICAgICAgICAgY2hpbGQuI3R5cGUgfD0gRU5PVERJUjtcbiAgICAgICAgfVxuICAgICAgICBjLnVuc2hpZnQoY2hpbGQpO1xuICAgICAgICBjLnByb3Zpc2lvbmFsKys7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgI3JlYWRkaXJNYXliZVByb21vdGVDaGlsZChlLCBjKSB7XG4gICAgICAgIGZvciAobGV0IHAgPSBjLnByb3Zpc2lvbmFsOyBwIDwgYy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgY29uc3QgcGNoaWxkID0gY1twXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5vY2FzZSA/IG5vcm1hbGl6ZU5vY2FzZShlLm5hbWUpIDogbm9ybWFsaXplKGUubmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gcGNoaWxkLiNtYXRjaE5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFkZGlyUHJvbW90ZUNoaWxkKGUsIHBjaGlsZCwgcCwgYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3JlYWRkaXJQcm9tb3RlQ2hpbGQoZSwgcCwgaW5kZXgsIGMpIHtcbiAgICAgICAgY29uc3QgdiA9IHAubmFtZTtcbiAgICAgICAgLy8gcmV0YWluIGFueSBvdGhlciBmbGFncywgYnV0IHNldCBpZm10IGZyb20gZGlyZW50XG4gICAgICAgIHAuI3R5cGUgPSAocC4jdHlwZSAmIElGTVRfVU5LTk9XTikgfCBlbnRUb1R5cGUoZSk7XG4gICAgICAgIC8vIGNhc2Ugc2Vuc2l0aXZpdHkgZml4aW5nIHdoZW4gd2UgbGVhcm4gdGhlIHRydWUgbmFtZS5cbiAgICAgICAgaWYgKHYgIT09IGUubmFtZSlcbiAgICAgICAgICAgIHAubmFtZSA9IGUubmFtZTtcbiAgICAgICAgLy8ganVzdCBhZHZhbmNlIHByb3Zpc2lvbmFsIGluZGV4IChwb3RlbnRpYWxseSBvZmYgdGhlIGxpc3QpLFxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgaGF2ZSB0byBzcGxpY2UvcG9wIGl0IG91dCBhbmQgcmUtaW5zZXJ0IGF0IGhlYWRcbiAgICAgICAgaWYgKGluZGV4ICE9PSBjLnByb3Zpc2lvbmFsKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICBjLnBvcCgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGMudW5zaGlmdChwKTtcbiAgICAgICAgfVxuICAgICAgICBjLnByb3Zpc2lvbmFsKys7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGxzdGF0KCkgb24gdGhpcyBQYXRoLCBhbmQgdXBkYXRlIGFsbCBrbm93biBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZVxuICAgICAqIGRldGVybWluZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdW5saWtlIGBmcy5sc3RhdCgpYCwgdGhlIHJldHVybmVkIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gc29tZVxuICAgICAqIGluZm9ybWF0aW9uLCBzdWNoIGFzIGBtb2RlYCwgYGRldmAsIGBubGlua2AsIGFuZCBgaW5vYC4gIElmIHRoYXRcbiAgICAgKiBpbmZvcm1hdGlvbiBpcyByZXF1aXJlZCwgeW91IHdpbGwgbmVlZCB0byBjYWxsIGBmcy5sc3RhdGAgeW91cnNlbGYuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCByZWZlcnMgdG8gYSBub25leGlzdGVudCBmaWxlLCBvciBpZiB0aGUgbHN0YXQgY2FsbCBmYWlscyBmb3JcbiAgICAgKiBhbnkgcmVhc29uLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC4gIE90aGVyd2lzZSB0aGUgdXBkYXRlZCBQYXRoIG9iamVjdCBpc1xuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogUmVzdWx0cyBhcmUgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0IG9mIGRhdGUgaWYgdGhlIGZpbGVzeXN0ZW0gaXNcbiAgICAgKiBtdXRhdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxzdGF0KCkge1xuICAgICAgICBpZiAoKHRoaXMuI3R5cGUgJiBFTk9FTlQpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2FwcGx5U3RhdChhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5sc3RhdCh0aGlzLmZ1bGxwYXRoKCkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xzdGF0RmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBzeW5jaHJvbm91cyB7QGxpbmsgUGF0aEJhc2UubHN0YXR9XG4gICAgICovXG4gICAgbHN0YXRTeW5jKCkge1xuICAgICAgICBpZiAoKHRoaXMuI3R5cGUgJiBFTk9FTlQpID09PSAwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2FwcGx5U3RhdCh0aGlzLiNmcy5sc3RhdFN5bmModGhpcy5mdWxscGF0aCgpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsc3RhdEZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2FwcGx5U3RhdChzdCkge1xuICAgICAgICBjb25zdCB7IGF0aW1lLCBhdGltZU1zLCBiaXJ0aHRpbWUsIGJpcnRodGltZU1zLCBibGtzaXplLCBibG9ja3MsIGN0aW1lLCBjdGltZU1zLCBkZXYsIGdpZCwgaW5vLCBtb2RlLCBtdGltZSwgbXRpbWVNcywgbmxpbmssIHJkZXYsIHNpemUsIHVpZCwgfSA9IHN0O1xuICAgICAgICB0aGlzLiNhdGltZSA9IGF0aW1lO1xuICAgICAgICB0aGlzLiNhdGltZU1zID0gYXRpbWVNcztcbiAgICAgICAgdGhpcy4jYmlydGh0aW1lID0gYmlydGh0aW1lO1xuICAgICAgICB0aGlzLiNiaXJ0aHRpbWVNcyA9IGJpcnRodGltZU1zO1xuICAgICAgICB0aGlzLiNibGtzaXplID0gYmxrc2l6ZTtcbiAgICAgICAgdGhpcy4jYmxvY2tzID0gYmxvY2tzO1xuICAgICAgICB0aGlzLiNjdGltZSA9IGN0aW1lO1xuICAgICAgICB0aGlzLiNjdGltZU1zID0gY3RpbWVNcztcbiAgICAgICAgdGhpcy4jZGV2ID0gZGV2O1xuICAgICAgICB0aGlzLiNnaWQgPSBnaWQ7XG4gICAgICAgIHRoaXMuI2lubyA9IGlubztcbiAgICAgICAgdGhpcy4jbW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuI210aW1lID0gbXRpbWU7XG4gICAgICAgIHRoaXMuI210aW1lTXMgPSBtdGltZU1zO1xuICAgICAgICB0aGlzLiNubGluayA9IG5saW5rO1xuICAgICAgICB0aGlzLiNyZGV2ID0gcmRldjtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMuI3VpZCA9IHVpZDtcbiAgICAgICAgY29uc3QgaWZtdCA9IGVudFRvVHlwZShzdCk7XG4gICAgICAgIC8vIHJldGFpbiBhbnkgb3RoZXIgZmxhZ3MsIGJ1dCBzZXQgdGhlIGlmbXRcbiAgICAgICAgdGhpcy4jdHlwZSA9ICh0aGlzLiN0eXBlICYgSUZNVF9VTktOT1dOKSB8IGlmbXQgfCBMU1RBVF9DQUxMRUQ7XG4gICAgICAgIGlmIChpZm10ICE9PSBVTktOT1dOICYmIGlmbXQgIT09IElGRElSICYmIGlmbXQgIT09IElGTE5LKSB7XG4gICAgICAgICAgICB0aGlzLiN0eXBlIHw9IEVOT1RESVI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI29uUmVhZGRpckNCID0gW107XG4gICAgI3JlYWRkaXJDQkluRmxpZ2h0ID0gZmFsc2U7XG4gICAgI2NhbGxPblJlYWRkaXJDQihjaGlsZHJlbikge1xuICAgICAgICB0aGlzLiNyZWFkZGlyQ0JJbkZsaWdodCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYnMgPSB0aGlzLiNvblJlYWRkaXJDQi5zbGljZSgpO1xuICAgICAgICB0aGlzLiNvblJlYWRkaXJDQi5sZW5ndGggPSAwO1xuICAgICAgICBjYnMuZm9yRWFjaChjYiA9PiBjYihudWxsLCBjaGlsZHJlbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBub2RlLXN0eWxlIGNhbGxiYWNrIGludGVyZmFjZSB0byBnZXQgbGlzdCBvZiBkaXJlY3RvcnkgZW50cmllcy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBQYXRoIGNhbm5vdCBvciBkb2VzIG5vdCBjb250YWluIGFueSBjaGlsZHJlbiwgdGhlbiBhbiBlbXB0eSBhcnJheVxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogUmVzdWx0cyBhcmUgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0IG9mIGRhdGUgaWYgdGhlIGZpbGVzeXN0ZW0gaXNcbiAgICAgKiBtdXRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayBjYWxsZWQgd2l0aCAoZXIsIGVudHJpZXMpLiAgTm90ZSB0aGF0IHRoZSBgZXJgXG4gICAgICogcGFyYW0gaXMgc29tZXdoYXQgZXh0cmFuZW91cywgYXMgYWxsIHJlYWRkaXIoKSBlcnJvcnMgYXJlIGhhbmRsZWQgYW5kXG4gICAgICogc2ltcGx5IHJlc3VsdCBpbiBhbiBlbXB0eSBzZXQgb2YgZW50cmllcyBiZWluZyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gYWxsb3daYWxnbyBCb29sZWFuIGluZGljYXRpbmcgdGhhdCBpbW1lZGlhdGVseSBrbm93biByZXN1bHRzIHNob3VsZFxuICAgICAqICpub3QqIGJlIGRlZmVycmVkIHdpdGggYHF1ZXVlTWljcm90YXNrYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC4gUmVsZWFzZVxuICAgICAqIHphbGdvIGF0IHlvdXIgcGVyaWwsIHRoZSBkYXJrIHBvbnkgbG9yZCBpcyBkZXZpb3VzIGFuZCB1bmZvcmdpdmluZy5cbiAgICAgKi9cbiAgICByZWFkZGlyQ0IoY2IsIGFsbG93WmFsZ28gPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3daYWxnbylcbiAgICAgICAgICAgICAgICBjYihudWxsLCBbXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2IobnVsbCwgW10pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGVkUmVhZGRpcigpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgICAgICAgICAgaWYgKGFsbG93WmFsZ28pXG4gICAgICAgICAgICAgICAgY2IobnVsbCwgYyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2IobnVsbCwgYykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgemFsZ28gYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy4jb25SZWFkZGlyQ0IucHVzaChjYik7XG4gICAgICAgIGlmICh0aGlzLiNyZWFkZGlyQ0JJbkZsaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3JlYWRkaXJDQkluRmxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgLy8gZWxzZSByZWFkIHRoZSBkaXJlY3RvcnksIGZpbGwgdXAgY2hpbGRyZW5cbiAgICAgICAgLy8gZGUtcHJvdmlzaW9uYWxpemUgYW55IHByb3Zpc2lvbmFsIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuZnVsbHBhdGgoKTtcbiAgICAgICAgdGhpcy4jZnMucmVhZGRpcihmdWxscGF0aCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0sIChlciwgZW50cmllcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpckZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhbiBlcnJvciwgd2UgYWx3YXlzIGdldCBlbnRyaWVzLlxuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJBZGRDaGlsZChlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJTdWNjZXNzKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbGxPblJlYWRkaXJDQihjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgI2FzeW5jUmVhZGRpckluRmxpZ2h0O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBrbm93biBjaGlsZCBlbnRyaWVzLlxuICAgICAqXG4gICAgICogSWYgdGhlIFBhdGggY2Fubm90IG9yIGRvZXMgbm90IGNvbnRhaW4gYW55IGNoaWxkcmVuLCB0aGVuIGFuIGVtcHR5IGFycmF5XG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHRzIGFyZSBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXQgb2YgZGF0ZSBpZiB0aGUgZmlsZXN5c3RlbSBpc1xuICAgICAqIG11dGF0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZGRpcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuICAgICAgICBpZiAodGhpcy5jYWxsZWRSZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSByZWFkIHRoZSBkaXJlY3RvcnksIGZpbGwgdXAgY2hpbGRyZW5cbiAgICAgICAgLy8gZGUtcHJvdmlzaW9uYWxpemUgYW55IHByb3Zpc2lvbmFsIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuZnVsbHBhdGgoKTtcbiAgICAgICAgaWYgKHRoaXMuI2FzeW5jUmVhZGRpckluRmxpZ2h0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNhc3luY1JlYWRkaXJJbkZsaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgbGV0IHJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jYXN5bmNSZWFkZGlySW5GbGlnaHQgPSBuZXcgUHJvbWlzZShyZXMgPT4gKHJlc29sdmUgPSByZXMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGF3YWl0IHRoaXMuI2ZzLnByb21pc2VzLnJlYWRkaXIoZnVsbHBhdGgsIHtcbiAgICAgICAgICAgICAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyQWRkQ2hpbGQoZSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyU3VjY2VzcyhjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wcm92aXNpb25hbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNhc3luY1JlYWRkaXJJbkZsaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzeW5jaHJvbm91cyB7QGxpbmsgUGF0aEJhc2UucmVhZGRpcn1cbiAgICAgKi9cbiAgICByZWFkZGlyU3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuICAgICAgICBpZiAodGhpcy5jYWxsZWRSZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSByZWFkIHRoZSBkaXJlY3RvcnksIGZpbGwgdXAgY2hpbGRyZW5cbiAgICAgICAgLy8gZGUtcHJvdmlzaW9uYWxpemUgYW55IHByb3Zpc2lvbmFsIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBmdWxscGF0aCA9IHRoaXMuZnVsbHBhdGgoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLiNmcy5yZWFkZGlyU3luYyhmdWxscGF0aCwge1xuICAgICAgICAgICAgICAgIHdpdGhGaWxlVHlwZXM6IHRydWUsXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJBZGRDaGlsZChlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNyZWFkZGlyU3VjY2VzcyhjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFkZGlyRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgIH1cbiAgICBjYW5SZWFkZGlyKCkge1xuICAgICAgICBpZiAodGhpcy4jdHlwZSAmIEVOT0NISUxEKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBpZm10ID0gSUZNVCAmIHRoaXMuI3R5cGU7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBzZXQgRU5PVERJUiB3aGVuIHNldHRpbmcgSUZNVCwgc28gc2hvdWxkIGJlIGltcG9zc2libGVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghKGlmbXQgPT09IFVOS05PV04gfHwgaWZtdCA9PT0gSUZESVIgfHwgaWZtdCA9PT0gSUZMTkspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikge1xuICAgICAgICByZXR1cm4gKCh0aGlzLiN0eXBlICYgSUZESVIpID09PSBJRkRJUiAmJlxuICAgICAgICAgICAgISh0aGlzLiN0eXBlICYgRU5PQ0hJTEQpICYmXG4gICAgICAgICAgICAhZGlycy5oYXModGhpcykgJiZcbiAgICAgICAgICAgICghd2Fsa0ZpbHRlciB8fCB3YWxrRmlsdGVyKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgUGF0aCBvYmplY3QgY29ycmVzcG9uZGluZyB0byBwYXRoIGFzIHJlc29sdmVkXG4gICAgICogYnkgcmVhbHBhdGgoMykuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcmVhbHBhdGggY2FsbCBmYWlscyBmb3IgYW55IHJlYXNvbiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHQgaXMgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0ZGF0ZWQgaWYgdGhlIGZpbGVzeXN0ZW0gaXMgbXV0YXRlZC5cbiAgICAgKiBPbiBzdWNjZXNzLCByZXR1cm5zIGEgUGF0aCBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgcmVhbHBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyZWFscGF0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFscGF0aDtcbiAgICAgICAgaWYgKChFTk9SRUFMUEFUSCB8IEVOT1JFQURMSU5LIHwgRU5PRU5UKSAmIHRoaXMuI3R5cGUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnAgPSBhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5yZWFscGF0aCh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNyZWFscGF0aCA9IHRoaXMucmVzb2x2ZShycCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PUkVBTFBBVEgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91cyB7QGxpbmsgcmVhbHBhdGh9XG4gICAgICovXG4gICAgcmVhbHBhdGhTeW5jKCkge1xuICAgICAgICBpZiAodGhpcy4jcmVhbHBhdGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVhbHBhdGg7XG4gICAgICAgIGlmICgoRU5PUkVBTFBBVEggfCBFTk9SRUFETElOSyB8IEVOT0VOVCkgJiB0aGlzLiN0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJwID0gdGhpcy4jZnMucmVhbHBhdGhTeW5jKHRoaXMuZnVsbHBhdGgoKSk7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3JlYWxwYXRoID0gdGhpcy5yZXNvbHZlKHJwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHRoaXMuI21hcmtFTk9SRUFMUEFUSCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBtYXJrIHRoaXMgUGF0aCBvYmplY3QgYXMgdGhlIHNjdXJyeSBjd2QsXG4gICAgICogY2FsbGVkIGJ5IHtAbGluayBQYXRoU2N1cnJ5I2NoZGlyfVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgW3NldEFzQ3dkXShvbGRDd2QpIHtcbiAgICAgICAgaWYgKG9sZEN3ZCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb2xkQ3dkLmlzQ1dEID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDV0QgPSB0cnVlO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gbmV3IFNldChbXSk7XG4gICAgICAgIGxldCBycCA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwICYmIHAucGFyZW50KSB7XG4gICAgICAgICAgICBjaGFuZ2VkLmFkZChwKTtcbiAgICAgICAgICAgIHAuI3JlbGF0aXZlID0gcnAuam9pbih0aGlzLnNlcCk7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZVBvc2l4ID0gcnAuam9pbignLycpO1xuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICAgICAgcnAucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgdW4tbWVtb2l6ZSBwYXJlbnRzIG9mIG9sZCBjd2RcbiAgICAgICAgcCA9IG9sZEN3ZDtcbiAgICAgICAgd2hpbGUgKHAgJiYgcC5wYXJlbnQgJiYgIWNoYW5nZWQuaGFzKHApKSB7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHAuI3JlbGF0aXZlUG9zaXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhdGhCYXNlID0gUGF0aEJhc2U7XG4vKipcbiAqIFBhdGggY2xhc3MgdXNlZCBvbiB3aW4zMiBzeXN0ZW1zXG4gKlxuICogVXNlcyBgJ1xcXFwnYCBhcyB0aGUgcGF0aCBzZXBhcmF0b3IgZm9yIHJldHVybmVkIHBhdGhzLCBlaXRoZXIgYCdcXFxcJ2Agb3IgYCcvJ2BcbiAqIGFzIHRoZSBwYXRoIHNlcGFyYXRvciBmb3IgcGFyc2luZyBwYXRocy5cbiAqL1xuY2xhc3MgUGF0aFdpbjMyIGV4dGVuZHMgUGF0aEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFNlcGFyYXRvciBmb3IgZ2VuZXJhdGluZyBwYXRoIHN0cmluZ3MuXG4gICAgICovXG4gICAgc2VwID0gJ1xcXFwnO1xuICAgIC8qKlxuICAgICAqIFNlcGFyYXRvciBmb3IgcGFyc2luZyBwYXRoIHN0cmluZ3MuXG4gICAgICovXG4gICAgc3BsaXRTZXAgPSBlaXRoZXJTZXA7XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNyZWF0ZSBuZXcgUGF0aCBvYmplY3RzIGRpcmVjdGx5LiAgVGhleSBzaG91bGQgYWx3YXlzIGJlIGFjY2Vzc2VkXG4gICAgICogdmlhIHRoZSBQYXRoU2N1cnJ5IGNsYXNzIG9yIG90aGVyIG1ldGhvZHMgb24gdGhlIFBhdGggY2xhc3MuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gVU5LTk9XTiwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgdHlwZSwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZXdDaGlsZChuYW1lLCB0eXBlID0gVU5LTk9XTiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFdpbjMyKG5hbWUsIHR5cGUsIHRoaXMucm9vdCwgdGhpcy5yb290cywgdGhpcy5ub2Nhc2UsIHRoaXMuY2hpbGRyZW5DYWNoZSgpLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Um9vdFN0cmluZyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBub2RlX3BhdGhfMS53aW4zMi5wYXJzZShwYXRoKS5yb290O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRSb290KHJvb3RQYXRoKSB7XG4gICAgICAgIHJvb3RQYXRoID0gdW5jVG9Ecml2ZShyb290UGF0aC50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgaWYgKHJvb3RQYXRoID09PSB0aGlzLnJvb3QubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvaywgbm90IHRoYXQgb25lLCBjaGVjayBpZiBpdCBtYXRjaGVzIGFub3RoZXIgd2Uga25vdyBhYm91dFxuICAgICAgICBmb3IgKGNvbnN0IFtjb21wYXJlLCByb290XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnJvb3RzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2FtZVJvb3Qocm9vdFBhdGgsIGNvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnJvb3RzW3Jvb3RQYXRoXSA9IHJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgaGF2ZSB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICByZXR1cm4gKHRoaXMucm9vdHNbcm9vdFBhdGhdID0gbmV3IFBhdGhTY3VycnlXaW4zMihyb290UGF0aCwgdGhpcykucm9vdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNhbWVSb290KHJvb3RQYXRoLCBjb21wYXJlID0gdGhpcy5yb290Lm5hbWUpIHtcbiAgICAgICAgLy8gd2luZG93cyBjYW4gKHJhcmVseSkgaGF2ZSBjYXNlLXNlbnNpdGl2ZSBmaWxlc3lzdGVtLCBidXRcbiAgICAgICAgLy8gVU5DIGFuZCBkcml2ZSBsZXR0ZXJzIGFyZSBhbHdheXMgY2FzZS1pbnNlbnNpdGl2ZSwgYW5kIGNhbm9uaWNhbGx5XG4gICAgICAgIC8vIHJlcHJlc2VudGVkIHVwcGVyY2FzZS5cbiAgICAgICAgcm9vdFBhdGggPSByb290UGF0aFxuICAgICAgICAgICAgLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ1xcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UodW5jRHJpdmVSZWdleHAsICckMVxcXFwnKTtcbiAgICAgICAgcmV0dXJuIHJvb3RQYXRoID09PSBjb21wYXJlO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFdpbjMyID0gUGF0aFdpbjMyO1xuLyoqXG4gKiBQYXRoIGNsYXNzIHVzZWQgb24gYWxsIHBvc2l4IHN5c3RlbXMuXG4gKlxuICogVXNlcyBgJy8nYCBhcyB0aGUgcGF0aCBzZXBhcmF0b3IuXG4gKi9cbmNsYXNzIFBhdGhQb3NpeCBleHRlbmRzIFBhdGhCYXNlIHtcbiAgICAvKipcbiAgICAgKiBzZXBhcmF0b3IgZm9yIHBhcnNpbmcgcGF0aCBzdHJpbmdzXG4gICAgICovXG4gICAgc3BsaXRTZXAgPSAnLyc7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBnZW5lcmF0aW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNlcCA9ICcvJztcbiAgICAvKipcbiAgICAgKiBEbyBub3QgY3JlYXRlIG5ldyBQYXRoIG9iamVjdHMgZGlyZWN0bHkuICBUaGV5IHNob3VsZCBhbHdheXMgYmUgYWNjZXNzZWRcbiAgICAgKiB2aWEgdGhlIFBhdGhTY3VycnkgY2xhc3Mgb3Igb3RoZXIgbWV0aG9kcyBvbiB0aGUgUGF0aCBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUgPSBVTktOT1dOLCByb290LCByb290cywgbm9jYXNlLCBjaGlsZHJlbiwgb3B0cykge1xuICAgICAgICBzdXBlcihuYW1lLCB0eXBlLCByb290LCByb290cywgbm9jYXNlLCBjaGlsZHJlbiwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJvb3RTdHJpbmcocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5zdGFydHNXaXRoKCcvJykgPyAnLycgOiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Um9vdChfcm9vdFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbmV3Q2hpbGQobmFtZSwgdHlwZSA9IFVOS05PV04sIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhQb3NpeChuYW1lLCB0eXBlLCB0aGlzLnJvb3QsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgb3B0cyk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoUG9zaXggPSBQYXRoUG9zaXg7XG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgUGF0aFNjdXJyeSBjbGFzc2VzLCBwcm92aWRpbmcgdGhlIGludGVyZmFjZSBmb3IgcGF0aFxuICogcmVzb2x1dGlvbiBhbmQgZmlsZXN5c3RlbSBvcGVyYXRpb25zLlxuICpcbiAqIFR5cGljYWxseSwgeW91IHNob3VsZCAqbm90KiBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCBidXQgcmF0aGVyIG9uZVxuICogb2YgdGhlIHBsYXRmb3JtLXNwZWNpZmljIGNsYXNzZXMsIG9yIHRoZSBleHBvcnRlZCB7QGxpbmsgUGF0aFNjdXJyeX0gd2hpY2hcbiAqIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICovXG5jbGFzcyBQYXRoU2N1cnJ5QmFzZSB7XG4gICAgLyoqXG4gICAgICogVGhlIHJvb3QgUGF0aCBlbnRyeSBmb3IgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3Rvcnkgb2YgdGhpcyBTY3VycnlcbiAgICAgKi9cbiAgICByb290O1xuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcGF0aCBmb3IgdGhlIHJvb3Qgb2YgdGhpcyBTY3VycnkncyBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gICAgICovXG4gICAgcm9vdFBhdGg7XG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIGFsbCByb290cyBlbmNvdW50ZXJlZCwgcmVmZXJlbmNlZCBieSByb290UGF0aFxuICAgICAqL1xuICAgIHJvb3RzO1xuICAgIC8qKlxuICAgICAqIFRoZSBQYXRoIGVudHJ5IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBQYXRoU2N1cnJ5J3MgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICBjd2Q7XG4gICAgI3Jlc29sdmVDYWNoZTtcbiAgICAjcmVzb2x2ZVBvc2l4Q2FjaGU7XG4gICAgI2NoaWxkcmVuO1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gcGF0aCBjb21wYXJpc29ucyBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0cnVlIG9uIERhcndpbiBhbmQgV2luZG93cyBzeXN0ZW1zLCBmYWxzZSBlbHNld2hlcmUuXG4gICAgICovXG4gICAgbm9jYXNlO1xuICAgICNmcztcbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogVXNlIFBhdGhTY3VycnlXaW4zMiwgUGF0aFNjdXJyeURhcndpbiwgUGF0aFNjdXJyeVBvc2l4LCBvciBQYXRoU2N1cnJ5XG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjd2QgPSBwcm9jZXNzLmN3ZCgpLCBwYXRoSW1wbCwgc2VwLCB7IG5vY2FzZSwgY2hpbGRyZW5DYWNoZVNpemUgPSAxNiAqIDEwMjQsIGZzID0gZGVmYXVsdEZTLCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy4jZnMgPSBmc0Zyb21PcHRpb24oZnMpO1xuICAgICAgICBpZiAoY3dkIGluc3RhbmNlb2YgVVJMIHx8IGN3ZC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcbiAgICAgICAgICAgIGN3ZCA9ICgwLCBub2RlX3VybF8xLmZpbGVVUkxUb1BhdGgpKGN3ZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbmQgc3BsaXQgcm9vdCwgYW5kIHRoZW4gYWRkIHRvIHRoZSBzdG9yZS5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgb25seSB0aW1lIHdlIGNhbGwgcGF0aC5yZXNvbHZlKClcbiAgICAgICAgY29uc3QgY3dkUGF0aCA9IHBhdGhJbXBsLnJlc29sdmUoY3dkKTtcbiAgICAgICAgdGhpcy5yb290cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMucm9vdFBhdGggPSB0aGlzLnBhcnNlUm9vdFBhdGgoY3dkUGF0aCk7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVDYWNoZSA9IG5ldyBSZXNvbHZlQ2FjaGUoKTtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZVBvc2l4Q2FjaGUgPSBuZXcgUmVzb2x2ZUNhY2hlKCk7XG4gICAgICAgIHRoaXMuI2NoaWxkcmVuID0gbmV3IENoaWxkcmVuQ2FjaGUoY2hpbGRyZW5DYWNoZVNpemUpO1xuICAgICAgICBjb25zdCBzcGxpdCA9IGN3ZFBhdGguc3Vic3RyaW5nKHRoaXMucm9vdFBhdGgubGVuZ3RoKS5zcGxpdChzZXApO1xuICAgICAgICAvLyByZXNvbHZlKCcvJykgbGVhdmVzICcnLCBzcGxpdHMgdG8gWycnXSwgd2UgZG9uJ3Qgd2FudCB0aGF0LlxuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAxICYmICFzcGxpdFswXSkge1xuICAgICAgICAgICAgc3BsaXQucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmIChub2Nhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBwcm92aWRlIG5vY2FzZSBzZXR0aW5nIHRvIFBhdGhTY3VycnlCYXNlIGN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLm5vY2FzZSA9IG5vY2FzZTtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5uZXdSb290KHRoaXMuI2ZzKTtcbiAgICAgICAgdGhpcy5yb290c1t0aGlzLnJvb3RQYXRoXSA9IHRoaXMucm9vdDtcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBsZW4gPSBzcGxpdC5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBqb2luU2VwID0gcGF0aEltcGwuc2VwO1xuICAgICAgICBsZXQgYWJzID0gdGhpcy5yb290UGF0aDtcbiAgICAgICAgbGV0IHNhd0ZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBzcGxpdCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IGxlbi0tO1xuICAgICAgICAgICAgcHJldiA9IHByZXYuY2hpbGQocGFydCwge1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlOiBuZXcgQXJyYXkobCkuZmlsbCgnLi4nKS5qb2luKGpvaW5TZXApLFxuICAgICAgICAgICAgICAgIHJlbGF0aXZlUG9zaXg6IG5ldyBBcnJheShsKS5maWxsKCcuLicpLmpvaW4oJy8nKSxcbiAgICAgICAgICAgICAgICBmdWxscGF0aDogKGFicyArPSAoc2F3Rmlyc3QgPyAnJyA6IGpvaW5TZXApICsgcGFydCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNhd0ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN3ZCA9IHByZXY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVwdGggb2YgYSBwcm92aWRlZCBwYXRoLCBzdHJpbmcsIG9yIHRoZSBjd2RcbiAgICAgKi9cbiAgICBkZXB0aChwYXRoID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0aCA9IHRoaXMuY3dkLnJlc29sdmUocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGguZGVwdGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjYWNoZSBvZiBjaGlsZCBlbnRyaWVzLiAgRXhwb3NlZCBzbyBzdWJjbGFzc2VzIGNhbiBjcmVhdGVcbiAgICAgKiBjaGlsZCBQYXRoIG9iamVjdHMgaW4gYSBwbGF0Zm9ybS1zcGVjaWZpYyB3YXkuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjaGlsZHJlbkNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hpbGRyZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgb25lIG9yIG1vcmUgcGF0aCBzdHJpbmdzIHRvIGEgcmVzb2x2ZWQgc3RyaW5nXG4gICAgICpcbiAgICAgKiBTYW1lIGludGVyZmFjZSBhcyByZXF1aXJlKCdwYXRoJykucmVzb2x2ZS5cbiAgICAgKlxuICAgICAqIE11Y2ggZmFzdGVyIHRoYW4gcGF0aC5yZXNvbHZlKCkgd2hlbiBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lXG4gICAgICogcGF0aCwgYmVjYXVzZSB0aGUgcmVzb2x2ZWQgUGF0aCBvYmplY3RzIGFyZSBjYWNoZWQuICBNdWNoIHNsb3dlclxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZXNvbHZlKC4uLnBhdGhzKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpZ3VyZSBvdXQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHBhdGhzIHdlIGhhdmUgdG8gdGVzdFxuICAgICAgICAvLyB3ZSBhbHdheXMgc3RhcnQgYXQgY3dkLCBidXQgYW55IGFic29sdXRlcyB3aWxsIGJ1bXAgdGhlIHN0YXJ0XG4gICAgICAgIGxldCByID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhdGhzW2ldO1xuICAgICAgICAgICAgaWYgKCFwIHx8IHAgPT09ICcuJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHIgPSByID8gYCR7cH0vJHtyfWAgOiBwO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBYnNvbHV0ZShwKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuI3Jlc29sdmVDYWNoZS5nZXQocik7XG4gICAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmN3ZC5yZXNvbHZlKHIpLmZ1bGxwYXRoKCk7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVDYWNoZS5zZXQociwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBvbmUgb3IgbW9yZSBwYXRoIHN0cmluZ3MgdG8gYSByZXNvbHZlZCBzdHJpbmcsIHJldHVybmluZ1xuICAgICAqIHRoZSBwb3NpeCBwYXRoLiAgSWRlbnRpY2FsIHRvIC5yZXNvbHZlKCkgb24gcG9zaXggc3lzdGVtcywgYnV0IG9uXG4gICAgICogd2luZG93cyB3aWxsIHJldHVybiBhIGZvcndhcmQtc2xhc2ggc2VwYXJhdGVkIFVOQyBwYXRoLlxuICAgICAqXG4gICAgICogU2FtZSBpbnRlcmZhY2UgYXMgcmVxdWlyZSgncGF0aCcpLnJlc29sdmUuXG4gICAgICpcbiAgICAgKiBNdWNoIGZhc3RlciB0aGFuIHBhdGgucmVzb2x2ZSgpIHdoZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICAgICAqIHBhdGgsIGJlY2F1c2UgdGhlIHJlc29sdmVkIFBhdGggb2JqZWN0cyBhcmUgY2FjaGVkLiAgTXVjaCBzbG93ZXJcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzb2x2ZVBvc2l4KC4uLnBhdGhzKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpZ3VyZSBvdXQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHBhdGhzIHdlIGhhdmUgdG8gdGVzdFxuICAgICAgICAvLyB3ZSBhbHdheXMgc3RhcnQgYXQgY3dkLCBidXQgYW55IGFic29sdXRlcyB3aWxsIGJ1bXAgdGhlIHN0YXJ0XG4gICAgICAgIGxldCByID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhdGhzW2ldO1xuICAgICAgICAgICAgaWYgKCFwIHx8IHAgPT09ICcuJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHIgPSByID8gYCR7cH0vJHtyfWAgOiBwO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBYnNvbHV0ZShwKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuI3Jlc29sdmVQb3NpeENhY2hlLmdldChyKTtcbiAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3dkLnJlc29sdmUocikuZnVsbHBhdGhQb3NpeCgpO1xuICAgICAgICB0aGlzLiNyZXNvbHZlUG9zaXhDYWNoZS5zZXQociwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZmluZCB0aGUgcmVsYXRpdmUgcGF0aCBmcm9tIHRoZSBjd2QgdG8gdGhlIHN1cHBsaWVkIHBhdGggc3RyaW5nIG9yIGVudHJ5XG4gICAgICovXG4gICAgcmVsYXRpdmUoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkucmVsYXRpdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZmluZCB0aGUgcmVsYXRpdmUgcGF0aCBmcm9tIHRoZSBjd2QgdG8gdGhlIHN1cHBsaWVkIHBhdGggc3RyaW5nIG9yXG4gICAgICogZW50cnksIHVzaW5nIC8gYXMgdGhlIHBhdGggZGVsaW1pdGVyLCBldmVuIG9uIFdpbmRvd3MuXG4gICAgICovXG4gICAgcmVsYXRpdmVQb3NpeChlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5yZWxhdGl2ZVBvc2l4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYmFzZW5hbWUgZm9yIHRoZSBwcm92aWRlZCBzdHJpbmcgb3IgUGF0aCBvYmplY3RcbiAgICAgKi9cbiAgICBiYXNlbmFtZShlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpcm5hbWUgZm9yIHRoZSBwcm92aWRlZCBzdHJpbmcgb3IgUGF0aCBvYmplY3RcbiAgICAgKi9cbiAgICBkaXJuYW1lKGVudHJ5ID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChlbnRyeS5wYXJlbnQgfHwgZW50cnkpLmZ1bGxwYXRoKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRkaXIoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHtcbiAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZSxcbiAgICB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzIH0gPSBvcHRzO1xuICAgICAgICBpZiAoIWVudHJ5LmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcCA9IGF3YWl0IGVudHJ5LnJlYWRkaXIoKTtcbiAgICAgICAgICAgIHJldHVybiB3aXRoRmlsZVR5cGVzID8gcCA6IHAubWFwKGUgPT4gZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkZGlyU3luYyhlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge1xuICAgICAgICB3aXRoRmlsZVR5cGVzOiB0cnVlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgPSB0cnVlIH0gPSBvcHRzO1xuICAgICAgICBpZiAoIWVudHJ5LmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpdGhGaWxlVHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5yZWFkZGlyU3luYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnJlYWRkaXJTeW5jKCkubWFwKGUgPT4gZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGxzdGF0KCkgb24gdGhlIHN0cmluZyBvciBQYXRoIG9iamVjdCwgYW5kIHVwZGF0ZSBhbGwga25vd25cbiAgICAgKiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBkZXRlcm1pbmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHVubGlrZSBgZnMubHN0YXQoKWAsIHRoZSByZXR1cm5lZCB2YWx1ZSBkb2VzIG5vdCBjb250YWluIHNvbWVcbiAgICAgKiBpbmZvcm1hdGlvbiwgc3VjaCBhcyBgbW9kZWAsIGBkZXZgLCBgbmxpbmtgLCBhbmQgYGlub2AuICBJZiB0aGF0XG4gICAgICogaW5mb3JtYXRpb24gaXMgcmVxdWlyZWQsIHlvdSB3aWxsIG5lZWQgdG8gY2FsbCBgZnMubHN0YXRgIHlvdXJzZWxmLlxuICAgICAqXG4gICAgICogSWYgdGhlIFBhdGggcmVmZXJzIHRvIGEgbm9uZXhpc3RlbnQgZmlsZSwgb3IgaWYgdGhlIGxzdGF0IGNhbGwgZmFpbHMgZm9yXG4gICAgICogYW55IHJlYXNvbiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuICBPdGhlcndpc2UgdGhlIHVwZGF0ZWQgUGF0aCBvYmplY3QgaXNcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdHMgYXJlIGNhY2hlZCwgYW5kIHRodXMgbWF5IGJlIG91dCBvZiBkYXRlIGlmIHRoZSBmaWxlc3lzdGVtIGlzXG4gICAgICogbXV0YXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBsc3RhdChlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5sc3RhdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzeW5jaHJvbm91cyB7QGxpbmsgUGF0aFNjdXJyeUJhc2UubHN0YXR9XG4gICAgICovXG4gICAgbHN0YXRTeW5jKGVudHJ5ID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LmxzdGF0U3luYygpO1xuICAgIH1cbiAgICBhc3luYyByZWFkbGluayhlbnRyeSA9IHRoaXMuY3dkLCB7IHdpdGhGaWxlVHlwZXMgfSA9IHtcbiAgICAgICAgd2l0aEZpbGVUeXBlczogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICB3aXRoRmlsZVR5cGVzID0gZW50cnkud2l0aEZpbGVUeXBlcztcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IGF3YWl0IGVudHJ5LnJlYWRsaW5rKCk7XG4gICAgICAgIHJldHVybiB3aXRoRmlsZVR5cGVzID8gZSA6IGU/LmZ1bGxwYXRoKCk7XG4gICAgfVxuICAgIHJlYWRsaW5rU3luYyhlbnRyeSA9IHRoaXMuY3dkLCB7IHdpdGhGaWxlVHlwZXMgfSA9IHtcbiAgICAgICAgd2l0aEZpbGVUeXBlczogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICB3aXRoRmlsZVR5cGVzID0gZW50cnkud2l0aEZpbGVUeXBlcztcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IGVudHJ5LnJlYWRsaW5rU3luYygpO1xuICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IGUgOiBlPy5mdWxscGF0aCgpO1xuICAgIH1cbiAgICBhc3luYyByZWFscGF0aChlbnRyeSA9IHRoaXMuY3dkLCB7IHdpdGhGaWxlVHlwZXMgfSA9IHtcbiAgICAgICAgd2l0aEZpbGVUeXBlczogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICB3aXRoRmlsZVR5cGVzID0gZW50cnkud2l0aEZpbGVUeXBlcztcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IGF3YWl0IGVudHJ5LnJlYWxwYXRoKCk7XG4gICAgICAgIHJldHVybiB3aXRoRmlsZVR5cGVzID8gZSA6IGU/LmZ1bGxwYXRoKCk7XG4gICAgfVxuICAgIHJlYWxwYXRoU3luYyhlbnRyeSA9IHRoaXMuY3dkLCB7IHdpdGhGaWxlVHlwZXMgfSA9IHtcbiAgICAgICAgd2l0aEZpbGVUeXBlczogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICB3aXRoRmlsZVR5cGVzID0gZW50cnkud2l0aEZpbGVUeXBlcztcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZSA9IGVudHJ5LnJlYWxwYXRoU3luYygpO1xuICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IGUgOiBlPy5mdWxscGF0aCgpO1xuICAgIH1cbiAgICBhc3luYyB3YWxrKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyA9IHRydWUsIGZvbGxvdyA9IGZhbHNlLCBmaWx0ZXIsIHdhbGtGaWx0ZXIsIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh3aXRoRmlsZVR5cGVzID8gZW50cnkgOiBlbnRyeS5mdWxscGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXJzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCB3YWxrID0gKGRpciwgY2IpID0+IHtcbiAgICAgICAgICAgIGRpcnMuYWRkKGRpcik7XG4gICAgICAgICAgICBkaXIucmVhZGRpckNCKChlciwgZW50cmllcykgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoIWxlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0tbGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh3aXRoRmlsZVR5cGVzID8gZSA6IGUuZnVsbHBhdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGxvdyAmJiBlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVhbHBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHIgPT4gKHI/LmlzVW5rbm93bigpID8gci5sc3RhdCgpIDogcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ociA9PiByPy5zaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpID8gd2FsayhyLCBuZXh0KSA6IG5leHQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsayhlLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUpOyAvLyB6YWxnb29vb29vb1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdGFydCA9IGVudHJ5O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICB3YWxrKHN0YXJ0LCBlciA9PiB7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqKGVyKTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHJlcyhyZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2Fsa1N5bmMoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpcnMgPSBuZXcgU2V0KFtlbnRyeV0pO1xuICAgICAgICBmb3IgKGNvbnN0IGRpciBvZiBkaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gZGlyLnJlYWRkaXJTeW5jKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2god2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgciA9IGU7XG4gICAgICAgICAgICAgICAgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShmb2xsb3cgJiYgKHIgPSBlLnJlYWxwYXRoU3luYygpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuaXNVbmtub3duKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByLmxzdGF0U3luYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoci5zaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnMuYWRkKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBmb3IgYGZvciBhd2FpdGBcbiAgICAgKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUGF0aFNjdXJyeUJhc2UuaXRlcmF0ZX1cbiAgICAgKlxuICAgICAqIE5vdGU6IEFzIG9mIE5vZGUgMTksIHRoaXMgaXMgdmVyeSBzbG93LCBjb21wYXJlZCB0byBvdGhlciBtZXRob2RzIG9mXG4gICAgICogd2Fsa2luZy4gIENvbnNpZGVyIHVzaW5nIHtAbGluayBQYXRoU2N1cnJ5QmFzZS5zdHJlYW19IGlmIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIGFuZCBiYWNrcHJlc3N1cmUgYXJlIGNvbmNlcm5zLCBvciB7QGxpbmsgUGF0aFNjdXJyeUJhc2Uud2Fsa30gaWYgbm90LlxuICAgICAqL1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG4gICAgaXRlcmF0ZShlbnRyeSA9IHRoaXMuY3dkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gaXRlcmF0aW5nIGFzeW5jIG92ZXIgdGhlIHN0cmVhbSBpcyBzaWduaWZpY2FudGx5IG1vcmUgcGVyZm9ybWFudCxcbiAgICAgICAgLy8gZXNwZWNpYWxseSBpbiB0aGUgd2FybS1jYWNoZSBzY2VuYXJpbywgYmVjYXVzZSBpdCBidWZmZXJzIHVwIGRpcmVjdG9yeVxuICAgICAgICAvLyBlbnRyaWVzIGluIHRoZSBiYWNrZ3JvdW5kIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgYSB5aWVsZCBmb3IgZWFjaCBvbmUuXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtKGVudHJ5LCBvcHRpb25zKVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0aW5nIG92ZXIgYSBQYXRoU2N1cnJ5IHBlcmZvcm1zIGEgc3luY2hyb25vdXMgd2Fsay5cbiAgICAgKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUGF0aFNjdXJyeUJhc2UuaXRlcmF0ZVN5bmN9XG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVTeW5jKCk7XG4gICAgfVxuICAgICppdGVyYXRlU3luYyhlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgPSB0cnVlLCBmb2xsb3cgPSBmYWxzZSwgZmlsdGVyLCB3YWxrRmlsdGVyLCB9ID0gb3B0cztcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgeWllbGQgd2l0aEZpbGVUeXBlcyA/IGVudHJ5IDogZW50cnkuZnVsbHBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXJzID0gbmV3IFNldChbZW50cnldKTtcbiAgICAgICAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IGRpci5yZWFkZGlyU3luYygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgd2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByID0gZTtcbiAgICAgICAgICAgICAgICBpZiAoZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGZvbGxvdyAmJiAociA9IGUucmVhbHBhdGhTeW5jKCkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoci5pc1Vua25vd24oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubHN0YXRTeW5jKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlycy5hZGQocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmVhbShlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgPSB0cnVlLCBmb2xsb3cgPSBmYWxzZSwgZmlsdGVyLCB3YWxrRmlsdGVyLCB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBtaW5pcGFzc18xLk1pbmlwYXNzKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0cy53cml0ZSh3aXRoRmlsZVR5cGVzID8gZW50cnkgOiBlbnRyeS5mdWxscGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXJzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFtlbnRyeV07XG4gICAgICAgIGxldCBwcm9jZXNzaW5nID0gMDtcbiAgICAgICAgY29uc3QgcHJvY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICghcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2luZyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZysrO1xuICAgICAgICAgICAgICAgIGRpcnMuYWRkKGRpcik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25SZWFkZGlyID0gKGVyLCBlbnRyaWVzLCBkaWRSZWFscGF0aHMgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xsb3cgJiYgIWRpZFJlYWxwYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWFscGF0aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigocikgPT4gcj8uaXNVbmtub3duKCkgPyByLmxzdGF0KCkgOiByKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IG9uUmVhZGRpcihudWxsLCBlbnRyaWVzLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzLndyaXRlKHdpdGhGaWxlVHlwZXMgPyBlIDogZS5mdWxscGF0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLS07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gZS5yZWFscGF0aENhY2hlZCgpIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5zaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF1c2VkICYmICFyZXN1bHRzLmZsb3dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMub25jZSgnZHJhaW4nLCBwcm9jZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyB6YWxnbyBjb250YWlubWVudFxuICAgICAgICAgICAgICAgIGxldCBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaXIucmVhZGRpckNCKG9uUmVhZGRpciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBzdHJlYW1TeW5jKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyA9IHRydWUsIGZvbGxvdyA9IGZhbHNlLCBmaWx0ZXIsIHdhbGtGaWx0ZXIsIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IG1pbmlwYXNzXzEuTWluaXBhc3MoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBkaXJzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXN1bHRzLndyaXRlKHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW2VudHJ5XTtcbiAgICAgICAgbGV0IHByb2Nlc3NpbmcgPSAwO1xuICAgICAgICBjb25zdCBwcm9jZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmICghZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nKys7XG4gICAgICAgICAgICAgICAgZGlycy5hZGQoZGlyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gZGlyLnJlYWRkaXJTeW5jKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMud3JpdGUod2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLS07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShmb2xsb3cgJiYgKHIgPSBlLnJlYWxwYXRoU3luYygpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5pc1Vua25vd24oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmxzdGF0U3luYygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF1c2VkICYmICFyZXN1bHRzLmZsb3dpbmcpXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5vbmNlKCdkcmFpbicsIHByb2Nlc3MpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBjaGRpcihwYXRoID0gdGhpcy5jd2QpIHtcbiAgICAgICAgY29uc3Qgb2xkQ3dkID0gdGhpcy5jd2Q7XG4gICAgICAgIHRoaXMuY3dkID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gdGhpcy5jd2QucmVzb2x2ZShwYXRoKSA6IHBhdGg7XG4gICAgICAgIHRoaXMuY3dkW3NldEFzQ3dkXShvbGRDd2QpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFNjdXJyeUJhc2UgPSBQYXRoU2N1cnJ5QmFzZTtcbi8qKlxuICogV2luZG93cyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGF0aFNjdXJyeUJhc2V9XG4gKlxuICogRGVmYXVsdHMgdG8gY2FzZSBpbnNlbnNpdHZlLCB1c2VzIGAnXFxcXCdgIHRvIGdlbmVyYXRlIHBhdGggc3RyaW5ncy4gIFVzZXNcbiAqIHtAbGluayBQYXRoV2luMzJ9IGZvciBQYXRoIG9iamVjdHMuXG4gKi9cbmNsYXNzIFBhdGhTY3VycnlXaW4zMiBleHRlbmRzIFBhdGhTY3VycnlCYXNlIHtcbiAgICAvKipcbiAgICAgKiBzZXBhcmF0b3IgZm9yIGdlbmVyYXRpbmcgcGF0aCBzdHJpbmdzXG4gICAgICovXG4gICAgc2VwID0gJ1xcXFwnO1xuICAgIGNvbnN0cnVjdG9yKGN3ZCA9IHByb2Nlc3MuY3dkKCksIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG5vY2FzZSA9IHRydWUgfSA9IG9wdHM7XG4gICAgICAgIHN1cGVyKGN3ZCwgbm9kZV9wYXRoXzEud2luMzIsICdcXFxcJywgeyAuLi5vcHRzLCBub2Nhc2UgfSk7XG4gICAgICAgIHRoaXMubm9jYXNlID0gbm9jYXNlO1xuICAgICAgICBmb3IgKGxldCBwID0gdGhpcy5jd2Q7IHA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICAgICAgcC5ub2Nhc2UgPSB0aGlzLm5vY2FzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYXJzZVJvb3RQYXRoKGRpcikge1xuICAgICAgICAvLyBpZiB0aGUgcGF0aCBzdGFydHMgd2l0aCBhIHNpbmdsZSBzZXBhcmF0b3IsIGl0J3Mgbm90IGEgVU5DLCBhbmQgd2UnbGxcbiAgICAgICAgLy8ganVzdCBnZXQgc2VwYXJhdG9yIGFzIHRoZSByb290LCBhbmQgZHJpdmVGcm9tVU5DIHdpbGwgcmV0dXJuIFxcXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgbW91bnQgXFwgb24gdGhlIHJvb3QgZnJvbSB0aGUgY3dkLlxuICAgICAgICByZXR1cm4gbm9kZV9wYXRoXzEud2luMzIucGFyc2UoZGlyKS5yb290LnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5ld1Jvb3QoZnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoV2luMzIodGhpcy5yb290UGF0aCwgSUZESVIsIHVuZGVmaW5lZCwgdGhpcy5yb290cywgdGhpcy5ub2Nhc2UsIHRoaXMuY2hpbGRyZW5DYWNoZSgpLCB7IGZzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcGF0aCBzdHJpbmcgaXMgYW4gYWJzb2x1dGUgcGF0aFxuICAgICAqL1xuICAgIGlzQWJzb2x1dGUocCkge1xuICAgICAgICByZXR1cm4gKHAuc3RhcnRzV2l0aCgnLycpIHx8IHAuc3RhcnRzV2l0aCgnXFxcXCcpIHx8IC9eW2Etel06KFxcL3xcXFxcKS9pLnRlc3QocCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFNjdXJyeVdpbjMyID0gUGF0aFNjdXJyeVdpbjMyO1xuLyoqXG4gKiB7QGxpbmsgUGF0aFNjdXJyeUJhc2V9IGltcGxlbWVudGF0aW9uIGZvciBhbGwgcG9zaXggc3lzdGVtcyBvdGhlciB0aGFuIERhcndpbi5cbiAqXG4gKiBEZWZhdWx0cyB0byBjYXNlLXNlbnNpdGl2ZSBtYXRjaGluZywgdXNlcyBgJy8nYCB0byBnZW5lcmF0ZSBwYXRoIHN0cmluZ3MuXG4gKlxuICogVXNlcyB7QGxpbmsgUGF0aFBvc2l4fSBmb3IgUGF0aCBvYmplY3RzLlxuICovXG5jbGFzcyBQYXRoU2N1cnJ5UG9zaXggZXh0ZW5kcyBQYXRoU2N1cnJ5QmFzZSB7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBnZW5lcmF0aW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNlcCA9ICcvJztcbiAgICBjb25zdHJ1Y3Rvcihjd2QgPSBwcm9jZXNzLmN3ZCgpLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBub2Nhc2UgPSBmYWxzZSB9ID0gb3B0cztcbiAgICAgICAgc3VwZXIoY3dkLCBub2RlX3BhdGhfMS5wb3NpeCwgJy8nLCB7IC4uLm9wdHMsIG5vY2FzZSB9KTtcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSBub2Nhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHBhcnNlUm9vdFBhdGgoX2Rpcikge1xuICAgICAgICByZXR1cm4gJy8nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZXdSb290KGZzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFBvc2l4KHRoaXMucm9vdFBhdGgsIElGRElSLCB1bmRlZmluZWQsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgeyBmcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBhdGggc3RyaW5nIGlzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgKi9cbiAgICBpc0Fic29sdXRlKHApIHtcbiAgICAgICAgcmV0dXJuIHAuc3RhcnRzV2l0aCgnLycpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFNjdXJyeVBvc2l4ID0gUGF0aFNjdXJyeVBvc2l4O1xuLyoqXG4gKiB7QGxpbmsgUGF0aFNjdXJyeUJhc2V9IGltcGxlbWVudGF0aW9uIGZvciBEYXJ3aW4gKG1hY09TKSBzeXN0ZW1zLlxuICpcbiAqIERlZmF1bHRzIHRvIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcsIHVzZXMgYCcvJ2AgZm9yIGdlbmVyYXRpbmcgcGF0aFxuICogc3RyaW5ncy5cbiAqXG4gKiBVc2VzIHtAbGluayBQYXRoUG9zaXh9IGZvciBQYXRoIG9iamVjdHMuXG4gKi9cbmNsYXNzIFBhdGhTY3VycnlEYXJ3aW4gZXh0ZW5kcyBQYXRoU2N1cnJ5UG9zaXgge1xuICAgIGNvbnN0cnVjdG9yKGN3ZCA9IHByb2Nlc3MuY3dkKCksIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG5vY2FzZSA9IHRydWUgfSA9IG9wdHM7XG4gICAgICAgIHN1cGVyKGN3ZCwgeyAuLi5vcHRzLCBub2Nhc2UgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoU2N1cnJ5RGFyd2luID0gUGF0aFNjdXJyeURhcndpbjtcbi8qKlxuICogRGVmYXVsdCB7QGxpbmsgUGF0aEJhc2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAqXG4gKiB7QGxpbmsgUGF0aFdpbjMyfSBvbiBXaW5kb3dzIHN5c3RlbXMsIHtAbGluayBQYXRoUG9zaXh9IG9uIGFsbCBvdGhlcnMuXG4gKi9cbmV4cG9ydHMuUGF0aCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyBQYXRoV2luMzIgOiBQYXRoUG9zaXg7XG4vKipcbiAqIERlZmF1bHQge0BsaW5rIFBhdGhTY3VycnlCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gKlxuICoge0BsaW5rIFBhdGhTY3VycnlXaW4zMn0gb24gV2luZG93cyBzeXN0ZW1zLCB7QGxpbmsgUGF0aFNjdXJyeURhcndpbn0gb25cbiAqIERhcndpbiAobWFjT1MpIHN5c3RlbXMsIHtAbGluayBQYXRoU2N1cnJ5UG9zaXh9IG9uIGFsbCBvdGhlcnMuXG4gKi9cbmV4cG9ydHMuUGF0aFNjdXJyeSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyBQYXRoU2N1cnJ5V2luMzJcbiAgICA6IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nID8gUGF0aFNjdXJyeURhcndpblxuICAgICAgICA6IFBhdGhTY3VycnlQb3NpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwiUGF0aFNjdXJyeSIsIlBhdGgiLCJQYXRoU2N1cnJ5RGFyd2luIiwiUGF0aFNjdXJyeVBvc2l4IiwiUGF0aFNjdXJyeVdpbjMyIiwiUGF0aFNjdXJyeUJhc2UiLCJQYXRoUG9zaXgiLCJQYXRoV2luMzIiLCJQYXRoQmFzZSIsIkNoaWxkcmVuQ2FjaGUiLCJSZXNvbHZlQ2FjaGUiLCJscnVfY2FjaGVfMSIsInJlcXVpcmUiLCJub2RlX3BhdGhfMSIsIm5vZGVfdXJsXzEiLCJmc18xIiwiYWN0dWFsRlMiLCJyZWFscGF0aFN5bmMiLCJuYXRpdmUiLCJwcm9taXNlc18xIiwibWluaXBhc3NfMSIsImRlZmF1bHRGUyIsImxzdGF0U3luYyIsInJlYWRkaXIiLCJyZWFkZGlyU3luYyIsInJlYWRsaW5rU3luYyIsInByb21pc2VzIiwibHN0YXQiLCJyZWFkbGluayIsInJlYWxwYXRoIiwiZnNGcm9tT3B0aW9uIiwiZnNPcHRpb24iLCJ1bmNEcml2ZVJlZ2V4cCIsInVuY1RvRHJpdmUiLCJyb290UGF0aCIsInJlcGxhY2UiLCJlaXRoZXJTZXAiLCJVTktOT1dOIiwiSUZJRk8iLCJJRkNIUiIsIklGRElSIiwiSUZCTEsiLCJJRlJFRyIsIklGTE5LIiwiSUZTT0NLIiwiSUZNVCIsIklGTVRfVU5LTk9XTiIsIlJFQURESVJfQ0FMTEVEIiwiTFNUQVRfQ0FMTEVEIiwiRU5PVERJUiIsIkVOT0VOVCIsIkVOT1JFQURMSU5LIiwiRU5PUkVBTFBBVEgiLCJFTk9DSElMRCIsIlRZUEVNQVNLIiwiZW50VG9UeXBlIiwicyIsImlzRmlsZSIsImlzRGlyZWN0b3J5IiwiaXNTeW1ib2xpY0xpbmsiLCJpc0NoYXJhY3RlckRldmljZSIsImlzQmxvY2tEZXZpY2UiLCJpc1NvY2tldCIsImlzRklGTyIsIm5vcm1hbGl6ZUNhY2hlIiwiTWFwIiwibm9ybWFsaXplIiwiYyIsIm4iLCJzZXQiLCJub3JtYWxpemVOb2Nhc2VDYWNoZSIsIm5vcm1hbGl6ZU5vY2FzZSIsInRvTG93ZXJDYXNlIiwiTFJVQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIm1heCIsIm1heFNpemUiLCJzaXplQ2FsY3VsYXRpb24iLCJhIiwibGVuZ3RoIiwic2V0QXNDd2QiLCJTeW1ib2wiLCJmcyIsImRldiIsIm1vZGUiLCJubGluayIsInVpZCIsImdpZCIsInJkZXYiLCJibGtzaXplIiwiaW5vIiwic2l6ZSIsImJsb2NrcyIsImF0aW1lTXMiLCJtdGltZU1zIiwiY3RpbWVNcyIsImJpcnRodGltZU1zIiwiYXRpbWUiLCJtdGltZSIsImN0aW1lIiwiYmlydGh0aW1lIiwibWF0Y2hOYW1lIiwiZGVwdGgiLCJmdWxscGF0aCIsImZ1bGxwYXRoUG9zaXgiLCJyZWxhdGl2ZSIsInJlbGF0aXZlUG9zaXgiLCJ0eXBlIiwiY2hpbGRyZW4iLCJsaW5rVGFyZ2V0IiwicGFyZW50UGF0aCIsInBhcmVudCIsInBhdGgiLCJuYW1lIiwicm9vdCIsInJvb3RzIiwibm9jYXNlIiwib3B0cyIsImlzQ1dEIiwib25SZWFkZGlyQ0IiLCJyZWFkZGlyQ0JJbkZsaWdodCIsImNoaWxkcmVuQ2FjaGUiLCJyZXNvbHZlIiwiZ2V0Um9vdFN0cmluZyIsImRpciIsInN1YnN0cmluZyIsImRpclBhcnRzIiwic3BsaXQiLCJzcGxpdFNlcCIsImdldFJvb3QiLCJyZXNvbHZlUGFydHMiLCJwIiwicGFydCIsImNoaWxkIiwiY2FjaGVkIiwiYXNzaWduIiwicHJvdmlzaW9uYWwiLCJwYXRoUGFydCIsInNlcCIsInBjaGlsZCIsIm5ld0NoaWxkIiwiY2FuUmVhZGRpciIsInB1c2giLCJwdiIsImZwIiwidGVzdCIsInBmcHAiLCJmcHAiLCJpc1Vua25vd24iLCJpc1R5cGUiLCJnZXRUeXBlIiwibHN0YXRDYWNoZWQiLCJyZWFkbGlua0NhY2hlZCIsInJlYWxwYXRoQ2FjaGVkIiwicmVhZGRpckNhY2hlZCIsInNsaWNlIiwiY2FuUmVhZGxpbmsiLCJpZm10IiwiY2FsbGVkUmVhZGRpciIsImlzRU5PRU5UIiwiaXNOYW1lZCIsInRhcmdldCIsInJlYWQiLCJlciIsInJlYWRsaW5rRmFpbCIsImNvZGUiLCJyZWFkZGlyU3VjY2VzcyIsIm1hcmtFTk9FTlQiLCJtYXJrQ2hpbGRyZW5FTk9FTlQiLCJtYXJrRU5PUkVBTFBBVEgiLCJtYXJrRU5PVERJUiIsInQiLCJyZWFkZGlyRmFpbCIsImxzdGF0RmFpbCIsInRlciIsInJlYWRkaXJBZGRDaGlsZCIsImUiLCJyZWFkZGlyTWF5YmVQcm9tb3RlQ2hpbGQiLCJyZWFkZGlyQWRkTmV3Q2hpbGQiLCJ1bnNoaWZ0IiwicmVhZGRpclByb21vdGVDaGlsZCIsImluZGV4IiwicG9wIiwic3BsaWNlIiwiYXBwbHlTdGF0Iiwic3QiLCJjYWxsT25SZWFkZGlyQ0IiLCJjYnMiLCJmb3JFYWNoIiwiY2IiLCJyZWFkZGlyQ0IiLCJhbGxvd1phbGdvIiwicXVldWVNaWNyb3Rhc2siLCJ3aXRoRmlsZVR5cGVzIiwiZW50cmllcyIsImFzeW5jUmVhZGRpckluRmxpZ2h0IiwiUHJvbWlzZSIsInJlcyIsInNob3VsZFdhbGsiLCJkaXJzIiwid2Fsa0ZpbHRlciIsImhhcyIsInJwIiwiXyIsIm9sZEN3ZCIsImNoYW5nZWQiLCJTZXQiLCJhZGQiLCJqb2luIiwid2luMzIiLCJwYXJzZSIsInRvVXBwZXJDYXNlIiwiY29tcGFyZSIsInNhbWVSb290Iiwic3RhcnRzV2l0aCIsIl9yb290UGF0aCIsInJlc29sdmVDYWNoZSIsInJlc29sdmVQb3NpeENhY2hlIiwiY3dkIiwicHJvY2VzcyIsInBhdGhJbXBsIiwiY2hpbGRyZW5DYWNoZVNpemUiLCJVUkwiLCJmaWxlVVJMVG9QYXRoIiwiY3dkUGF0aCIsInBhcnNlUm9vdFBhdGgiLCJUeXBlRXJyb3IiLCJuZXdSb290IiwicHJldiIsImxlbiIsImpvaW5TZXAiLCJhYnMiLCJzYXdGaXJzdCIsImwiLCJBcnJheSIsImZpbGwiLCJwYXRocyIsInIiLCJpIiwiaXNBYnNvbHV0ZSIsInJlc29sdmVQb3NpeCIsImVudHJ5IiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwibWFwIiwid2FsayIsImZvbGxvdyIsImZpbHRlciIsInJlc3VsdHMiLCJuZXh0IiwidGhlbiIsInN0YXJ0IiwicmVqIiwid2Fsa1N5bmMiLCJhc3luY0l0ZXJhdG9yIiwiaXRlcmF0ZSIsIm9wdGlvbnMiLCJzdHJlYW0iLCJpdGVyYXRvciIsIml0ZXJhdGVTeW5jIiwiTWluaXBhc3MiLCJvYmplY3RNb2RlIiwid3JpdGUiLCJxdWV1ZSIsInByb2Nlc3NpbmciLCJwYXVzZWQiLCJzaGlmdCIsImVuZCIsIm9uUmVhZGRpciIsImRpZFJlYWxwYXRocyIsImVtaXQiLCJhbGwiLCJmbG93aW5nIiwib25jZSIsInN5bmMiLCJzdHJlYW1TeW5jIiwiY2hkaXIiLCJwb3NpeCIsIl9kaXIiLCJwbGF0Zm9ybSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/path-scurry/dist/commonjs/index.js\n");

/***/ })

};
;