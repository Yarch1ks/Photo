/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zip-stream";
exports.ids = ["vendor-chunks/zip-stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/zip-stream/index.js":
/*!******************************************!*\
  !*** ./node_modules/zip-stream/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * ZipStream\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}\n * @copyright (c) 2014 Chris Talkington, contributors.\n */ var inherits = (__webpack_require__(/*! util */ \"util\").inherits);\nvar ZipArchiveOutputStream = (__webpack_require__(/*! compress-commons */ \"(rsc)/./node_modules/compress-commons/lib/compress-commons.js\").ZipArchiveOutputStream);\nvar ZipArchiveEntry = (__webpack_require__(/*! compress-commons */ \"(rsc)/./node_modules/compress-commons/lib/compress-commons.js\").ZipArchiveEntry);\nvar util = __webpack_require__(/*! archiver-utils */ \"(rsc)/./node_modules/archiver-utils/index.js\");\n/**\n * @constructor\n * @extends external:ZipArchiveOutputStream\n * @param {Object} [options]\n * @param {String} [options.comment] Sets the zip archive comment.\n * @param {Boolean} [options.forceLocalTime=false] Forces the archive to contain local file times instead of UTC.\n * @param {Boolean} [options.forceZip64=false] Forces the archive to contain ZIP64 headers.\n * @param {Boolean} [options.store=false] Sets the compression method to STORE.\n * @param {Object} [options.zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}\n * to control compression.\n */ var ZipStream = module.exports = function(options) {\n    if (!(this instanceof ZipStream)) {\n        return new ZipStream(options);\n    }\n    options = this.options = options || {};\n    options.zlib = options.zlib || {};\n    ZipArchiveOutputStream.call(this, options);\n    if (typeof options.level === \"number\" && options.level >= 0) {\n        options.zlib.level = options.level;\n        delete options.level;\n    }\n    if (!options.forceZip64 && typeof options.zlib.level === \"number\" && options.zlib.level === 0) {\n        options.store = true;\n    }\n    options.namePrependSlash = options.namePrependSlash || false;\n    if (options.comment && options.comment.length > 0) {\n        this.setComment(options.comment);\n    }\n};\ninherits(ZipStream, ZipArchiveOutputStream);\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @return {Object}\n */ ZipStream.prototype._normalizeFileData = function(data) {\n    data = util.defaults(data, {\n        type: \"file\",\n        name: null,\n        namePrependSlash: this.options.namePrependSlash,\n        linkname: null,\n        date: null,\n        mode: null,\n        store: this.options.store,\n        comment: \"\"\n    });\n    var isDir = data.type === \"directory\";\n    var isSymlink = data.type === \"symlink\";\n    if (data.name) {\n        data.name = util.sanitizePath(data.name);\n        if (!isSymlink && data.name.slice(-1) === \"/\") {\n            isDir = true;\n            data.type = \"directory\";\n        } else if (isDir) {\n            data.name += \"/\";\n        }\n    }\n    if (isDir || isSymlink) {\n        data.store = true;\n    }\n    data.date = util.dateify(data.date);\n    return data;\n};\n/**\n * Appends an entry given an input source (text string, buffer, or stream).\n *\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {Object} data\n * @param  {String} data.name Sets the entry name including internal path.\n * @param  {String} [data.comment] Sets the entry comment.\n * @param  {(String|Date)} [data.date=NOW()] Sets the entry date.\n * @param  {Number} [data.mode=D:0755/F:0644] Sets the entry permissions.\n * @param  {Boolean} [data.store=options.store] Sets the compression method to STORE.\n * @param  {String} [data.type=file] Sets the entry type. Defaults to `directory`\n * if name ends with trailing slash.\n * @param  {Function} callback\n * @return this\n */ ZipStream.prototype.entry = function(source, data, callback) {\n    if (typeof callback !== \"function\") {\n        callback = this._emitErrorCallback.bind(this);\n    }\n    data = this._normalizeFileData(data);\n    if (data.type !== \"file\" && data.type !== \"directory\" && data.type !== \"symlink\") {\n        callback(new Error(data.type + \" entries not currently supported\"));\n        return;\n    }\n    if (typeof data.name !== \"string\" || data.name.length === 0) {\n        callback(new Error(\"entry name must be a non-empty string value\"));\n        return;\n    }\n    if (data.type === \"symlink\" && typeof data.linkname !== \"string\") {\n        callback(new Error(\"entry linkname must be a non-empty string value when type equals symlink\"));\n        return;\n    }\n    var entry = new ZipArchiveEntry(data.name);\n    entry.setTime(data.date, this.options.forceLocalTime);\n    if (data.namePrependSlash) {\n        entry.setName(data.name, true);\n    }\n    if (data.store) {\n        entry.setMethod(0);\n    }\n    if (data.comment.length > 0) {\n        entry.setComment(data.comment);\n    }\n    if (data.type === \"symlink\" && typeof data.mode !== \"number\") {\n        data.mode = 40960; // 0120000\n    }\n    if (typeof data.mode === \"number\") {\n        if (data.type === \"symlink\") {\n            data.mode |= 40960;\n        }\n        entry.setUnixMode(data.mode);\n    }\n    if (data.type === \"symlink\" && typeof data.linkname === \"string\") {\n        source = Buffer.from(data.linkname);\n    }\n    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);\n};\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * @return void\n */ ZipStream.prototype.finalize = function() {\n    this.finish();\n}; /**\n * Returns the current number of bytes written to this stream.\n * @function ZipStream#getBytesWritten\n * @returns {Number}\n */  /**\n * Compress Commons ZipArchiveOutputStream\n * @external ZipArchiveOutputStream\n * @see {@link https://github.com/archiverjs/node-compress-commons}\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0NBTUMsR0FDRCxJQUFJQSxXQUFXQyxrREFBd0I7QUFFdkMsSUFBSUMseUJBQXlCRCxxSUFBa0Q7QUFDL0UsSUFBSUUsa0JBQWtCRiw4SEFBMkM7QUFFakUsSUFBSUcsT0FBT0gsbUJBQU9BLENBQUM7QUFFbkI7Ozs7Ozs7Ozs7Q0FVQyxHQUNELElBQUlJLFlBQVlDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxPQUFPO0lBQy9DLElBQUksQ0FBRSxLQUFJLFlBQVlILFNBQVEsR0FBSTtRQUNoQyxPQUFPLElBQUlBLFVBQVVHO0lBQ3ZCO0lBRUFBLFVBQVUsSUFBSSxDQUFDQSxPQUFPLEdBQUdBLFdBQVcsQ0FBQztJQUNyQ0EsUUFBUUMsSUFBSSxHQUFHRCxRQUFRQyxJQUFJLElBQUksQ0FBQztJQUVoQ1AsdUJBQXVCUSxJQUFJLENBQUMsSUFBSSxFQUFFRjtJQUVsQyxJQUFJLE9BQU9BLFFBQVFHLEtBQUssS0FBSyxZQUFZSCxRQUFRRyxLQUFLLElBQUksR0FBRztRQUMzREgsUUFBUUMsSUFBSSxDQUFDRSxLQUFLLEdBQUdILFFBQVFHLEtBQUs7UUFDbEMsT0FBT0gsUUFBUUcsS0FBSztJQUN0QjtJQUVBLElBQUksQ0FBQ0gsUUFBUUksVUFBVSxJQUFJLE9BQU9KLFFBQVFDLElBQUksQ0FBQ0UsS0FBSyxLQUFLLFlBQVlILFFBQVFDLElBQUksQ0FBQ0UsS0FBSyxLQUFLLEdBQUc7UUFDN0ZILFFBQVFLLEtBQUssR0FBRztJQUNsQjtJQUVBTCxRQUFRTSxnQkFBZ0IsR0FBR04sUUFBUU0sZ0JBQWdCLElBQUk7SUFFdkQsSUFBSU4sUUFBUU8sT0FBTyxJQUFJUCxRQUFRTyxPQUFPLENBQUNDLE1BQU0sR0FBRyxHQUFHO1FBQ2pELElBQUksQ0FBQ0MsVUFBVSxDQUFDVCxRQUFRTyxPQUFPO0lBQ2pDO0FBQ0Y7QUFFQWYsU0FBU0ssV0FBV0g7QUFFcEI7Ozs7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YUFBYSxPQUFPRixLQUFLSSxRQUFRLEtBQUssVUFBVTtRQUNoRVMsU0FBU1UsT0FBT0MsSUFBSSxDQUFDeEIsS0FBS0ksUUFBUTtJQUNwQztJQUVBLE9BQU90Qix1QkFBdUJnQixTQUFTLENBQUNjLEtBQUssQ0FBQ3RCLElBQUksQ0FBQyxJQUFJLEVBQUVzQixPQUFPQyxRQUFRQztBQUMxRTtBQUVBOzs7OztDQUtDLEdBQ0Q3QixVQUFVYSxTQUFTLENBQUMyQixRQUFRLEdBQUc7SUFDN0IsSUFBSSxDQUFDQyxNQUFNO0FBQ2IsR0FFQTs7OztDQUlDLElBRUQ7Ozs7Q0FJQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvemlwLXN0cmVhbS9pbmRleC5qcz9iNzlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogWmlwU3RyZWFtXG4gKlxuICogQGlnbm9yZVxuICogQGxpY2Vuc2UgW01JVF17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS16aXAtc3RyZWFtL2Jsb2IvbWFzdGVyL0xJQ0VOU0V9XG4gKiBAY29weXJpZ2h0IChjKSAyMDE0IENocmlzIFRhbGtpbmd0b24sIGNvbnRyaWJ1dG9ycy5cbiAqL1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuXG52YXIgWmlwQXJjaGl2ZU91dHB1dFN0cmVhbSA9IHJlcXVpcmUoJ2NvbXByZXNzLWNvbW1vbnMnKS5aaXBBcmNoaXZlT3V0cHV0U3RyZWFtO1xudmFyIFppcEFyY2hpdmVFbnRyeSA9IHJlcXVpcmUoJ2NvbXByZXNzLWNvbW1vbnMnKS5aaXBBcmNoaXZlRW50cnk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnYXJjaGl2ZXItdXRpbHMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIGV4dGVybmFsOlppcEFyY2hpdmVPdXRwdXRTdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jb21tZW50XSBTZXRzIHRoZSB6aXAgYXJjaGl2ZSBjb21tZW50LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb3JjZUxvY2FsVGltZT1mYWxzZV0gRm9yY2VzIHRoZSBhcmNoaXZlIHRvIGNvbnRhaW4gbG9jYWwgZmlsZSB0aW1lcyBpbnN0ZWFkIG9mIFVUQy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9yY2VaaXA2ND1mYWxzZV0gRm9yY2VzIHRoZSBhcmNoaXZlIHRvIGNvbnRhaW4gWklQNjQgaGVhZGVycy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcmU9ZmFsc2VdIFNldHMgdGhlIGNvbXByZXNzaW9uIG1ldGhvZCB0byBTVE9SRS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliXSBQYXNzZWQgdG8gW3psaWJde0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvemxpYi5odG1sI3psaWJfY2xhc3Nfb3B0aW9uc31cbiAqIHRvIGNvbnRyb2wgY29tcHJlc3Npb24uXG4gKi9cbnZhciBaaXBTdHJlYW0gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFppcFN0cmVhbSkpIHtcbiAgICByZXR1cm4gbmV3IFppcFN0cmVhbShvcHRpb25zKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnpsaWIgPSBvcHRpb25zLnpsaWIgfHwge307XG5cbiAgWmlwQXJjaGl2ZU91dHB1dFN0cmVhbS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5sZXZlbCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5sZXZlbCA+PSAwKSB7XG4gICAgb3B0aW9ucy56bGliLmxldmVsID0gb3B0aW9ucy5sZXZlbDtcbiAgICBkZWxldGUgb3B0aW9ucy5sZXZlbDtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5mb3JjZVppcDY0ICYmIHR5cGVvZiBvcHRpb25zLnpsaWIubGV2ZWwgPT09ICdudW1iZXInICYmIG9wdGlvbnMuemxpYi5sZXZlbCA9PT0gMCkge1xuICAgIG9wdGlvbnMuc3RvcmUgPSB0cnVlO1xuICB9XG5cbiAgb3B0aW9ucy5uYW1lUHJlcGVuZFNsYXNoID0gb3B0aW9ucy5uYW1lUHJlcGVuZFNsYXNoIHx8IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zLmNvbW1lbnQgJiYgb3B0aW9ucy5jb21tZW50Lmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLnNldENvbW1lbnQob3B0aW9ucy5jb21tZW50KTtcbiAgfVxufTtcblxuaW5oZXJpdHMoWmlwU3RyZWFtLCBaaXBBcmNoaXZlT3V0cHV0U3RyZWFtKTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGVudHJ5IGRhdGEgd2l0aCBmYWxsYmFja3MgZm9yIGtleSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuWmlwU3RyZWFtLnByb3RvdHlwZS5fbm9ybWFsaXplRmlsZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRhdGEgPSB1dGlsLmRlZmF1bHRzKGRhdGEsIHtcbiAgICB0eXBlOiAnZmlsZScsXG4gICAgbmFtZTogbnVsbCxcbiAgICBuYW1lUHJlcGVuZFNsYXNoOiB0aGlzLm9wdGlvbnMubmFtZVByZXBlbmRTbGFzaCxcbiAgICBsaW5rbmFtZTogbnVsbCxcbiAgICBkYXRlOiBudWxsLFxuICAgIG1vZGU6IG51bGwsXG4gICAgc3RvcmU6IHRoaXMub3B0aW9ucy5zdG9yZSxcbiAgICBjb21tZW50OiAnJ1xuICB9KTtcblxuICB2YXIgaXNEaXIgPSBkYXRhLnR5cGUgPT09ICdkaXJlY3RvcnknO1xuICB2YXIgaXNTeW1saW5rID0gZGF0YS50eXBlID09PSAnc3ltbGluayc7XG5cbiAgaWYgKGRhdGEubmFtZSkge1xuICAgIGRhdGEubmFtZSA9IHV0aWwuc2FuaXRpemVQYXRoKGRhdGEubmFtZSk7XG5cbiAgICBpZiAoIWlzU3ltbGluayAmJiBkYXRhLm5hbWUuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgIGlzRGlyID0gdHJ1ZTtcbiAgICAgIGRhdGEudHlwZSA9ICdkaXJlY3RvcnknO1xuICAgIH0gZWxzZSBpZiAoaXNEaXIpIHtcbiAgICAgIGRhdGEubmFtZSArPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGlyIHx8IGlzU3ltbGluaykge1xuICAgIGRhdGEuc3RvcmUgPSB0cnVlO1xuICB9XG5cbiAgZGF0YS5kYXRlID0gdXRpbC5kYXRlaWZ5KGRhdGEuZGF0ZSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYW4gZW50cnkgZ2l2ZW4gYW4gaW5wdXQgc291cmNlICh0ZXh0IHN0cmluZywgYnVmZmVyLCBvciBzdHJlYW0pLlxuICpcbiAqIEBwYXJhbSAgeyhCdWZmZXJ8U3RyZWFtfFN0cmluZyl9IHNvdXJjZSBUaGUgaW5wdXQgc291cmNlLlxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEubmFtZSBTZXRzIHRoZSBlbnRyeSBuYW1lIGluY2x1ZGluZyBpbnRlcm5hbCBwYXRoLlxuICogQHBhcmFtICB7U3RyaW5nfSBbZGF0YS5jb21tZW50XSBTZXRzIHRoZSBlbnRyeSBjb21tZW50LlxuICogQHBhcmFtICB7KFN0cmluZ3xEYXRlKX0gW2RhdGEuZGF0ZT1OT1coKV0gU2V0cyB0aGUgZW50cnkgZGF0ZS5cbiAqIEBwYXJhbSAge051bWJlcn0gW2RhdGEubW9kZT1EOjA3NTUvRjowNjQ0XSBTZXRzIHRoZSBlbnRyeSBwZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtkYXRhLnN0b3JlPW9wdGlvbnMuc3RvcmVdIFNldHMgdGhlIGNvbXByZXNzaW9uIG1ldGhvZCB0byBTVE9SRS5cbiAqIEBwYXJhbSAge1N0cmluZ30gW2RhdGEudHlwZT1maWxlXSBTZXRzIHRoZSBlbnRyeSB0eXBlLiBEZWZhdWx0cyB0byBgZGlyZWN0b3J5YFxuICogaWYgbmFtZSBlbmRzIHdpdGggdHJhaWxpbmcgc2xhc2guXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4gdGhpc1xuICovXG5aaXBTdHJlYW0ucHJvdG90eXBlLmVudHJ5ID0gZnVuY3Rpb24oc291cmNlLCBkYXRhLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSB0aGlzLl9lbWl0RXJyb3JDYWxsYmFjay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZGF0YSA9IHRoaXMuX25vcm1hbGl6ZUZpbGVEYXRhKGRhdGEpO1xuXG4gIGlmIChkYXRhLnR5cGUgIT09ICdmaWxlJyAmJiBkYXRhLnR5cGUgIT09ICdkaXJlY3RvcnknICYmIGRhdGEudHlwZSAhPT0gJ3N5bWxpbmsnKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKGRhdGEudHlwZSArICcgZW50cmllcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGRhdGEubmFtZSAhPT0gJ3N0cmluZycgfHwgZGF0YS5uYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIGNhbGxiYWNrKG5ldyBFcnJvcignZW50cnkgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyB2YWx1ZScpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YS50eXBlID09PSAnc3ltbGluaycgJiYgdHlwZW9mIGRhdGEubGlua25hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdlbnRyeSBsaW5rbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyB2YWx1ZSB3aGVuIHR5cGUgZXF1YWxzIHN5bWxpbmsnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVudHJ5ID0gbmV3IFppcEFyY2hpdmVFbnRyeShkYXRhLm5hbWUpO1xuICBlbnRyeS5zZXRUaW1lKGRhdGEuZGF0ZSwgdGhpcy5vcHRpb25zLmZvcmNlTG9jYWxUaW1lKTtcblxuICBpZiAoZGF0YS5uYW1lUHJlcGVuZFNsYXNoKSB7XG4gICAgZW50cnkuc2V0TmFtZShkYXRhLm5hbWUsIHRydWUpO1xuICB9XG5cbiAgaWYgKGRhdGEuc3RvcmUpIHtcbiAgICBlbnRyeS5zZXRNZXRob2QoMCk7XG4gIH1cblxuICBpZiAoZGF0YS5jb21tZW50Lmxlbmd0aCA+IDApIHtcbiAgICBlbnRyeS5zZXRDb21tZW50KGRhdGEuY29tbWVudCk7XG4gIH1cblxuICBpZiAoZGF0YS50eXBlID09PSAnc3ltbGluaycgJiYgdHlwZW9mIGRhdGEubW9kZSAhPT0gJ251bWJlcicpIHtcbiAgICBkYXRhLm1vZGUgPSA0MDk2MDsgLy8gMDEyMDAwMFxuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhLm1vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ3N5bWxpbmsnKSB7XG4gICAgICBkYXRhLm1vZGUgfD0gNDA5NjA7XG4gICAgfVxuXG4gICAgZW50cnkuc2V0VW5peE1vZGUoZGF0YS5tb2RlKTtcbiAgfVxuXG4gIGlmIChkYXRhLnR5cGUgPT09ICdzeW1saW5rJyAmJiB0eXBlb2YgZGF0YS5saW5rbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2UgPSBCdWZmZXIuZnJvbShkYXRhLmxpbmtuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBaaXBBcmNoaXZlT3V0cHV0U3RyZWFtLnByb3RvdHlwZS5lbnRyeS5jYWxsKHRoaXMsIGVudHJ5LCBzb3VyY2UsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmluYWxpemVzIHRoZSBpbnN0YW5jZSBhbmQgcHJldmVudHMgZnVydGhlciBhcHBlbmRpbmcgdG8gdGhlIGFyY2hpdmVcbiAqIHN0cnVjdHVyZSAocXVldWUgd2lsbCBjb250aW51ZSB0aWwgZHJhaW5lZCkuXG4gKlxuICogQHJldHVybiB2b2lkXG4gKi9cblppcFN0cmVhbS5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5maW5pc2goKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiB0byB0aGlzIHN0cmVhbS5cbiAqIEBmdW5jdGlvbiBaaXBTdHJlYW0jZ2V0Qnl0ZXNXcml0dGVuXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5cbi8qKlxuICogQ29tcHJlc3MgQ29tbW9ucyBaaXBBcmNoaXZlT3V0cHV0U3RyZWFtXG4gKiBAZXh0ZXJuYWwgWmlwQXJjaGl2ZU91dHB1dFN0cmVhbVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1jb21wcmVzcy1jb21tb25zfVxuICovXG4iXSwibmFtZXMiOlsiaW5oZXJpdHMiLCJyZXF1aXJlIiwiWmlwQXJjaGl2ZU91dHB1dFN0cmVhbSIsIlppcEFyY2hpdmVFbnRyeSIsInV0aWwiLCJaaXBTdHJlYW0iLCJtb2R1bGUiLCJleHBvcnRzIiwib3B0aW9ucyIsInpsaWIiLCJjYWxsIiwibGV2ZWwiLCJmb3JjZVppcDY0Iiwic3RvcmUiLCJuYW1lUHJlcGVuZFNsYXNoIiwiY29tbWVudCIsImxlbmd0aCIsInNldENvbW1lbnQiLCJwcm90b3R5cGUiLCJfbm9ybWFsaXplRmlsZURhdGEiLCJkYXRhIiwiZGVmYXVsdHMiLCJ0eXBlIiwibmFtZSIsImxpbmtuYW1lIiwiZGF0ZSIsIm1vZGUiLCJpc0RpciIsImlzU3ltbGluayIsInNhbml0aXplUGF0aCIsInNsaWNlIiwiZGF0ZWlmeSIsImVudHJ5Iiwic291cmNlIiwiY2FsbGJhY2siLCJfZW1pdEVycm9yQ2FsbGJhY2siLCJiaW5kIiwiRXJyb3IiLCJzZXRUaW1lIiwiZm9yY2VMb2NhbFRpbWUiLCJzZXROYW1lIiwic2V0TWV0aG9kIiwic2V0VW5peE1vZGUiLCJCdWZmZXIiLCJmcm9tIiwiZmluYWxpemUiLCJmaW5pc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/zip-stream/index.js\n");

/***/ })

};
;