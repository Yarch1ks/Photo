/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/glob";
exports.ids = ["vendor-chunks/glob"];
exports.modules = {

/***/ "(rsc)/./node_modules/glob/node_modules/brace-expansion/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/glob/node_modules/brace-expansion/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var balanced = __webpack_require__(/*! balanced-match */ \"(rsc)/./node_modules/balanced-match/index.js\");\nmodule.exports = expandTop;\nvar escSlash = \"\\x00SLASH\" + Math.random() + \"\\x00\";\nvar escOpen = \"\\x00OPEN\" + Math.random() + \"\\x00\";\nvar escClose = \"\\x00CLOSE\" + Math.random() + \"\\x00\";\nvar escComma = \"\\x00COMMA\" + Math.random() + \"\\x00\";\nvar escPeriod = \"\\x00PERIOD\" + Math.random() + \"\\x00\";\nfunction numeric(str) {\n    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str.split(\"\\\\\\\\\").join(escSlash).split(\"\\\\{\").join(escOpen).split(\"\\\\}\").join(escClose).split(\"\\\\,\").join(escComma).split(\"\\\\.\").join(escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str.split(escSlash).join(\"\\\\\").split(escOpen).join(\"{\").split(escClose).join(\"}\").split(escComma).join(\",\").split(escPeriod).join(\".\");\n}\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n    if (!str) return [\n        \"\"\n    ];\n    var parts = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return str.split(\",\");\n    var pre = m.pre;\n    var body = m.body;\n    var post = m.post;\n    var p = pre.split(\",\");\n    p[p.length - 1] += \"{\" + body + \"}\";\n    var postParts = parseCommaParts(post);\n    if (post.length) {\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nfunction expandTop(str) {\n    if (!str) return [];\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.substr(0, 2) === \"{}\") {\n        str = \"\\\\{\\\\}\" + str.substr(2);\n    }\n    return expand(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return \"{\" + str + \"}\";\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand(str, isTop) {\n    var expansions = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return [\n        str\n    ];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    var pre = m.pre;\n    var post = m.post.length ? expand(m.post, false) : [\n        \"\"\n    ];\n    if (/\\$$/.test(m.pre)) {\n        for(var k = 0; k < post.length; k++){\n            var expansion = pre + \"{\" + m.body + \"}\" + post[k];\n            expansions.push(expansion);\n        }\n    } else {\n        var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isSequence = isNumericSequence || isAlphaSequence;\n        var isOptions = m.body.indexOf(\",\") >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + \"{\" + m.body + escClose + m.post;\n                return expand(str);\n            }\n            return [\n                str\n            ];\n        }\n        var n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        } else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand(n[0], false).map(embrace);\n                if (n.length === 1) {\n                    return post.map(function(p) {\n                        return m.pre + n[0] + p;\n                    });\n                }\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        var N;\n        if (isSequence) {\n            var x = numeric(n[0]);\n            var y = numeric(n[1]);\n            var width = Math.max(n[0].length, n[1].length);\n            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n            var test = lte;\n            var reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            var pad = n.some(isPadded);\n            N = [];\n            for(var i = x; test(i, y); i += incr){\n                var c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === \"\\\\\") c = \"\";\n                } else {\n                    c = String(i);\n                    if (pad) {\n                        var need = width - c.length;\n                        if (need > 0) {\n                            var z = new Array(need + 1).join(\"0\");\n                            if (i < 0) c = \"-\" + z + c.slice(1);\n                            else c = z + c;\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        } else {\n            N = [];\n            for(var j = 0; j < n.length; j++){\n                N.push.apply(N, expand(n[j], false));\n            }\n        }\n        for(var j = 0; j < N.length; j++){\n            for(var k = 0; k < post.length; k++){\n                var expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) expansions.push(expansion);\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvYnJhY2UtZXhwYW5zaW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDO0FBRXZCQyxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLFdBQVcsY0FBVUMsS0FBS0MsTUFBTSxLQUFHO0FBQ3ZDLElBQUlDLFVBQVUsYUFBU0YsS0FBS0MsTUFBTSxLQUFHO0FBQ3JDLElBQUlFLFdBQVcsY0FBVUgsS0FBS0MsTUFBTSxLQUFHO0FBQ3ZDLElBQUlHLFdBQVcsY0FBVUosS0FBS0MsTUFBTSxLQUFHO0FBQ3ZDLElBQUlJLFlBQVksZUFBV0wsS0FBS0MsTUFBTSxLQUFHO0FBRXpDLFNBQVNLLFFBQVFDLEdBQUc7SUFDbEIsT0FBT0MsU0FBU0QsS0FBSyxPQUFPQSxNQUN4QkMsU0FBU0QsS0FBSyxNQUNkQSxJQUFJRSxVQUFVLENBQUM7QUFDckI7QUFFQSxTQUFTQyxhQUFhSCxHQUFHO0lBQ3ZCLE9BQU9BLElBQUlJLEtBQUssQ0FBQyxRQUFRQyxJQUFJLENBQUNiLFVBQ25CWSxLQUFLLENBQUMsT0FBT0MsSUFBSSxDQUFDVixTQUNsQlMsS0FBSyxDQUFDLE9BQU9DLElBQUksQ0FBQ1QsVUFDbEJRLEtBQUssQ0FBQyxPQUFPQyxJQUFJLENBQUNSLFVBQ2xCTyxLQUFLLENBQUMsT0FBT0MsSUFBSSxDQUFDUDtBQUMvQjtBQUVBLFNBQVNRLGVBQWVOLEdBQUc7SUFDekIsT0FBT0EsSUFBSUksS0FBSyxDQUFDWixVQUFVYSxJQUFJLENBQUMsTUFDckJELEtBQUssQ0FBQ1QsU0FBU1UsSUFBSSxDQUFDLEtBQ3BCRCxLQUFLLENBQUNSLFVBQVVTLElBQUksQ0FBQyxLQUNyQkQsS0FBSyxDQUFDUCxVQUFVUSxJQUFJLENBQUMsS0FDckJELEtBQUssQ0FBQ04sV0FBV08sSUFBSSxDQUFDO0FBQ25DO0FBR0Esb0RBQW9EO0FBQ3BELHdEQUF3RDtBQUN4RCxrREFBa0Q7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QUNwQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGhvdG8tc2t1LXByb2Nlc3Nvci8uL25vZGVfbW9kdWxlcy9nbG9iL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanM/M2Y2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFsYW5jZWQgPSByZXF1aXJlKCdiYWxhbmNlZC1tYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cGFuZFRvcDtcblxudmFyIGVzY1NsYXNoID0gJ1xcMFNMQVNIJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY09wZW4gPSAnXFwwT1BFTicrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDbG9zZSA9ICdcXDBDTE9TRScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDb21tYSA9ICdcXDBDT01NQScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NQZXJpb2QgPSAnXFwwUEVSSU9EJytNYXRoLnJhbmRvbSgpKydcXDAnO1xuXG5mdW5jdGlvbiBudW1lcmljKHN0cikge1xuICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCkgPT0gc3RyXG4gICAgPyBwYXJzZUludChzdHIsIDEwKVxuICAgIDogc3RyLmNoYXJDb2RlQXQoMCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnXFxcXFxcXFwnKS5qb2luKGVzY1NsYXNoKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxceycpLmpvaW4oZXNjT3BlbilcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXH0nKS5qb2luKGVzY0Nsb3NlKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLCcpLmpvaW4oZXNjQ29tbWEpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwuJykuam9pbihlc2NQZXJpb2QpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChlc2NTbGFzaCkuam9pbignXFxcXCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjT3Blbikuam9pbigneycpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ2xvc2UpLmpvaW4oJ30nKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0NvbW1hKS5qb2luKCcsJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NQZXJpb2QpLmpvaW4oJy4nKTtcbn1cblxuXG4vLyBCYXNpY2FsbHkganVzdCBzdHIuc3BsaXQoXCIsXCIpLCBidXQgaGFuZGxpbmcgY2FzZXNcbi8vIHdoZXJlIHdlIGhhdmUgbmVzdGVkIGJyYWNlZCBzZWN0aW9ucywgd2hpY2ggc2hvdWxkIGJlXG4vLyB0cmVhdGVkIGFzIGluZGl2aWR1YWwgbWVtYmVycywgbGlrZSB7YSx7YixjfSxkfVxuZnVuY3Rpb24gcGFyc2VDb21tYVBhcnRzKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gWycnXTtcblxuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcblxuICBpZiAoIW0pXG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnLCcpO1xuXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIGJvZHkgPSBtLmJvZHk7XG4gIHZhciBwb3N0ID0gbS5wb3N0O1xuICB2YXIgcCA9IHByZS5zcGxpdCgnLCcpO1xuXG4gIHBbcC5sZW5ndGgtMV0gKz0gJ3snICsgYm9keSArICd9JztcbiAgdmFyIHBvc3RQYXJ0cyA9IHBhcnNlQ29tbWFQYXJ0cyhwb3N0KTtcbiAgaWYgKHBvc3QubGVuZ3RoKSB7XG4gICAgcFtwLmxlbmd0aC0xXSArPSBwb3N0UGFydHMuc2hpZnQoKTtcbiAgICBwLnB1c2guYXBwbHkocCwgcG9zdFBhcnRzKTtcbiAgfVxuXG4gIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHApO1xuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9wKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gW107XG5cbiAgLy8gSSBkb24ndCBrbm93IHdoeSBCYXNoIDQuMyBkb2VzIHRoaXMsIGJ1dCBpdCBkb2VzLlxuICAvLyBBbnl0aGluZyBzdGFydGluZyB3aXRoIHt9IHdpbGwgaGF2ZSB0aGUgZmlyc3QgdHdvIGJ5dGVzIHByZXNlcnZlZFxuICAvLyBidXQgKm9ubHkqIGF0IHRoZSB0b3AgbGV2ZWwsIHNvIHt9LGF9YiB3aWxsIG5vdCBleHBhbmQgdG8gYW55dGhpbmcsXG4gIC8vIGJ1dCBhe30sYn1jIHdpbGwgYmUgZXhwYW5kZWQgdG8gW2F9YyxhYmNdLlxuICAvLyBPbmUgY291bGQgYXJndWUgdGhhdCB0aGlzIGlzIGEgYnVnIGluIEJhc2gsIGJ1dCBzaW5jZSB0aGUgZ29hbCBvZlxuICAvLyB0aGlzIG1vZHVsZSBpcyB0byBtYXRjaCBCYXNoJ3MgcnVsZXMsIHdlIGVzY2FwZSBhIGxlYWRpbmcge31cbiAgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICd7fScpIHtcbiAgICBzdHIgPSAnXFxcXHtcXFxcfScgKyBzdHIuc3Vic3RyKDIpO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChlc2NhcGVCcmFjZXMoc3RyKSwgdHJ1ZSkubWFwKHVuZXNjYXBlQnJhY2VzKTtcbn1cblxuZnVuY3Rpb24gZW1icmFjZShzdHIpIHtcbiAgcmV0dXJuICd7JyArIHN0ciArICd9Jztcbn1cbmZ1bmN0aW9uIGlzUGFkZGVkKGVsKSB7XG4gIHJldHVybiAvXi0/MFxcZC8udGVzdChlbCk7XG59XG5cbmZ1bmN0aW9uIGx0ZShpLCB5KSB7XG4gIHJldHVybiBpIDw9IHk7XG59XG5mdW5jdGlvbiBndGUoaSwgeSkge1xuICByZXR1cm4gaSA+PSB5O1xufVxuXG5mdW5jdGlvbiBleHBhbmQoc3RyLCBpc1RvcCkge1xuICB2YXIgZXhwYW5zaW9ucyA9IFtdO1xuXG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG4gIGlmICghbSkgcmV0dXJuIFtzdHJdO1xuXG4gIC8vIG5vIG5lZWQgdG8gZXhwYW5kIHByZSwgc2luY2UgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSBmcmVlIG9mIGJyYWNlLXNldHNcbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgIDogWycnXTtcblxuICBpZiAoL1xcJCQvLnRlc3QobS5wcmUpKSB7ICAgIFxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSsgJ3snICsgbS5ib2R5ICsgJ30nICsgcG9zdFtrXTtcbiAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXNOdW1lcmljU2VxdWVuY2UgPSAvXi0/XFxkK1xcLlxcLi0/XFxkKyg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICAgIHZhciBpc0FscGhhU2VxdWVuY2UgPSAvXlthLXpBLVpdXFwuXFwuW2EtekEtWl0oPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgICB2YXIgaXNTZXF1ZW5jZSA9IGlzTnVtZXJpY1NlcXVlbmNlIHx8IGlzQWxwaGFTZXF1ZW5jZTtcbiAgICB2YXIgaXNPcHRpb25zID0gbS5ib2R5LmluZGV4T2YoJywnKSA+PSAwO1xuICAgIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgICAvLyB7YX0sYn1cbiAgICAgIGlmIChtLnBvc3QubWF0Y2goLywoPyEsKS4qXFx9LykpIHtcbiAgICAgICAgc3RyID0gbS5wcmUgKyAneycgKyBtLmJvZHkgKyBlc2NDbG9zZSArIG0ucG9zdDtcbiAgICAgICAgcmV0dXJuIGV4cGFuZChzdHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtzdHJdO1xuICAgIH1cblxuICAgIHZhciBuO1xuICAgIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgICBuID0gbS5ib2R5LnNwbGl0KC9cXC5cXC4vKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IHBhcnNlQ29tbWFQYXJ0cyhtLmJvZHkpO1xuICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHh7e2EsYn19eSA9PT4geHthfXkgeHtifXlcbiAgICAgICAgbiA9IGV4cGFuZChuWzBdLCBmYWxzZSkubWFwKGVtYnJhY2UpO1xuICAgICAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gcG9zdC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIG0ucHJlICsgblswXSArIHA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBuIGlzIHRoZSBwYXJ0cywgYW5kIHdlIGtub3cgaXQncyBub3QgYSBjb21tYSBzZXRcbiAgICAvLyB3aXRoIGEgc2luZ2xlIGVudHJ5LlxuICAgIHZhciBOO1xuXG4gICAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICAgIHZhciB4ID0gbnVtZXJpYyhuWzBdKTtcbiAgICAgIHZhciB5ID0gbnVtZXJpYyhuWzFdKTtcbiAgICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KG5bMF0ubGVuZ3RoLCBuWzFdLmxlbmd0aClcbiAgICAgIHZhciBpbmNyID0gbi5sZW5ndGggPT0gM1xuICAgICAgICA/IE1hdGguYWJzKG51bWVyaWMoblsyXSkpXG4gICAgICAgIDogMTtcbiAgICAgIHZhciB0ZXN0ID0gbHRlO1xuICAgICAgdmFyIHJldmVyc2UgPSB5IDwgeDtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIGluY3IgKj0gLTE7XG4gICAgICAgIHRlc3QgPSBndGU7XG4gICAgICB9XG4gICAgICB2YXIgcGFkID0gbi5zb21lKGlzUGFkZGVkKTtcblxuICAgICAgTiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0geDsgdGVzdChpLCB5KTsgaSArPSBpbmNyKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICBpZiAoaXNBbHBoYVNlcXVlbmNlKSB7XG4gICAgICAgICAgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgICAgaWYgKGMgPT09ICdcXFxcJylcbiAgICAgICAgICAgIGMgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjID0gU3RyaW5nKGkpO1xuICAgICAgICAgIGlmIChwYWQpIHtcbiAgICAgICAgICAgIHZhciBuZWVkID0gd2lkdGggLSBjLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuZWVkID4gMCkge1xuICAgICAgICAgICAgICB2YXIgeiA9IG5ldyBBcnJheShuZWVkICsgMSkuam9pbignMCcpO1xuICAgICAgICAgICAgICBpZiAoaSA8IDApXG4gICAgICAgICAgICAgICAgYyA9ICctJyArIHogKyBjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYyA9IHogKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBOLnB1c2goYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIE4ucHVzaC5hcHBseShOLCBleHBhbmQobltqXSwgZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IE4ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gcHJlICsgTltqXSArIHBvc3Rba107XG4gICAgICAgIGlmICghaXNUb3AgfHwgaXNTZXF1ZW5jZSB8fCBleHBhbnNpb24pXG4gICAgICAgICAgZXhwYW5zaW9ucy5wdXNoKGV4cGFuc2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuc2lvbnM7XG59XG5cbiJdLCJuYW1lcyI6WyJiYWxhbmNlZCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXhwYW5kVG9wIiwiZXNjU2xhc2giLCJNYXRoIiwicmFuZG9tIiwiZXNjT3BlbiIsImVzY0Nsb3NlIiwiZXNjQ29tbWEiLCJlc2NQZXJpb2QiLCJudW1lcmljIiwic3RyIiwicGFyc2VJbnQiLCJjaGFyQ29kZUF0IiwiZXNjYXBlQnJhY2VzIiwic3BsaXQiLCJqb2luIiwidW5lc2NhcGVCcmFjZXMiLCJwYXJzZUNvbW1hUGFydHMiLCJwYXJ0cyIsIm0iLCJwcmUiLCJib2R5IiwicG9zdCIsInAiLCJsZW5ndGgiLCJwb3N0UGFydHMiLCJzaGlmdCIsInB1c2giLCJhcHBseSIsInN1YnN0ciIsImV4cGFuZCIsIm1hcCIsImVtYnJhY2UiLCJpc1BhZGRlZCIsImVsIiwidGVzdCIsImx0ZSIsImkiLCJ5IiwiZ3RlIiwiaXNUb3AiLCJleHBhbnNpb25zIiwiayIsImV4cGFuc2lvbiIsImlzTnVtZXJpY1NlcXVlbmNlIiwiaXNBbHBoYVNlcXVlbmNlIiwiaXNTZXF1ZW5jZSIsImlzT3B0aW9ucyIsImluZGV4T2YiLCJtYXRjaCIsIm4iLCJOIiwieCIsIndpZHRoIiwibWF4IiwiaW5jciIsImFicyIsInJldmVyc2UiLCJwYWQiLCJzb21lIiwiYyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm5lZWQiLCJ6IiwiQXJyYXkiLCJzbGljZSIsImoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/glob.js":
/*!*************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/glob.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Glob = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\");\nconst node_url_1 = __webpack_require__(/*! node:url */ \"node:url\");\nconst path_scurry_1 = __webpack_require__(/*! path-scurry */ \"(rsc)/./node_modules/path-scurry/dist/commonjs/index.js\");\nconst pattern_js_1 = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/commonjs/pattern.js\");\nconst walker_js_1 = __webpack_require__(/*! ./walker.js */ \"(rsc)/./node_modules/glob/dist/commonjs/walker.js\");\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform = typeof process === \"object\" && process && typeof process.platform === \"string\" ? process.platform : \"linux\";\n/**\n * An object that can perform glob pattern traversals.\n */ class Glob {\n    /**\n     * All options are stored as properties on the `Glob` object.\n     *\n     * See {@link GlobOptions} for full options descriptions.\n     *\n     * Note that a previous `Glob` object can be passed as the\n     * `GlobOptions` to another `Glob` instantiation to re-use settings\n     * and caches with a new pattern.\n     *\n     * Traversal functions can be called multiple times to run the walk\n     * again.\n     */ constructor(pattern, opts){\n        /* c8 ignore start */ if (!opts) throw new TypeError(\"glob options required\");\n        /* c8 ignore stop */ this.withFileTypes = !!opts.withFileTypes;\n        this.signal = opts.signal;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.dotRelative = !!opts.dotRelative;\n        this.nodir = !!opts.nodir;\n        this.mark = !!opts.mark;\n        if (!opts.cwd) {\n            this.cwd = \"\";\n        } else if (opts.cwd instanceof URL || opts.cwd.startsWith(\"file://\")) {\n            opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);\n        }\n        this.cwd = opts.cwd || \"\";\n        this.root = opts.root;\n        this.magicalBraces = !!opts.magicalBraces;\n        this.nobrace = !!opts.nobrace;\n        this.noext = !!opts.noext;\n        this.realpath = !!opts.realpath;\n        this.absolute = opts.absolute;\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        this.noglobstar = !!opts.noglobstar;\n        this.matchBase = !!opts.matchBase;\n        this.maxDepth = typeof opts.maxDepth === \"number\" ? opts.maxDepth : Infinity;\n        this.stat = !!opts.stat;\n        this.ignore = opts.ignore;\n        if (this.withFileTypes && this.absolute !== undefined) {\n            throw new Error(\"cannot set absolute and withFileTypes:true\");\n        }\n        if (typeof pattern === \"string\") {\n            pattern = [\n                pattern\n            ];\n        }\n        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            pattern = pattern.map((p)=>p.replace(/\\\\/g, \"/\"));\n        }\n        if (this.matchBase) {\n            if (opts.noglobstar) {\n                throw new TypeError(\"base matching requires globstar\");\n            }\n            pattern = pattern.map((p)=>p.includes(\"/\") ? p : `./**/${p}`);\n        }\n        this.pattern = pattern;\n        this.platform = opts.platform || defaultPlatform;\n        this.opts = {\n            ...opts,\n            platform: this.platform\n        };\n        if (opts.scurry) {\n            this.scurry = opts.scurry;\n            if (opts.nocase !== undefined && opts.nocase !== opts.scurry.nocase) {\n                throw new Error(\"nocase option contradicts provided scurry option\");\n            }\n        } else {\n            const Scurry = opts.platform === \"win32\" ? path_scurry_1.PathScurryWin32 : opts.platform === \"darwin\" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;\n            this.scurry = new Scurry(this.cwd, {\n                nocase: opts.nocase,\n                fs: opts.fs\n            });\n        }\n        this.nocase = this.scurry.nocase;\n        // If you do nocase:true on a case-sensitive file system, then\n        // we need to use regexps instead of strings for non-magic\n        // path portions, because statting `aBc` won't return results\n        // for the file `AbC` for example.\n        const nocaseMagicOnly = this.platform === \"darwin\" || this.platform === \"win32\";\n        const mmo = {\n            // default nocase based on platform\n            ...opts,\n            dot: this.dot,\n            matchBase: this.matchBase,\n            nobrace: this.nobrace,\n            nocase: this.nocase,\n            nocaseMagicOnly,\n            nocomment: true,\n            noext: this.noext,\n            nonegate: true,\n            optimizationLevel: 2,\n            platform: this.platform,\n            windowsPathsNoEscape: this.windowsPathsNoEscape,\n            debug: !!this.opts.debug\n        };\n        const mms = this.pattern.map((p)=>new minimatch_1.Minimatch(p, mmo));\n        const [matchSet, globParts] = mms.reduce((set, m)=>{\n            set[0].push(...m.set);\n            set[1].push(...m.globParts);\n            return set;\n        }, [\n            [],\n            []\n        ]);\n        this.patterns = matchSet.map((set, i)=>{\n            const g = globParts[i];\n            /* c8 ignore start */ if (!g) throw new Error(\"invalid pattern object\");\n            /* c8 ignore stop */ return new pattern_js_1.Pattern(set, g, 0, this.platform);\n        });\n    }\n    async walk() {\n        // Walkers always return array of Path objects, so we just have to\n        // coerce them into the right shape.  It will have already called\n        // realpath() if the option was set to do so, so we know that's cached.\n        // start out knowing the cwd, at least\n        return [\n            ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches\n            }).walk()\n        ];\n    }\n    walkSync() {\n        return [\n            ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {\n                ...this.opts,\n                maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,\n                platform: this.platform,\n                nocase: this.nocase,\n                includeChildMatches: this.includeChildMatches\n            }).walkSync()\n        ];\n    }\n    stream() {\n        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches\n        }).stream();\n    }\n    streamSync() {\n        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {\n            ...this.opts,\n            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,\n            platform: this.platform,\n            nocase: this.nocase,\n            includeChildMatches: this.includeChildMatches\n        }).streamSync();\n    }\n    /**\n     * Default sync iteration function. Returns a Generator that\n     * iterates over the results.\n     */ iterateSync() {\n        return this.streamSync()[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    /**\n     * Default async iteration function. Returns an AsyncGenerator that\n     * iterates over the results.\n     */ iterate() {\n        return this.stream()[Symbol.asyncIterator]();\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n}\nexports.Glob = Glob; //# sourceMappingURL=glob.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2dsb2IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBRyxLQUFLO0FBQ3BCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLDBGQUFXO0FBQ3ZDLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLDBCQUFVO0FBQ3JDLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUMsNEVBQWE7QUFDM0MsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsd0VBQWM7QUFDM0MsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsc0VBQWE7QUFDekMsNENBQTRDO0FBQzVDLGdEQUFnRDtBQUNoRCxNQUFNSyxrQkFBa0IsT0FBUUMsWUFBWSxZQUN4Q0EsV0FDQSxPQUFPQSxRQUFRQyxRQUFRLEtBQUssV0FDNUJELFFBQVFDLFFBQVEsR0FDZDtBQUNOOztDQUVDLEdBQ0QsTUFBTVQ7SUFrQ0Y7Ozs7Ozs7Ozs7O0tBV0MsR0FDRFUsWUFBWUMsT0FBTyxFQUFFQyxJQUFJLENBQUU7UUFDdkIsbUJBQW1CLEdBQ25CLElBQUksQ0FBQ0EsTUFDRCxNQUFNLElBQUlDLFVBQVU7UUFDeEIsa0JBQWtCLEdBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLENBQUMsQ0FBQ0YsS0FBS0UsYUFBYTtRQUN6QyxJQUFJLENBQUNDLE1BQU0sR0FBR0gsS0FBS0csTUFBTTtRQUN6QixJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDLENBQUNKLEtBQUtJLE1BQU07UUFDM0IsSUFBSSxDQUFDQyxHQUFHLEdBQUcsQ0FBQyxDQUFDTCxLQUFLSyxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLENBQUMsQ0FBQ04sS0FBS00sV0FBVztRQUNyQyxJQUFJLENBQUNDLEtBQUssR0FBRyxDQUFDLENBQUNQLEtBQUtPLEtBQUs7UUFDekIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQyxD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WUFDbkJoQixxQkFBcUIsSUFBSSxDQUFDQSxtQkFBbUI7UUFDakQsR0FBRytDLFVBQVU7SUFDakI7SUFDQTs7O0tBR0MsR0FDREMsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDRCxVQUFVLEVBQUUsQ0FBQ0UsT0FBT0MsUUFBUSxDQUFDO0lBQzdDO0lBQ0EsQ0FBQ0QsT0FBT0MsUUFBUSxDQUFDLEdBQUc7UUFDaEIsT0FBTyxJQUFJLENBQUNGLFdBQVc7SUFDM0I7SUFDQTs7O0tBR0MsR0FDREcsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDTixNQUFNLEVBQUUsQ0FBQ0ksT0FBT0csYUFBYSxDQUFDO0lBQzlDO0lBQ0EsQ0FBQ0gsT0FBT0csYUFBYSxDQUFDLEdBQUc7UUFDckIsT0FBTyxJQUFJLENBQUNELE9BQU87SUFDdkI7QUFDSjtBQUNBcEYsWUFBWSxHQUFHRSxNQUNmLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2dsb2IuanM/ZjM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2xvYiA9IHZvaWQgMDtcbmNvbnN0IG1pbmltYXRjaF8xID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbmNvbnN0IG5vZGVfdXJsXzEgPSByZXF1aXJlKFwibm9kZTp1cmxcIik7XG5jb25zdCBwYXRoX3NjdXJyeV8xID0gcmVxdWlyZShcInBhdGgtc2N1cnJ5XCIpO1xuY29uc3QgcGF0dGVybl9qc18xID0gcmVxdWlyZShcIi4vcGF0dGVybi5qc1wiKTtcbmNvbnN0IHdhbGtlcl9qc18xID0gcmVxdWlyZShcIi4vd2Fsa2VyLmpzXCIpO1xuLy8gaWYgbm8gcHJvY2VzcyBnbG9iYWwsIGp1c3QgY2FsbCBpdCBsaW51eC5cbi8vIHNvIHdlIGRlZmF1bHQgdG8gY2FzZS1zZW5zaXRpdmUsIC8gc2VwYXJhdG9yc1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIHByb2Nlc3MgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3N0cmluZycpID9cbiAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAnbGludXgnO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gcGVyZm9ybSBnbG9iIHBhdHRlcm4gdHJhdmVyc2Fscy5cbiAqL1xuY2xhc3MgR2xvYiB7XG4gICAgYWJzb2x1dGU7XG4gICAgY3dkO1xuICAgIHJvb3Q7XG4gICAgZG90O1xuICAgIGRvdFJlbGF0aXZlO1xuICAgIGZvbGxvdztcbiAgICBpZ25vcmU7XG4gICAgbWFnaWNhbEJyYWNlcztcbiAgICBtYXJrO1xuICAgIG1hdGNoQmFzZTtcbiAgICBtYXhEZXB0aDtcbiAgICBub2JyYWNlO1xuICAgIG5vY2FzZTtcbiAgICBub2RpcjtcbiAgICBub2V4dDtcbiAgICBub2dsb2JzdGFyO1xuICAgIHBhdHRlcm47XG4gICAgcGxhdGZvcm07XG4gICAgcmVhbHBhdGg7XG4gICAgc2N1cnJ5O1xuICAgIHN0YXQ7XG4gICAgc2lnbmFsO1xuICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlO1xuICAgIHdpdGhGaWxlVHlwZXM7XG4gICAgaW5jbHVkZUNoaWxkTWF0Y2hlcztcbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW9ucyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgb3B0cztcbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBwYXJzZWQgaW1tdXRhYmxlIHtAbGluayBQYXR0ZXJufSBvYmplY3RzLlxuICAgICAqL1xuICAgIHBhdHRlcm5zO1xuICAgIC8qKlxuICAgICAqIEFsbCBvcHRpb25zIGFyZSBzdG9yZWQgYXMgcHJvcGVydGllcyBvbiB0aGUgYEdsb2JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgR2xvYk9wdGlvbnN9IGZvciBmdWxsIG9wdGlvbnMgZGVzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGEgcHJldmlvdXMgYEdsb2JgIG9iamVjdCBjYW4gYmUgcGFzc2VkIGFzIHRoZVxuICAgICAqIGBHbG9iT3B0aW9uc2AgdG8gYW5vdGhlciBgR2xvYmAgaW5zdGFudGlhdGlvbiB0byByZS11c2Ugc2V0dGluZ3NcbiAgICAgKiBhbmQgY2FjaGVzIHdpdGggYSBuZXcgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIFRyYXZlcnNhbCBmdW5jdGlvbnMgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBydW4gdGhlIHdhbGtcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRzKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIW9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnbG9iIG9wdGlvbnMgcmVxdWlyZWQnKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53aXRoRmlsZVR5cGVzID0gISFvcHRzLndpdGhGaWxlVHlwZXM7XG4gICAgICAgIHRoaXMuc2lnbmFsID0gb3B0cy5zaWduYWw7XG4gICAgICAgIHRoaXMuZm9sbG93ID0gISFvcHRzLmZvbGxvdztcbiAgICAgICAgdGhpcy5kb3QgPSAhIW9wdHMuZG90O1xuICAgICAgICB0aGlzLmRvdFJlbGF0aXZlID0gISFvcHRzLmRvdFJlbGF0aXZlO1xuICAgICAgICB0aGlzLm5vZGlyID0gISFvcHRzLm5vZGlyO1xuICAgICAgICB0aGlzLm1hcmsgPSAhIW9wdHMubWFyaztcbiAgICAgICAgaWYgKCFvcHRzLmN3ZCkge1xuICAgICAgICAgICAgdGhpcy5jd2QgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmN3ZCBpbnN0YW5jZW9mIFVSTCB8fCBvcHRzLmN3ZC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcbiAgICAgICAgICAgIG9wdHMuY3dkID0gKDAsIG5vZGVfdXJsXzEuZmlsZVVSTFRvUGF0aCkob3B0cy5jd2QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3dkID0gb3B0cy5jd2QgfHwgJyc7XG4gICAgICAgIHRoaXMucm9vdCA9IG9wdHMucm9vdDtcbiAgICAgICAgdGhpcy5tYWdpY2FsQnJhY2VzID0gISFvcHRzLm1hZ2ljYWxCcmFjZXM7XG4gICAgICAgIHRoaXMubm9icmFjZSA9ICEhb3B0cy5ub2JyYWNlO1xuICAgICAgICB0aGlzLm5vZXh0ID0gISFvcHRzLm5vZXh0O1xuICAgICAgICB0aGlzLnJlYWxwYXRoID0gISFvcHRzLnJlYWxwYXRoO1xuICAgICAgICB0aGlzLmFic29sdXRlID0gb3B0cy5hYnNvbHV0ZTtcbiAgICAgICAgdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzID0gb3B0cy5pbmNsdWRlQ2hpbGRNYXRjaGVzICE9PSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub2dsb2JzdGFyID0gISFvcHRzLm5vZ2xvYnN0YXI7XG4gICAgICAgIHRoaXMubWF0Y2hCYXNlID0gISFvcHRzLm1hdGNoQmFzZTtcbiAgICAgICAgdGhpcy5tYXhEZXB0aCA9XG4gICAgICAgICAgICB0eXBlb2Ygb3B0cy5tYXhEZXB0aCA9PT0gJ251bWJlcicgPyBvcHRzLm1heERlcHRoIDogSW5maW5pdHk7XG4gICAgICAgIHRoaXMuc3RhdCA9ICEhb3B0cy5zdGF0O1xuICAgICAgICB0aGlzLmlnbm9yZSA9IG9wdHMuaWdub3JlO1xuICAgICAgICBpZiAodGhpcy53aXRoRmlsZVR5cGVzICYmIHRoaXMuYWJzb2x1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2V0IGFic29sdXRlIGFuZCB3aXRoRmlsZVR5cGVzOnRydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gW3BhdHRlcm5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRzLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8XG4gICAgICAgICAgICAgICAgb3B0cy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSkge1xuICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ubWFwKHAgPT4gcC5yZXBsYWNlKC9cXFxcL2csICcvJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoQmFzZSkge1xuICAgICAgICAgICAgaWYgKG9wdHMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Jhc2UgbWF0Y2hpbmcgcmVxdWlyZXMgZ2xvYnN0YXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLm1hcChwID0+IChwLmluY2x1ZGVzKCcvJykgPyBwIDogYC4vKiovJHtwfWApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gb3B0cy5wbGF0Zm9ybSB8fCBkZWZhdWx0UGxhdGZvcm07XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0gfTtcbiAgICAgICAgaWYgKG9wdHMuc2N1cnJ5KSB7XG4gICAgICAgICAgICB0aGlzLnNjdXJyeSA9IG9wdHMuc2N1cnJ5O1xuICAgICAgICAgICAgaWYgKG9wdHMubm9jYXNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvcHRzLm5vY2FzZSAhPT0gb3B0cy5zY3Vycnkubm9jYXNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2Nhc2Ugb3B0aW9uIGNvbnRyYWRpY3RzIHByb3ZpZGVkIHNjdXJyeSBvcHRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFNjdXJyeSA9IG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicgPyBwYXRoX3NjdXJyeV8xLlBhdGhTY3VycnlXaW4zMlxuICAgICAgICAgICAgICAgIDogb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgPyBwYXRoX3NjdXJyeV8xLlBhdGhTY3VycnlEYXJ3aW5cbiAgICAgICAgICAgICAgICAgICAgOiBvcHRzLnBsYXRmb3JtID8gcGF0aF9zY3VycnlfMS5QYXRoU2N1cnJ5UG9zaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGF0aF9zY3VycnlfMS5QYXRoU2N1cnJ5O1xuICAgICAgICAgICAgdGhpcy5zY3VycnkgPSBuZXcgU2N1cnJ5KHRoaXMuY3dkLCB7XG4gICAgICAgICAgICAgICAgbm9jYXNlOiBvcHRzLm5vY2FzZSxcbiAgICAgICAgICAgICAgICBmczogb3B0cy5mcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9jYXNlID0gdGhpcy5zY3Vycnkubm9jYXNlO1xuICAgICAgICAvLyBJZiB5b3UgZG8gbm9jYXNlOnRydWUgb24gYSBjYXNlLXNlbnNpdGl2ZSBmaWxlIHN5c3RlbSwgdGhlblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHVzZSByZWdleHBzIGluc3RlYWQgb2Ygc3RyaW5ncyBmb3Igbm9uLW1hZ2ljXG4gICAgICAgIC8vIHBhdGggcG9ydGlvbnMsIGJlY2F1c2Ugc3RhdHRpbmcgYGFCY2Agd29uJ3QgcmV0dXJuIHJlc3VsdHNcbiAgICAgICAgLy8gZm9yIHRoZSBmaWxlIGBBYkNgIGZvciBleGFtcGxlLlxuICAgICAgICBjb25zdCBub2Nhc2VNYWdpY09ubHkgPSB0aGlzLnBsYXRmb3JtID09PSAnZGFyd2luJyB8fCB0aGlzLnBsYXRmb3JtID09PSAnd2luMzInO1xuICAgICAgICBjb25zdCBtbW8gPSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IG5vY2FzZSBiYXNlZCBvbiBwbGF0Zm9ybVxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIGRvdDogdGhpcy5kb3QsXG4gICAgICAgICAgICBtYXRjaEJhc2U6IHRoaXMubWF0Y2hCYXNlLFxuICAgICAgICAgICAgbm9icmFjZTogdGhpcy5ub2JyYWNlLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIG5vY2FzZU1hZ2ljT25seSxcbiAgICAgICAgICAgIG5vY29tbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIG5vZXh0OiB0aGlzLm5vZXh0LFxuICAgICAgICAgICAgbm9uZWdhdGU6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWl6YXRpb25MZXZlbDogMixcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgd2luZG93c1BhdGhzTm9Fc2NhcGU6IHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUsXG4gICAgICAgICAgICBkZWJ1ZzogISF0aGlzLm9wdHMuZGVidWcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1tcyA9IHRoaXMucGF0dGVybi5tYXAocCA9PiBuZXcgbWluaW1hdGNoXzEuTWluaW1hdGNoKHAsIG1tbykpO1xuICAgICAgICBjb25zdCBbbWF0Y2hTZXQsIGdsb2JQYXJ0c10gPSBtbXMucmVkdWNlKChzZXQsIG0pID0+IHtcbiAgICAgICAgICAgIHNldFswXS5wdXNoKC4uLm0uc2V0KTtcbiAgICAgICAgICAgIHNldFsxXS5wdXNoKC4uLm0uZ2xvYlBhcnRzKTtcbiAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH0sIFtbXSwgW11dKTtcbiAgICAgICAgdGhpcy5wYXR0ZXJucyA9IG1hdGNoU2V0Lm1hcCgoc2V0LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnID0gZ2xvYlBhcnRzW2ldO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAoIWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhdHRlcm4gb2JqZWN0Jyk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXR0ZXJuX2pzXzEuUGF0dGVybihzZXQsIGcsIDAsIHRoaXMucGxhdGZvcm0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgd2FsaygpIHtcbiAgICAgICAgLy8gV2Fsa2VycyBhbHdheXMgcmV0dXJuIGFycmF5IG9mIFBhdGggb2JqZWN0cywgc28gd2UganVzdCBoYXZlIHRvXG4gICAgICAgIC8vIGNvZXJjZSB0aGVtIGludG8gdGhlIHJpZ2h0IHNoYXBlLiAgSXQgd2lsbCBoYXZlIGFscmVhZHkgY2FsbGVkXG4gICAgICAgIC8vIHJlYWxwYXRoKCkgaWYgdGhlIG9wdGlvbiB3YXMgc2V0IHRvIGRvIHNvLCBzbyB3ZSBrbm93IHRoYXQncyBjYWNoZWQuXG4gICAgICAgIC8vIHN0YXJ0IG91dCBrbm93aW5nIHRoZSBjd2QsIGF0IGxlYXN0XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi4oYXdhaXQgbmV3IHdhbGtlcl9qc18xLkdsb2JXYWxrZXIodGhpcy5wYXR0ZXJucywgdGhpcy5zY3VycnkuY3dkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRzLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggKyB0aGlzLnNjdXJyeS5jd2QuZGVwdGgoKVxuICAgICAgICAgICAgICAgICAgICA6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgICAgIG5vY2FzZTogdGhpcy5ub2Nhc2UsXG4gICAgICAgICAgICAgICAgaW5jbHVkZUNoaWxkTWF0Y2hlczogdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzLFxuICAgICAgICAgICAgfSkud2FsaygpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgd2Fsa1N5bmMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5uZXcgd2Fsa2VyX2pzXzEuR2xvYldhbGtlcih0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGggIT09IEluZmluaXR5ID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgICAgIDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlQ2hpbGRNYXRjaGVzOiB0aGlzLmluY2x1ZGVDaGlsZE1hdGNoZXMsXG4gICAgICAgICAgICB9KS53YWxrU3luYygpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2Fsa2VyX2pzXzEuR2xvYlN0cmVhbSh0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgfSkuc3RyZWFtKCk7XG4gICAgfVxuICAgIHN0cmVhbVN5bmMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgd2Fsa2VyX2pzXzEuR2xvYlN0cmVhbSh0aGlzLnBhdHRlcm5zLCB0aGlzLnNjdXJyeS5jd2QsIHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgICAgICAgIG1heERlcHRoOiB0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSA/XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCArIHRoaXMuc2N1cnJ5LmN3ZC5kZXB0aCgpXG4gICAgICAgICAgICAgICAgOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jYXNlOiB0aGlzLm5vY2FzZSxcbiAgICAgICAgICAgIGluY2x1ZGVDaGlsZE1hdGNoZXM6IHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyxcbiAgICAgICAgfSkuc3RyZWFtU3luYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN5bmMgaXRlcmF0aW9uIGZ1bmN0aW9uLiBSZXR1cm5zIGEgR2VuZXJhdG9yIHRoYXRcbiAgICAgKiBpdGVyYXRlcyBvdmVyIHRoZSByZXN1bHRzLlxuICAgICAqL1xuICAgIGl0ZXJhdGVTeW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1TeW5jKClbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZVN5bmMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBhc3luYyBpdGVyYXRpb24gZnVuY3Rpb24uIFJldHVybnMgYW4gQXN5bmNHZW5lcmF0b3IgdGhhdFxuICAgICAqIGl0ZXJhdGVzIG92ZXIgdGhlIHJlc3VsdHMuXG4gICAgICovXG4gICAgaXRlcmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtKClbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG59XG5leHBvcnRzLkdsb2IgPSBHbG9iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJHbG9iIiwibWluaW1hdGNoXzEiLCJyZXF1aXJlIiwibm9kZV91cmxfMSIsInBhdGhfc2N1cnJ5XzEiLCJwYXR0ZXJuX2pzXzEiLCJ3YWxrZXJfanNfMSIsImRlZmF1bHRQbGF0Zm9ybSIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImNvbnN0cnVjdG9yIiwicGF0dGVybiIsIm9wdHMiLCJUeXBlRXJyb3IiLCJ3aXRoRmlsZVR5cGVzIiwic2lnbmFsIiwiZm9sbG93IiwiZG90IiwiZG90UmVsYXRpdmUiLCJub2RpciIsIm1hcmsiLCJjd2QiLCJVUkwiLCJzdGFydHNXaXRoIiwiZmlsZVVSTFRvUGF0aCIsInJvb3QiLCJtYWdpY2FsQnJhY2VzIiwibm9icmFjZSIsIm5vZXh0IiwicmVhbHBhdGgiLCJhYnNvbHV0ZSIsImluY2x1ZGVDaGlsZE1hdGNoZXMiLCJub2dsb2JzdGFyIiwibWF0Y2hCYXNlIiwibWF4RGVwdGgiLCJJbmZpbml0eSIsInN0YXQiLCJpZ25vcmUiLCJ1bmRlZmluZWQiLCJFcnJvciIsIndpbmRvd3NQYXRoc05vRXNjYXBlIiwiYWxsb3dXaW5kb3dzRXNjYXBlIiwibWFwIiwicCIsInJlcGxhY2UiLCJpbmNsdWRlcyIsInNjdXJyeSIsIm5vY2FzZSIsIlNjdXJyeSIsIlBhdGhTY3VycnlXaW4zMiIsIlBhdGhTY3VycnlEYXJ3aW4iLCJQYXRoU2N1cnJ5UG9zaXgiLCJQYXRoU2N1cnJ5IiwiZnMiLCJub2Nhc2VNYWdpY09ubHkiLCJtbW8iLCJub2NvbW1lbnQiLCJub25lZ2F0ZSIsIm9wdGltaXphdGlvbkxldmVsIiwiZGVidWciLCJtbXMiLCJNaW5pbWF0Y2giLCJtYXRjaFNldCIsImdsb2JQYXJ0cyIsInJlZHVjZSIsInNldCIsIm0iLCJwdXNoIiwicGF0dGVybnMiLCJpIiwiZyIsIlBhdHRlcm4iLCJ3YWxrIiwiR2xvYldhbGtlciIsImRlcHRoIiwid2Fsa1N5bmMiLCJzdHJlYW0iLCJHbG9iU3RyZWFtIiwic3RyZWFtU3luYyIsIml0ZXJhdGVTeW5jIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpdGVyYXRlIiwiYXN5bmNJdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/glob.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/has-magic.js":
/*!******************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/has-magic.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hasMagic = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\");\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */ const hasMagic = (pattern, options = {})=>{\n    if (!Array.isArray(pattern)) {\n        pattern = [\n            pattern\n        ];\n    }\n    for (const p of pattern){\n        if (new minimatch_1.Minimatch(p, options).hasMagic()) return true;\n    }\n    return false;\n};\nexports.hasMagic = hasMagic; //# sourceMappingURL=has-magic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2hhcy1tYWdpYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQywwRkFBVztBQUN2Qzs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTUYsV0FBVyxDQUFDRyxTQUFTQyxVQUFVLENBQUMsQ0FBQztJQUNuQyxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0gsVUFBVTtRQUN6QkEsVUFBVTtZQUFDQTtTQUFRO0lBQ3ZCO0lBQ0EsS0FBSyxNQUFNSSxLQUFLSixRQUFTO1FBQ3JCLElBQUksSUFBSUYsWUFBWU8sU0FBUyxDQUFDRCxHQUFHSCxTQUFTSixRQUFRLElBQzlDLE9BQU87SUFDZjtJQUNBLE9BQU87QUFDWDtBQUNBRixnQkFBZ0IsR0FBR0UsVUFDbkIscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGhvdG8tc2t1LXByb2Nlc3Nvci8uL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvaGFzLW1hZ2ljLmpzPzAyODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc01hZ2ljID0gdm9pZCAwO1xuY29uc3QgbWluaW1hdGNoXzEgPSByZXF1aXJlKFwibWluaW1hdGNoXCIpO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcGF0dGVybnMgcHJvdmlkZWQgY29udGFpbiBhbnkgbWFnaWMgZ2xvYiBjaGFyYWN0ZXJzLFxuICogZ2l2ZW4gdGhlIG9wdGlvbnMgcHJvdmlkZWQuXG4gKlxuICogQnJhY2UgZXhwYW5zaW9uIGlzIG5vdCBjb25zaWRlcmVkIFwibWFnaWNcIiB1bmxlc3MgdGhlIGBtYWdpY2FsQnJhY2VzYCBvcHRpb25cbiAqIGlzIHNldCwgYXMgYnJhY2UgZXhwYW5zaW9uIGp1c3QgdHVybnMgb25lIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBTbyBhIHBhdHRlcm4gbGlrZSBgJ3h7YSxifXknYCB3b3VsZCByZXR1cm4gYGZhbHNlYCwgYmVjYXVzZSBgJ3hheSdgIGFuZFxuICogYCd4YnknYCBib3RoIGRvIG5vdCBjb250YWluIGFueSBtYWdpYyBnbG9iIGNoYXJhY3RlcnMsIGFuZCBpdCdzIHRyZWF0ZWQgdGhlXG4gKiBzYW1lIGFzIGlmIHlvdSBoYWQgY2FsbGVkIGl0IG9uIGBbJ3hheScsICd4YnknXWAuIFdoZW4gYG1hZ2ljYWxCcmFjZXM6dHJ1ZWBcbiAqIGlzIGluIHRoZSBvcHRpb25zLCBicmFjZSBleHBhbnNpb24gX2lzXyB0cmVhdGVkIGFzIGEgcGF0dGVybiBoYXZpbmcgbWFnaWMuXG4gKi9cbmNvbnN0IGhhc01hZ2ljID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICBwYXR0ZXJuID0gW3BhdHRlcm5dO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHAgb2YgcGF0dGVybikge1xuICAgICAgICBpZiAobmV3IG1pbmltYXRjaF8xLk1pbmltYXRjaChwLCBvcHRpb25zKS5oYXNNYWdpYygpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLmhhc01hZ2ljID0gaGFzTWFnaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtbWFnaWMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFzTWFnaWMiLCJtaW5pbWF0Y2hfMSIsInJlcXVpcmUiLCJwYXR0ZXJuIiwib3B0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsInAiLCJNaW5pbWF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/has-magic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/ignore.js":
/*!***************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/ignore.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Ignore = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\");\nconst pattern_js_1 = __webpack_require__(/*! ./pattern.js */ \"(rsc)/./node_modules/glob/dist/commonjs/pattern.js\");\nconst defaultPlatform = typeof process === \"object\" && process && typeof process.platform === \"string\" ? process.platform : \"linux\";\n/**\n * Class used to process ignored patterns\n */ class Ignore {\n    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }){\n        this.relative = [];\n        this.absolute = [];\n        this.relativeChildren = [];\n        this.absoluteChildren = [];\n        this.platform = platform;\n        this.mmopts = {\n            dot: true,\n            nobrace,\n            nocase,\n            noext,\n            noglobstar,\n            optimizationLevel: 2,\n            platform,\n            nocomment: true,\n            nonegate: true\n        };\n        for (const ign of ignored)this.add(ign);\n    }\n    add(ign) {\n        // this is a little weird, but it gives us a clean set of optimized\n        // minimatch matchers, without getting tripped up if one of them\n        // ends in /** inside a brace section, and it's only inefficient at\n        // the start of the walk, not along it.\n        // It'd be nice if the Pattern class just had a .test() method, but\n        // handling globstars is a bit of a pita, and that code already lives\n        // in minimatch anyway.\n        // Another way would be if maybe Minimatch could take its set/globParts\n        // as an option, and then we could at least just use Pattern to test\n        // for absolute-ness.\n        // Yet another way, Minimatch could take an array of glob strings, and\n        // a cwd option, and do the right thing.\n        const mm = new minimatch_1.Minimatch(ign, this.mmopts);\n        for(let i = 0; i < mm.set.length; i++){\n            const parsed = mm.set[i];\n            const globParts = mm.globParts[i];\n            /* c8 ignore start */ if (!parsed || !globParts) {\n                throw new Error(\"invalid pattern object\");\n            }\n            // strip off leading ./ portions\n            // https://github.com/isaacs/node-glob/issues/570\n            while(parsed[0] === \".\" && globParts[0] === \".\"){\n                parsed.shift();\n                globParts.shift();\n            }\n            /* c8 ignore stop */ const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);\n            const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);\n            const children = globParts[globParts.length - 1] === \"**\";\n            const absolute = p.isAbsolute();\n            if (absolute) this.absolute.push(m);\n            else this.relative.push(m);\n            if (children) {\n                if (absolute) this.absoluteChildren.push(m);\n                else this.relativeChildren.push(m);\n            }\n        }\n    }\n    ignored(p) {\n        const fullpath = p.fullpath();\n        const fullpaths = `${fullpath}/`;\n        const relative = p.relative() || \".\";\n        const relatives = `${relative}/`;\n        for (const m of this.relative){\n            if (m.match(relative) || m.match(relatives)) return true;\n        }\n        for (const m of this.absolute){\n            if (m.match(fullpath) || m.match(fullpaths)) return true;\n        }\n        return false;\n    }\n    childrenIgnored(p) {\n        const fullpath = p.fullpath() + \"/\";\n        const relative = (p.relative() || \".\") + \"/\";\n        for (const m of this.relativeChildren){\n            if (m.match(relative)) return true;\n        }\n        for (const m of this.absoluteChildren){\n            if (m.match(fullpath)) return true;\n        }\n        return false;\n    }\n}\nexports.Ignore = Ignore; //# sourceMappingURL=ignore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2lnbm9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNEQUFzRDtBQUN0RCxrQ0FBa0M7QUFDbEMsa0VBQWtFO0FBQ2xFLDZDQUE2QztBQUM3Q0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLE1BQU1HLGNBQWNDLG1CQUFPQSxDQUFDLDBGQUFXO0FBQ3ZDLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLHdFQUFjO0FBQzNDLE1BQU1FLGtCQUFrQixPQUFRQyxZQUFZLFlBQ3hDQSxXQUNBLE9BQU9BLFFBQVFDLFFBQVEsS0FBSyxXQUM1QkQsUUFBUUMsUUFBUSxHQUNkO0FBQ047O0NBRUMsR0FDRCxNQUFNTjtJQU9GTyxZQUFZQyxPQUFPLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFTixXQUFXRixlQUFlLEVBQUcsQ0FBRTtRQUN0RixJQUFJLENBQUNTLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxFQUFFO1FBQzFCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsRUFBRTtRQUMxQixJQUFJLENBQUNWLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDVyxNQUFNLEdBQUc7WUFDVkMsS0FBSztZQUNMVDtZQUNBQztZQUNBQztZQUNBQztZQUNBTyxtQkFBbUI7WUFDbkJiO1lBQ0FjLFdBQVc7WUFDWEMsVUFBVTtRQUNkO1FBQ0EsS0FBSyxNQUFNQyxPQUFPZCxRQUNkLElBQUksQ0FBQ2UsR0FBRyxDQUFDRDtJQUNqQjtJQUNBQyxJQUFJRCxHQUFHLEVBQUU7UUFDTCxtRUFBbUU7UUFDbkUsZ0VBQWdFO1FBQ2hFLG1FQUFtRTtRQUNuRSx1Q0FBdUM7UUFDdkMsbUVBQW1FO1FBQ25FLHFFQUFxRTtR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b21tb25qcy9pZ25vcmUuanM/ZGNhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIGdpdmUgaXQgYSBwYXR0ZXJuLCBhbmQgaXQnbGwgYmUgYWJsZSB0byB0ZWxsIHlvdSBpZlxuLy8gYSBnaXZlbiBwYXRoIHNob3VsZCBiZSBpZ25vcmVkLlxuLy8gSWdub3JpbmcgYSBwYXRoIGlnbm9yZXMgaXRzIGNoaWxkcmVuIGlmIHRoZSBwYXR0ZXJuIGVuZHMgaW4gLyoqXG4vLyBJZ25vcmVzIGFyZSBhbHdheXMgcGFyc2VkIGluIGRvdDp0cnVlIG1vZGVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWdub3JlID0gdm9pZCAwO1xuY29uc3QgbWluaW1hdGNoXzEgPSByZXF1aXJlKFwibWluaW1hdGNoXCIpO1xuY29uc3QgcGF0dGVybl9qc18xID0gcmVxdWlyZShcIi4vcGF0dGVybi5qc1wiKTtcbmNvbnN0IGRlZmF1bHRQbGF0Zm9ybSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgICBwcm9jZXNzICYmXG4gICAgdHlwZW9mIHByb2Nlc3MucGxhdGZvcm0gPT09ICdzdHJpbmcnKSA/XG4gICAgcHJvY2Vzcy5wbGF0Zm9ybVxuICAgIDogJ2xpbnV4Jztcbi8qKlxuICogQ2xhc3MgdXNlZCB0byBwcm9jZXNzIGlnbm9yZWQgcGF0dGVybnNcbiAqL1xuY2xhc3MgSWdub3JlIHtcbiAgICByZWxhdGl2ZTtcbiAgICByZWxhdGl2ZUNoaWxkcmVuO1xuICAgIGFic29sdXRlO1xuICAgIGFic29sdXRlQ2hpbGRyZW47XG4gICAgcGxhdGZvcm07XG4gICAgbW1vcHRzO1xuICAgIGNvbnN0cnVjdG9yKGlnbm9yZWQsIHsgbm9icmFjZSwgbm9jYXNlLCBub2V4dCwgbm9nbG9ic3RhciwgcGxhdGZvcm0gPSBkZWZhdWx0UGxhdGZvcm0sIH0pIHtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLmFic29sdXRlID0gW107XG4gICAgICAgIHRoaXMucmVsYXRpdmVDaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmFic29sdXRlQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgICAgICB0aGlzLm1tb3B0cyA9IHtcbiAgICAgICAgICAgIGRvdDogdHJ1ZSxcbiAgICAgICAgICAgIG5vYnJhY2UsXG4gICAgICAgICAgICBub2Nhc2UsXG4gICAgICAgICAgICBub2V4dCxcbiAgICAgICAgICAgIG5vZ2xvYnN0YXIsXG4gICAgICAgICAgICBvcHRpbWl6YXRpb25MZXZlbDogMixcbiAgICAgICAgICAgIHBsYXRmb3JtLFxuICAgICAgICAgICAgbm9jb21tZW50OiB0cnVlLFxuICAgICAgICAgICAgbm9uZWdhdGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgaWduIG9mIGlnbm9yZWQpXG4gICAgICAgICAgICB0aGlzLmFkZChpZ24pO1xuICAgIH1cbiAgICBhZGQoaWduKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBsaXR0bGUgd2VpcmQsIGJ1dCBpdCBnaXZlcyB1cyBhIGNsZWFuIHNldCBvZiBvcHRpbWl6ZWRcbiAgICAgICAgLy8gbWluaW1hdGNoIG1hdGNoZXJzLCB3aXRob3V0IGdldHRpbmcgdHJpcHBlZCB1cCBpZiBvbmUgb2YgdGhlbVxuICAgICAgICAvLyBlbmRzIGluIC8qKiBpbnNpZGUgYSBicmFjZSBzZWN0aW9uLCBhbmQgaXQncyBvbmx5IGluZWZmaWNpZW50IGF0XG4gICAgICAgIC8vIHRoZSBzdGFydCBvZiB0aGUgd2Fsaywgbm90IGFsb25nIGl0LlxuICAgICAgICAvLyBJdCdkIGJlIG5pY2UgaWYgdGhlIFBhdHRlcm4gY2xhc3MganVzdCBoYWQgYSAudGVzdCgpIG1ldGhvZCwgYnV0XG4gICAgICAgIC8vIGhhbmRsaW5nIGdsb2JzdGFycyBpcyBhIGJpdCBvZiBhIHBpdGEsIGFuZCB0aGF0IGNvZGUgYWxyZWFkeSBsaXZlc1xuICAgICAgICAvLyBpbiBtaW5pbWF0Y2ggYW55d2F5LlxuICAgICAgICAvLyBBbm90aGVyIHdheSB3b3VsZCBiZSBpZiBtYXliZSBNaW5pbWF0Y2ggY291bGQgdGFrZSBpdHMgc2V0L2dsb2JQYXJ0c1xuICAgICAgICAvLyBhcyBhbiBvcHRpb24sIGFuZCB0aGVuIHdlIGNvdWxkIGF0IGxlYXN0IGp1c3QgdXNlIFBhdHRlcm4gdG8gdGVzdFxuICAgICAgICAvLyBmb3IgYWJzb2x1dGUtbmVzcy5cbiAgICAgICAgLy8gWWV0IGFub3RoZXIgd2F5LCBNaW5pbWF0Y2ggY291bGQgdGFrZSBhbiBhcnJheSBvZiBnbG9iIHN0cmluZ3MsIGFuZFxuICAgICAgICAvLyBhIGN3ZCBvcHRpb24sIGFuZCBkbyB0aGUgcmlnaHQgdGhpbmcuXG4gICAgICAgIGNvbnN0IG1tID0gbmV3IG1pbmltYXRjaF8xLk1pbmltYXRjaChpZ24sIHRoaXMubW1vcHRzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtbS5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG1tLnNldFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JQYXJ0cyA9IG1tLmdsb2JQYXJ0c1tpXTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKCFwYXJzZWQgfHwgIWdsb2JQYXJ0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYXR0ZXJuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3RyaXAgb2ZmIGxlYWRpbmcgLi8gcG9ydGlvbnNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy81NzBcbiAgICAgICAgICAgIHdoaWxlIChwYXJzZWRbMF0gPT09ICcuJyAmJiBnbG9iUGFydHNbMF0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGdsb2JQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgcGF0dGVybl9qc18xLlBhdHRlcm4ocGFyc2VkLCBnbG9iUGFydHMsIDAsIHRoaXMucGxhdGZvcm0pO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBtaW5pbWF0Y2hfMS5NaW5pbWF0Y2gocC5nbG9iU3RyaW5nKCksIHRoaXMubW1vcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2xvYlBhcnRzW2dsb2JQYXJ0cy5sZW5ndGggLSAxXSA9PT0gJyoqJztcbiAgICAgICAgICAgIGNvbnN0IGFic29sdXRlID0gcC5pc0Fic29sdXRlKCk7XG4gICAgICAgICAgICBpZiAoYWJzb2x1dGUpXG4gICAgICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZS5wdXNoKG0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmUucHVzaChtKTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChhYnNvbHV0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hYnNvbHV0ZUNoaWxkcmVuLnB1c2gobSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlQ2hpbGRyZW4ucHVzaChtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVkKHApIHtcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSBwLmZ1bGxwYXRoKCk7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRocyA9IGAke2Z1bGxwYXRofS9gO1xuICAgICAgICBjb25zdCByZWxhdGl2ZSA9IHAucmVsYXRpdmUoKSB8fCAnLic7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlcyA9IGAke3JlbGF0aXZlfS9gO1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2gocmVsYXRpdmUpIHx8IG0ubWF0Y2gocmVsYXRpdmVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5hYnNvbHV0ZSkge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2goZnVsbHBhdGgpIHx8IG0ubWF0Y2goZnVsbHBhdGhzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoaWxkcmVuSWdub3JlZChwKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gcC5mdWxscGF0aCgpICsgJy8nO1xuICAgICAgICBjb25zdCByZWxhdGl2ZSA9IChwLnJlbGF0aXZlKCkgfHwgJy4nKSArICcvJztcbiAgICAgICAgZm9yIChjb25zdCBtIG9mIHRoaXMucmVsYXRpdmVDaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG0ubWF0Y2gocmVsYXRpdmUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLmFic29sdXRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChtLm1hdGNoKGZ1bGxwYXRoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5JZ25vcmUgPSBJZ25vcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZ25vcmUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSWdub3JlIiwibWluaW1hdGNoXzEiLCJyZXF1aXJlIiwicGF0dGVybl9qc18xIiwiZGVmYXVsdFBsYXRmb3JtIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiY29uc3RydWN0b3IiLCJpZ25vcmVkIiwibm9icmFjZSIsIm5vY2FzZSIsIm5vZXh0Iiwibm9nbG9ic3RhciIsInJlbGF0aXZlIiwiYWJzb2x1dGUiLCJyZWxhdGl2ZUNoaWxkcmVuIiwiYWJzb2x1dGVDaGlsZHJlbiIsIm1tb3B0cyIsImRvdCIsIm9wdGltaXphdGlvbkxldmVsIiwibm9jb21tZW50Iiwibm9uZWdhdGUiLCJpZ24iLCJhZGQiLCJtbSIsIk1pbmltYXRjaCIsImkiLCJzZXQiLCJsZW5ndGgiLCJwYXJzZWQiLCJnbG9iUGFydHMiLCJFcnJvciIsInNoaWZ0IiwicCIsIlBhdHRlcm4iLCJtIiwiZ2xvYlN0cmluZyIsImNoaWxkcmVuIiwiaXNBYnNvbHV0ZSIsInB1c2giLCJmdWxscGF0aCIsImZ1bGxwYXRocyIsInJlbGF0aXZlcyIsIm1hdGNoIiwiY2hpbGRyZW5JZ25vcmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/ignore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = void 0;\nexports.globStreamSync = globStreamSync;\nexports.globStream = globStream;\nexports.globSync = globSync;\nexports.globIterateSync = globIterateSync;\nexports.globIterate = globIterate;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\");\nconst glob_js_1 = __webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/glob/dist/commonjs/glob.js\");\nconst has_magic_js_1 = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/./node_modules/glob/dist/commonjs/has-magic.js\");\nvar minimatch_2 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\");\nObject.defineProperty(exports, \"escape\", ({\n    enumerable: true,\n    get: function() {\n        return minimatch_2.escape;\n    }\n}));\nObject.defineProperty(exports, \"unescape\", ({\n    enumerable: true,\n    get: function() {\n        return minimatch_2.unescape;\n    }\n}));\nvar glob_js_2 = __webpack_require__(/*! ./glob.js */ \"(rsc)/./node_modules/glob/dist/commonjs/glob.js\");\nObject.defineProperty(exports, \"Glob\", ({\n    enumerable: true,\n    get: function() {\n        return glob_js_2.Glob;\n    }\n}));\nvar has_magic_js_2 = __webpack_require__(/*! ./has-magic.js */ \"(rsc)/./node_modules/glob/dist/commonjs/has-magic.js\");\nObject.defineProperty(exports, \"hasMagic\", ({\n    enumerable: true,\n    get: function() {\n        return has_magic_js_2.hasMagic;\n    }\n}));\nvar ignore_js_1 = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/commonjs/ignore.js\");\nObject.defineProperty(exports, \"Ignore\", ({\n    enumerable: true,\n    get: function() {\n        return ignore_js_1.Ignore;\n    }\n}));\nfunction globStreamSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).streamSync();\n}\nfunction globStream(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).stream();\n}\nfunction globSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).walkSync();\n}\nasync function glob_(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).walk();\n}\nfunction globIterateSync(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).iterateSync();\n}\nfunction globIterate(pattern, options = {}) {\n    return new glob_js_1.Glob(pattern, options).iterate();\n}\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexports.streamSync = globStreamSync;\nexports.stream = Object.assign(globStream, {\n    sync: globStreamSync\n});\nexports.iterateSync = globIterateSync;\nexports.iterate = Object.assign(globIterate, {\n    sync: globIterateSync\n});\nexports.sync = Object.assign(globSync, {\n    stream: globStreamSync,\n    iterate: globIterateSync\n});\nexports.glob = Object.assign(glob_, {\n    glob: glob_,\n    globSync,\n    sync: exports.sync,\n    globStream,\n    stream: exports.stream,\n    globStreamSync,\n    streamSync: exports.streamSync,\n    globIterate,\n    iterate: exports.iterate,\n    globIterateSync,\n    iterateSync: exports.iterateSync,\n    Glob: glob_js_1.Glob,\n    hasMagic: has_magic_js_1.hasMagic,\n    escape: minimatch_1.escape,\n    unescape: minimatch_1.unescape\n});\nexports.glob.glob = exports.glob; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxZQUFZLEdBQUdBLFlBQVksR0FBR0EsZUFBZSxHQUFHQSxtQkFBbUIsR0FBR0EsY0FBYyxHQUFHQSxrQkFBa0IsR0FBR0EsY0FBYyxHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHQSxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDeE1BLHNCQUFzQixHQUFHYTtBQUN6QmIsa0JBQWtCLEdBQUdjO0FBQ3JCZCxnQkFBZ0IsR0FBR2U7QUFDbkJmLHVCQUF1QixHQUFHZ0I7QUFDMUJoQixtQkFBbUIsR0FBR2lCO0FBQ3RCLE1BQU1DLGNBQWNDLG1CQUFPQSxDQUFDLDBGQUFXO0FBQ3ZDLE1BQU1DLFlBQVlELG1CQUFPQSxDQUFDLGtFQUFXO0FBQ3JDLE1BQU1FLGlCQUFpQkYsbUJBQU9BLENBQUMsNEVBQWdCO0FBQy9DLElBQUlHLGNBQWNILG1CQUFPQSxDQUFDLDBGQUFXO0FBQ3JDckIsMENBQXlDO0lBQUV5QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixZQUFZVixNQUFNO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDL0dkLDRDQUEyQztJQUFFeUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsWUFBWVgsUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ25ILElBQUljLFlBQVlOLG1CQUFPQSxDQUFDLGtFQUFXO0FBQ25DckIsd0NBQXVDO0lBQUV5QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxVQUFVZixJQUFJO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDekcsSUFBSWdCLGlCQUFpQlAsbUJBQU9BLENBQUMsNEVBQWdCO0FBQzdDckIsNENBQTJDO0lBQUV5QixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxlQUFlakIsUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3RILElBQUlrQixjQUFjUixtQkFBT0EsQ0FBQyxzRUFBYTtBQUN2Q3JCLDBDQUF5QztJQUFFeUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csWUFBWW5CLE1BQU07SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvRyxTQUFTSyxlQUFlZSxPQUFPLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLE9BQU8sSUFBSVQsVUFBVVYsSUFBSSxDQUFDa0IsU0FBU0MsU0FBU3RCLFVBQVU7QUFDMUQ7QUFDQSxTQUFTTyxXQUFXYyxPQUFPLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ3JDLE9BQU8sSUFBSVQsVUFBVVYsSUFBSSxDQUFDa0IsU0FBU0MsU0FBU3ZCLE1BQU07QUFDdEQ7QUFDQSxTQUFTUyxTQUFTYSxPQUFPLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLE9BQU8sSUFBSVQsVUFBVVYsSUFBSSxDQUFDa0IsU0FBU0MsU0FBU0MsUUFBUTtBQUN4RDtBQUNBLGVBQWVDLE1BQU1ILE9BQU8sRUFBRUMsVUFBVSxDQUFDLENBQUM7SUFDdEMsT0FBTyxJQUFJVCxVQUFVVixJQUFJLENBQUNrQixTQUFTQyxTQUFTRyxJQUFJO0FBQ3BEO0FBQ0EsU0FBU2hCLGdCQUFnQlksT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUMxQyxPQUFPLElBQUlULFVBQVVWLElBQUksQ0FBQ2tCLFNBQVNDLFNBQVN4QixXQUFXO0FBQzNEO0FBQ0EsU0FBU1ksWUFBWVcsT0FBTyxFQUFFQyxVQUFVLENBQUMsQ0FBQztJQUN0QyxPQUFPLElBQUlULFVBQVVWLElBQUksQ0FBQ2tCLFNBQVNDLFNBQVN6QixPQUFPO0FBQ3ZEO0FBQ0EsaUVBQWlFO0FBQ2pFSixrQkFBa0IsR0FBR2E7QUFDckJiLGNBQWMsR0FBR0YsT0FBT21DLE1BQU0sQ0FBQ25CLFlBQVk7SUFBRVgsTUFBTVU7QUFBZTtBQUNsRWIsbUJBQW1CLEdBQUdnQjtBQUN0QmhCLGVBQWUsR0FBR0YsT0FBT21DLE1BQU0sQ0FBQ2hCLGFBQWE7SUFDekNkLE1BQU1hO0FBQ1Y7QUFDQWhCLFlBQVksR0FBR0YsT0FBT21DLE1BQU0sQ0FBQ2xCLFVBQVU7SUFDbkNULFFBQVFPO0lBQ1JULFNBQVNZO0FBQ2I7QUFDQWhCLFlBQVksR0FBR0YsT0FBT21DLE1BQU0sQ0FBQ0YsT0FBTztJQUNoQzdCLE1BQU02QjtJQUNOaEI7SUFDQVosTUFBTUgsUUFBUUcsSUFBSTtJQUNsQlc7SUFDQVIsUUFBUU4sUUFBUU0sTUFBTTtJQUN0Qk87SUFDQU4sWUFBWVAsUUFBUU8sVUFBVTtJQUM5QlU7SUFDQWIsU0FBU0osUUFBUUksT0FBTztJQUN4Qlk7SUFDQVgsYUFBYUwsUUFBUUssV0FBVztJQUNoQ0ssTUFBTVUsVUFBVVYsSUFBSTtJQUNwQkQsVUFBVVksZUFBZVosUUFBUTtJQUNqQ0csUUFBUU0sWUFBWU4sTUFBTTtJQUMxQkQsVUFBVU8sWUFBWVAsUUFBUTtBQUNsQztBQUNBWCxpQkFBaUIsR0FBR0EsUUFBUUUsSUFBSSxFQUNoQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9jb21tb25qcy9pbmRleC5qcz9hZDAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nbG9iID0gZXhwb3J0cy5zeW5jID0gZXhwb3J0cy5pdGVyYXRlID0gZXhwb3J0cy5pdGVyYXRlU3luYyA9IGV4cG9ydHMuc3RyZWFtID0gZXhwb3J0cy5zdHJlYW1TeW5jID0gZXhwb3J0cy5JZ25vcmUgPSBleHBvcnRzLmhhc01hZ2ljID0gZXhwb3J0cy5HbG9iID0gZXhwb3J0cy51bmVzY2FwZSA9IGV4cG9ydHMuZXNjYXBlID0gdm9pZCAwO1xuZXhwb3J0cy5nbG9iU3RyZWFtU3luYyA9IGdsb2JTdHJlYW1TeW5jO1xuZXhwb3J0cy5nbG9iU3RyZWFtID0gZ2xvYlN0cmVhbTtcbmV4cG9ydHMuZ2xvYlN5bmMgPSBnbG9iU3luYztcbmV4cG9ydHMuZ2xvYkl0ZXJhdGVTeW5jID0gZ2xvYkl0ZXJhdGVTeW5jO1xuZXhwb3J0cy5nbG9iSXRlcmF0ZSA9IGdsb2JJdGVyYXRlO1xuY29uc3QgbWluaW1hdGNoXzEgPSByZXF1aXJlKFwibWluaW1hdGNoXCIpO1xuY29uc3QgZ2xvYl9qc18xID0gcmVxdWlyZShcIi4vZ2xvYi5qc1wiKTtcbmNvbnN0IGhhc19tYWdpY19qc18xID0gcmVxdWlyZShcIi4vaGFzLW1hZ2ljLmpzXCIpO1xudmFyIG1pbmltYXRjaF8yID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWluaW1hdGNoXzIuZXNjYXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5lc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pbmltYXRjaF8yLnVuZXNjYXBlOyB9IH0pO1xudmFyIGdsb2JfanNfMiA9IHJlcXVpcmUoXCIuL2dsb2IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnbG9iX2pzXzIuR2xvYjsgfSB9KTtcbnZhciBoYXNfbWFnaWNfanNfMiA9IHJlcXVpcmUoXCIuL2hhcy1tYWdpYy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc01hZ2ljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNfbWFnaWNfanNfMi5oYXNNYWdpYzsgfSB9KTtcbnZhciBpZ25vcmVfanNfMSA9IHJlcXVpcmUoXCIuL2lnbm9yZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklnbm9yZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWdub3JlX2pzXzEuSWdub3JlOyB9IH0pO1xuZnVuY3Rpb24gZ2xvYlN0cmVhbVN5bmMocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBnbG9iX2pzXzEuR2xvYihwYXR0ZXJuLCBvcHRpb25zKS5zdHJlYW1TeW5jKCk7XG59XG5mdW5jdGlvbiBnbG9iU3RyZWFtKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgZ2xvYl9qc18xLkdsb2IocGF0dGVybiwgb3B0aW9ucykuc3RyZWFtKCk7XG59XG5mdW5jdGlvbiBnbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLndhbGtTeW5jKCk7XG59XG5hc3luYyBmdW5jdGlvbiBnbG9iXyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLndhbGsoKTtcbn1cbmZ1bmN0aW9uIGdsb2JJdGVyYXRlU3luYyhwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLml0ZXJhdGVTeW5jKCk7XG59XG5mdW5jdGlvbiBnbG9iSXRlcmF0ZShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGdsb2JfanNfMS5HbG9iKHBhdHRlcm4sIG9wdGlvbnMpLml0ZXJhdGUoKTtcbn1cbi8vIGFsaWFzZXM6IGdsb2Iuc3luYy5zdHJlYW0oKSBnbG9iLnN0cmVhbS5zeW5jKCkgZ2xvYi5zeW5jKCkgZXRjXG5leHBvcnRzLnN0cmVhbVN5bmMgPSBnbG9iU3RyZWFtU3luYztcbmV4cG9ydHMuc3RyZWFtID0gT2JqZWN0LmFzc2lnbihnbG9iU3RyZWFtLCB7IHN5bmM6IGdsb2JTdHJlYW1TeW5jIH0pO1xuZXhwb3J0cy5pdGVyYXRlU3luYyA9IGdsb2JJdGVyYXRlU3luYztcbmV4cG9ydHMuaXRlcmF0ZSA9IE9iamVjdC5hc3NpZ24oZ2xvYkl0ZXJhdGUsIHtcbiAgICBzeW5jOiBnbG9iSXRlcmF0ZVN5bmMsXG59KTtcbmV4cG9ydHMuc3luYyA9IE9iamVjdC5hc3NpZ24oZ2xvYlN5bmMsIHtcbiAgICBzdHJlYW06IGdsb2JTdHJlYW1TeW5jLFxuICAgIGl0ZXJhdGU6IGdsb2JJdGVyYXRlU3luYyxcbn0pO1xuZXhwb3J0cy5nbG9iID0gT2JqZWN0LmFzc2lnbihnbG9iXywge1xuICAgIGdsb2I6IGdsb2JfLFxuICAgIGdsb2JTeW5jLFxuICAgIHN5bmM6IGV4cG9ydHMuc3luYyxcbiAgICBnbG9iU3RyZWFtLFxuICAgIHN0cmVhbTogZXhwb3J0cy5zdHJlYW0sXG4gICAgZ2xvYlN0cmVhbVN5bmMsXG4gICAgc3RyZWFtU3luYzogZXhwb3J0cy5zdHJlYW1TeW5jLFxuICAgIGdsb2JJdGVyYXRlLFxuICAgIGl0ZXJhdGU6IGV4cG9ydHMuaXRlcmF0ZSxcbiAgICBnbG9iSXRlcmF0ZVN5bmMsXG4gICAgaXRlcmF0ZVN5bmM6IGV4cG9ydHMuaXRlcmF0ZVN5bmMsXG4gICAgR2xvYjogZ2xvYl9qc18xLkdsb2IsXG4gICAgaGFzTWFnaWM6IGhhc19tYWdpY19qc18xLmhhc01hZ2ljLFxuICAgIGVzY2FwZTogbWluaW1hdGNoXzEuZXNjYXBlLFxuICAgIHVuZXNjYXBlOiBtaW5pbWF0Y2hfMS51bmVzY2FwZSxcbn0pO1xuZXhwb3J0cy5nbG9iLmdsb2IgPSBleHBvcnRzLmdsb2I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnbG9iIiwic3luYyIsIml0ZXJhdGUiLCJpdGVyYXRlU3luYyIsInN0cmVhbSIsInN0cmVhbVN5bmMiLCJJZ25vcmUiLCJoYXNNYWdpYyIsIkdsb2IiLCJ1bmVzY2FwZSIsImVzY2FwZSIsImdsb2JTdHJlYW1TeW5jIiwiZ2xvYlN0cmVhbSIsImdsb2JTeW5jIiwiZ2xvYkl0ZXJhdGVTeW5jIiwiZ2xvYkl0ZXJhdGUiLCJtaW5pbWF0Y2hfMSIsInJlcXVpcmUiLCJnbG9iX2pzXzEiLCJoYXNfbWFnaWNfanNfMSIsIm1pbmltYXRjaF8yIiwiZW51bWVyYWJsZSIsImdldCIsImdsb2JfanNfMiIsImhhc19tYWdpY19qc18yIiwiaWdub3JlX2pzXzEiLCJwYXR0ZXJuIiwib3B0aW9ucyIsIndhbGtTeW5jIiwiZ2xvYl8iLCJ3YWxrIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/pattern.js":
/*!****************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/pattern.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// this is just a very light wrapper around 2 arrays with an offset index\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Pattern = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\");\nconst isPatternList = (pl)=>pl.length >= 1;\nconst isGlobList = (gl)=>gl.length >= 1;\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */ class Pattern {\n    #patternList;\n    #globList;\n    #index;\n    #platform;\n    #rest;\n    #globString;\n    #isDrive;\n    #isUNC;\n    #isAbsolute;\n    #followGlobstar;\n    constructor(patternList, globList, index, platform){\n        this.#followGlobstar = true;\n        if (!isPatternList(patternList)) {\n            throw new TypeError(\"empty pattern list\");\n        }\n        if (!isGlobList(globList)) {\n            throw new TypeError(\"empty glob list\");\n        }\n        if (globList.length !== patternList.length) {\n            throw new TypeError(\"mismatched pattern list and glob list lengths\");\n        }\n        this.length = patternList.length;\n        if (index < 0 || index >= this.length) {\n            throw new TypeError(\"index out of range\");\n        }\n        this.#patternList = patternList;\n        this.#globList = globList;\n        this.#index = index;\n        this.#platform = platform;\n        // normalize root entries of absolute patterns on initial creation.\n        if (this.#index === 0) {\n            // c: => ['c:/']\n            // C:/ => ['C:/']\n            // C:/x => ['C:/', 'x']\n            // //host/share => ['//host/share/']\n            // //host/share/ => ['//host/share/']\n            // //host/share/x => ['//host/share/', 'x']\n            // /etc => ['/', 'etc']\n            // / => ['/']\n            if (this.isUNC()) {\n                // '' / '' / 'host' / 'share'\n                const [p0, p1, p2, p3, ...prest] = this.#patternList;\n                const [g0, g1, g2, g3, ...grest] = this.#globList;\n                if (prest[0] === \"\") {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = [\n                    p0,\n                    p1,\n                    p2,\n                    p3,\n                    \"\"\n                ].join(\"/\");\n                const g = [\n                    g0,\n                    g1,\n                    g2,\n                    g3,\n                    \"\"\n                ].join(\"/\");\n                this.#patternList = [\n                    p,\n                    ...prest\n                ];\n                this.#globList = [\n                    g,\n                    ...grest\n                ];\n                this.length = this.#patternList.length;\n            } else if (this.isDrive() || this.isAbsolute()) {\n                const [p1, ...prest] = this.#patternList;\n                const [g1, ...grest] = this.#globList;\n                if (prest[0] === \"\") {\n                    // ends in /\n                    prest.shift();\n                    grest.shift();\n                }\n                const p = p1 + \"/\";\n                const g = g1 + \"/\";\n                this.#patternList = [\n                    p,\n                    ...prest\n                ];\n                this.#globList = [\n                    g,\n                    ...grest\n                ];\n                this.length = this.#patternList.length;\n            }\n        }\n    }\n    /**\n     * The first entry in the parsed list of patterns\n     */ pattern() {\n        return this.#patternList[this.#index];\n    }\n    /**\n     * true of if pattern() returns a string\n     */ isString() {\n        return typeof this.#patternList[this.#index] === \"string\";\n    }\n    /**\n     * true of if pattern() returns GLOBSTAR\n     */ isGlobstar() {\n        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;\n    }\n    /**\n     * true if pattern() returns a regexp\n     */ isRegExp() {\n        return this.#patternList[this.#index] instanceof RegExp;\n    }\n    /**\n     * The /-joined set of glob parts that make up this pattern\n     */ globString() {\n        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join(\"/\") : this.#globList.join(\"/\") : this.#globList.slice(this.#index).join(\"/\"));\n    }\n    /**\n     * true if there are more pattern parts after this one\n     */ hasMore() {\n        return this.length > this.#index + 1;\n    }\n    /**\n     * The rest of the pattern after this part, or null if this is the end\n     */ rest() {\n        if (this.#rest !== undefined) return this.#rest;\n        if (!this.hasMore()) return this.#rest = null;\n        this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);\n        this.#rest.#isAbsolute = this.#isAbsolute;\n        this.#rest.#isUNC = this.#isUNC;\n        this.#rest.#isDrive = this.#isDrive;\n        return this.#rest;\n    }\n    /**\n     * true if the pattern represents a //unc/path/ on windows\n     */ isUNC() {\n        const pl = this.#patternList;\n        return this.#isUNC !== undefined ? this.#isUNC : this.#isUNC = this.#platform === \"win32\" && this.#index === 0 && pl[0] === \"\" && pl[1] === \"\" && typeof pl[2] === \"string\" && !!pl[2] && typeof pl[3] === \"string\" && !!pl[3];\n    }\n    // pattern like C:/...\n    // split = ['C:', ...]\n    // XXX: would be nice to handle patterns like `c:*` to test the cwd\n    // in c: for *, but I don't know of a way to even figure out what that\n    // cwd is without actually chdir'ing into it?\n    /**\n     * True if the pattern starts with a drive letter on Windows\n     */ isDrive() {\n        const pl = this.#patternList;\n        return this.#isDrive !== undefined ? this.#isDrive : this.#isDrive = this.#platform === \"win32\" && this.#index === 0 && this.length > 1 && typeof pl[0] === \"string\" && /^[a-z]:$/i.test(pl[0]);\n    }\n    // pattern = '/' or '/...' or '/x/...'\n    // split = ['', ''] or ['', ...] or ['', 'x', ...]\n    // Drive and UNC both considered absolute on windows\n    /**\n     * True if the pattern is rooted on an absolute path\n     */ isAbsolute() {\n        const pl = this.#patternList;\n        return this.#isAbsolute !== undefined ? this.#isAbsolute : this.#isAbsolute = pl[0] === \"\" && pl.length > 1 || this.isDrive() || this.isUNC();\n    }\n    /**\n     * consume the root of the pattern, and return it\n     */ root() {\n        const p = this.#patternList[0];\n        return typeof p === \"string\" && this.isAbsolute() && this.#index === 0 ? p : \"\";\n    }\n    /**\n     * Check to see if the current globstar pattern is allowed to follow\n     * a symbolic link.\n     */ checkFollowGlobstar() {\n        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);\n    }\n    /**\n     * Mark that the current globstar pattern is following a symbolic link\n     */ markFollowGlobstar() {\n        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar) return false;\n        this.#followGlobstar = false;\n        return true;\n    }\n}\nexports.Pattern = Pattern; //# sourceMappingURL=pattern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3BhdHRlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYix5RUFBeUU7QUFDekVBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRyxjQUFjQyxtQkFBT0EsQ0FBQywwRkFBVztBQUN2QyxNQUFNQyxnQkFBZ0IsQ0FBQ0MsS0FBT0EsR0FBR0MsTUFBTSxJQUFJO0FBQzNDLE1BQU1DLGFBQWEsQ0FBQ0MsS0FBT0EsR0FBR0YsTUFBTSxJQUFJO0FBQ3hDOzs7Q0FHQyxHQUNELE1BQU1MO0lBQ0YsQ0FBQ1EsV0FBVyxDQUFDO0lBQ2IsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsQ0FBQ0MsS0FBSyxDQUFDO0lBRVAsQ0FBQ0MsUUFBUSxDQUFDO0lBQ1YsQ0FBQ0MsSUFBSSxDQUFDO0lBQ04sQ0FBQ0MsVUFBVSxDQUFDO0lBQ1osQ0FBQ0MsT0FBTyxDQUFDO0lBQ1QsQ0FBQ0MsS0FBSyxDQUFDO0lBQ1AsQ0FBQ0MsVUFBVSxDQUFDO0lBQ1osQ0FBQ0MsY0FBYyxDQUFRO0lBQ3ZCQyxZQUFZVixXQUFXLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7YUFEcEQsQ0FBQ00sY0FBYyxHQUFHO1FBRWQsSUFBSSxDQUFDZCxjQUFjSyxjQUFjO1lBQzdCLE1BQU0sSUFBSVcsVUFBVTtRQUN4QjtRQUNBLElBQUksQ0FBQ2IsV0FBV0csV0FBVztZQUN2QixNQUFNLElBQUlVLFVBQVU7UUFDeEI7UUFDQSxJQUFJVixTQUFTSixNQUFNLEtBQUtHLFlBQVlILE1BQU0sRUFBRTtZQUN4QyxNQUFNLElBQUljLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUNkLE1BQU0sR0FBR0csWUFBWUgsTUFBTTtRQUNoQyxJQUFJSyxRQUFRLEtBQUtBLFNBQVMsSUFBSSxDQUFDTCxNQUFNLEVBQUU7WUFDbkMsTUFBTSxJQUFJYyxVQUFVO1FBQ3hC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LHNDQUFzQztJQUN0QyxrREFBa0Q7SUFDbEQsb0RBQW9EO0lBQ3BEOztLQUVDLEdBQ0RZLGFBQWE7UUFDVCxNQUFNWixLQUFLLElBQUksQ0FBQyxDQUFDSSxXQUFXO1FBQzVCLE9BQU8sSUFBSSxDQUFDLENBQUNRLFVBQVUsS0FBSzBCLFlBQ3hCLElBQUksQ0FBQyxDQUFDMUIsVUFBVSxHQUNiLElBQUksQ0FBQyxDQUFDQSxVQUFVLEdBQ2YsRUFBRyxDQUFDLEVBQUUsS0FBSyxNQUFNWixHQUFHQyxNQUFNLEdBQUcsS0FDekIsSUFBSSxDQUFDUyxPQUFPLE1BQ1osSUFBSSxDQUFDQyxLQUFLO0lBQzFCO0lBQ0E7O0tBRUMsR0FDRDZCLE9BQU87UUFDSCxNQUFNYixJQUFJLElBQUksQ0FBQyxDQUFDdkIsV0FBVyxDQUFDLEVBQUU7UUFDOUIsT0FBTyxPQUFRdUIsTUFBTSxZQUFZLElBQUksQ0FBQ2YsVUFBVSxNQUFNLElBQUksQ0FBQyxDQUFDTixLQUFLLEtBQUssSUFDbEVxQixJQUNFO0lBQ1Y7SUFDQTs7O0tBR0MsR0FDRGMsc0JBQXNCO1FBQ2xCLE9BQU8sQ0FBRSxLQUFJLENBQUMsQ0FBQ25DLEtBQUssS0FBSyxLQUNyQixDQUFDLElBQUksQ0FBQzBCLFVBQVUsTUFDaEIsQ0FBQyxJQUFJLENBQUMsQ0FBQ25CLGNBQWM7SUFDN0I7SUFDQTs7S0FFQyxHQUNENkIscUJBQXFCO1FBQ2pCLElBQUksSUFBSSxDQUFDLENBQUNwQyxLQUFLLEtBQUssS0FBSyxDQUFDLElBQUksQ0FBQzBCLFVBQVUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDbkIsY0FBYyxFQUNoRSxPQUFPO1FBQ1gsSUFBSSxDQUFDLENBQUNBLGNBQWMsR0FBRztRQUN2QixPQUFPO0lBQ1g7QUFDSjtBQUNBbkIsZUFBZSxHQUFHRSxTQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL2dsb2IvZGlzdC9jb21tb25qcy9wYXR0ZXJuLmpzP2FhMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0aGlzIGlzIGp1c3QgYSB2ZXJ5IGxpZ2h0IHdyYXBwZXIgYXJvdW5kIDIgYXJyYXlzIHdpdGggYW4gb2Zmc2V0IGluZGV4XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdHRlcm4gPSB2b2lkIDA7XG5jb25zdCBtaW5pbWF0Y2hfMSA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIik7XG5jb25zdCBpc1BhdHRlcm5MaXN0ID0gKHBsKSA9PiBwbC5sZW5ndGggPj0gMTtcbmNvbnN0IGlzR2xvYkxpc3QgPSAoZ2wpID0+IGdsLmxlbmd0aCA+PSAxO1xuLyoqXG4gKiBBbiBpbW11dGFibGUtaXNoIHZpZXcgb24gYW4gYXJyYXkgb2YgZ2xvYiBwYXJ0cyBhbmQgdGhlaXIgcGFyc2VkXG4gKiByZXN1bHRzXG4gKi9cbmNsYXNzIFBhdHRlcm4ge1xuICAgICNwYXR0ZXJuTGlzdDtcbiAgICAjZ2xvYkxpc3Q7XG4gICAgI2luZGV4O1xuICAgIGxlbmd0aDtcbiAgICAjcGxhdGZvcm07XG4gICAgI3Jlc3Q7XG4gICAgI2dsb2JTdHJpbmc7XG4gICAgI2lzRHJpdmU7XG4gICAgI2lzVU5DO1xuICAgICNpc0Fic29sdXRlO1xuICAgICNmb2xsb3dHbG9ic3RhciA9IHRydWU7XG4gICAgY29uc3RydWN0b3IocGF0dGVybkxpc3QsIGdsb2JMaXN0LCBpbmRleCwgcGxhdGZvcm0pIHtcbiAgICAgICAgaWYgKCFpc1BhdHRlcm5MaXN0KHBhdHRlcm5MaXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW1wdHkgcGF0dGVybiBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0dsb2JMaXN0KGdsb2JMaXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW1wdHkgZ2xvYiBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2JMaXN0Lmxlbmd0aCAhPT0gcGF0dGVybkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNtYXRjaGVkIHBhdHRlcm4gbGlzdCBhbmQgZ2xvYiBsaXN0IGxlbmd0aHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCA9IHBhdHRlcm5MaXN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGF0dGVybkxpc3QgPSBwYXR0ZXJuTGlzdDtcbiAgICAgICAgdGhpcy4jZ2xvYkxpc3QgPSBnbG9iTGlzdDtcbiAgICAgICAgdGhpcy4jaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy4jcGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgLy8gbm9ybWFsaXplIHJvb3QgZW50cmllcyBvZiBhYnNvbHV0ZSBwYXR0ZXJucyBvbiBpbml0aWFsIGNyZWF0aW9uLlxuICAgICAgICBpZiAodGhpcy4jaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGM6ID0+IFsnYzovJ11cbiAgICAgICAgICAgIC8vIEM6LyA9PiBbJ0M6LyddXG4gICAgICAgICAgICAvLyBDOi94ID0+IFsnQzovJywgJ3gnXVxuICAgICAgICAgICAgLy8gLy9ob3N0L3NoYXJlID0+IFsnLy9ob3N0L3NoYXJlLyddXG4gICAgICAgICAgICAvLyAvL2hvc3Qvc2hhcmUvID0+IFsnLy9ob3N0L3NoYXJlLyddXG4gICAgICAgICAgICAvLyAvL2hvc3Qvc2hhcmUveCA9PiBbJy8vaG9zdC9zaGFyZS8nLCAneCddXG4gICAgICAgICAgICAvLyAvZXRjID0+IFsnLycsICdldGMnXVxuICAgICAgICAgICAgLy8gLyA9PiBbJy8nXVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNVTkMoKSkge1xuICAgICAgICAgICAgICAgIC8vICcnIC8gJycgLyAnaG9zdCcgLyAnc2hhcmUnXG4gICAgICAgICAgICAgICAgY29uc3QgW3AwLCBwMSwgcDIsIHAzLCAuLi5wcmVzdF0gPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgICAgICAgICBjb25zdCBbZzAsIGcxLCBnMiwgZzMsIC4uLmdyZXN0XSA9IHRoaXMuI2dsb2JMaXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcmVzdFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kcyBpbiAvXG4gICAgICAgICAgICAgICAgICAgIHByZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGdyZXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBbcDAsIHAxLCBwMiwgcDMsICcnXS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IFtnMCwgZzEsIGcyLCBnMywgJyddLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXR0ZXJuTGlzdCA9IFtwLCAuLi5wcmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZ2xvYkxpc3QgPSBbZywgLi4uZ3Jlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy4jcGF0dGVybkxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0RyaXZlKCkgfHwgdGhpcy5pc0Fic29sdXRlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbcDEsIC4uLnByZXN0XSA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICAgICAgICAgIGNvbnN0IFtnMSwgLi4uZ3Jlc3RdID0gdGhpcy4jZ2xvYkxpc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHByZXN0WzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmRzIGluIC9cbiAgICAgICAgICAgICAgICAgICAgcHJlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZ3Jlc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHAxICsgJy8nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBnMSArICcvJztcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXR0ZXJuTGlzdCA9IFtwLCAuLi5wcmVzdF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZ2xvYkxpc3QgPSBbZywgLi4uZ3Jlc3RdO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy4jcGF0dGVybkxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgcGFyc2VkIGxpc3Qgb2YgcGF0dGVybnNcbiAgICAgKi9cbiAgICBwYXR0ZXJuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIG9mIGlmIHBhdHRlcm4oKSByZXR1cm5zIGEgc3RyaW5nXG4gICAgICovXG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy4jcGF0dGVybkxpc3RbdGhpcy4jaW5kZXhdID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBvZiBpZiBwYXR0ZXJuKCkgcmV0dXJucyBHTE9CU1RBUlxuICAgICAqL1xuICAgIGlzR2xvYnN0YXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF0gPT09IG1pbmltYXRjaF8xLkdMT0JTVEFSO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHBhdHRlcm4oKSByZXR1cm5zIGEgcmVnZXhwXG4gICAgICovXG4gICAgaXNSZWdFeHAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXR0ZXJuTGlzdFt0aGlzLiNpbmRleF0gaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSAvLWpvaW5lZCBzZXQgb2YgZ2xvYiBwYXJ0cyB0aGF0IG1ha2UgdXAgdGhpcyBwYXR0ZXJuXG4gICAgICovXG4gICAgZ2xvYlN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNnbG9iU3RyaW5nID1cbiAgICAgICAgICAgIHRoaXMuI2dsb2JTdHJpbmcgfHxcbiAgICAgICAgICAgICAgICAodGhpcy4jaW5kZXggPT09IDAgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQWJzb2x1dGUoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNnbG9iTGlzdFswXSArIHRoaXMuI2dsb2JMaXN0LnNsaWNlKDEpLmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNnbG9iTGlzdC5qb2luKCcvJylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNnbG9iTGlzdC5zbGljZSh0aGlzLiNpbmRleCkuam9pbignLycpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgcGF0dGVybiBwYXJ0cyBhZnRlciB0aGlzIG9uZVxuICAgICAqL1xuICAgIGhhc01vcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IHRoaXMuI2luZGV4ICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXIgdGhpcyBwYXJ0LCBvciBudWxsIGlmIHRoaXMgaXMgdGhlIGVuZFxuICAgICAqL1xuICAgIHJlc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyZXN0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmhhc01vcmUoKSlcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVzdCA9IG51bGwpO1xuICAgICAgICB0aGlzLiNyZXN0ID0gbmV3IFBhdHRlcm4odGhpcy4jcGF0dGVybkxpc3QsIHRoaXMuI2dsb2JMaXN0LCB0aGlzLiNpbmRleCArIDEsIHRoaXMuI3BsYXRmb3JtKTtcbiAgICAgICAgdGhpcy4jcmVzdC4jaXNBYnNvbHV0ZSA9IHRoaXMuI2lzQWJzb2x1dGU7XG4gICAgICAgIHRoaXMuI3Jlc3QuI2lzVU5DID0gdGhpcy4jaXNVTkM7XG4gICAgICAgIHRoaXMuI3Jlc3QuI2lzRHJpdmUgPSB0aGlzLiNpc0RyaXZlO1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgcGF0dGVybiByZXByZXNlbnRzIGEgLy91bmMvcGF0aC8gb24gd2luZG93c1xuICAgICAqL1xuICAgIGlzVU5DKCkge1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICByZXR1cm4gdGhpcy4jaXNVTkMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLiNpc1VOQ1xuICAgICAgICAgICAgOiAodGhpcy4jaXNVTkMgPVxuICAgICAgICAgICAgICAgIHRoaXMuI3BsYXRmb3JtID09PSAnd2luMzInICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2luZGV4ID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHBsWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBwbFsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBsWzJdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAhIXBsWzJdICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwbFszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgISFwbFszXSk7XG4gICAgfVxuICAgIC8vIHBhdHRlcm4gbGlrZSBDOi8uLi5cbiAgICAvLyBzcGxpdCA9IFsnQzonLCAuLi5dXG4gICAgLy8gWFhYOiB3b3VsZCBiZSBuaWNlIHRvIGhhbmRsZSBwYXR0ZXJucyBsaWtlIGBjOipgIHRvIHRlc3QgdGhlIGN3ZFxuICAgIC8vIGluIGM6IGZvciAqLCBidXQgSSBkb24ndCBrbm93IG9mIGEgd2F5IHRvIGV2ZW4gZmlndXJlIG91dCB3aGF0IHRoYXRcbiAgICAvLyBjd2QgaXMgd2l0aG91dCBhY3R1YWxseSBjaGRpcidpbmcgaW50byBpdD9cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIGEgZHJpdmUgbGV0dGVyIG9uIFdpbmRvd3NcbiAgICAgKi9cbiAgICBpc0RyaXZlKCkge1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhdHRlcm5MaXN0O1xuICAgICAgICByZXR1cm4gdGhpcy4jaXNEcml2ZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMuI2lzRHJpdmVcbiAgICAgICAgICAgIDogKHRoaXMuI2lzRHJpdmUgPVxuICAgICAgICAgICAgICAgIHRoaXMuI3BsYXRmb3JtID09PSAnd2luMzInICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2luZGV4ID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcGxbMF0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgIC9eW2Etel06JC9pLnRlc3QocGxbMF0pKTtcbiAgICB9XG4gICAgLy8gcGF0dGVybiA9ICcvJyBvciAnLy4uLicgb3IgJy94Ly4uLidcbiAgICAvLyBzcGxpdCA9IFsnJywgJyddIG9yIFsnJywgLi4uXSBvciBbJycsICd4JywgLi4uXVxuICAgIC8vIERyaXZlIGFuZCBVTkMgYm90aCBjb25zaWRlcmVkIGFic29sdXRlIG9uIHdpbmRvd3NcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBwYXR0ZXJuIGlzIHJvb3RlZCBvbiBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICovXG4gICAgaXNBYnNvbHV0ZSgpIHtcbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXR0ZXJuTGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lzQWJzb2x1dGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLiNpc0Fic29sdXRlXG4gICAgICAgICAgICA6ICh0aGlzLiNpc0Fic29sdXRlID1cbiAgICAgICAgICAgICAgICAocGxbMF0gPT09ICcnICYmIHBsLmxlbmd0aCA+IDEpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcml2ZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNVTkMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbnN1bWUgdGhlIHJvb3Qgb2YgdGhlIHBhdHRlcm4sIGFuZCByZXR1cm4gaXRcbiAgICAgKi9cbiAgICByb290KCkge1xuICAgICAgICBjb25zdCBwID0gdGhpcy4jcGF0dGVybkxpc3RbMF07XG4gICAgICAgIHJldHVybiAodHlwZW9mIHAgPT09ICdzdHJpbmcnICYmIHRoaXMuaXNBYnNvbHV0ZSgpICYmIHRoaXMuI2luZGV4ID09PSAwKSA/XG4gICAgICAgICAgICBwXG4gICAgICAgICAgICA6ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgZ2xvYnN0YXIgcGF0dGVybiBpcyBhbGxvd2VkIHRvIGZvbGxvd1xuICAgICAqIGEgc3ltYm9saWMgbGluay5cbiAgICAgKi9cbiAgICBjaGVja0ZvbGxvd0dsb2JzdGFyKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLiNpbmRleCA9PT0gMCB8fFxuICAgICAgICAgICAgIXRoaXMuaXNHbG9ic3RhcigpIHx8XG4gICAgICAgICAgICAhdGhpcy4jZm9sbG93R2xvYnN0YXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIHRoYXQgdGhlIGN1cnJlbnQgZ2xvYnN0YXIgcGF0dGVybiBpcyBmb2xsb3dpbmcgYSBzeW1ib2xpYyBsaW5rXG4gICAgICovXG4gICAgbWFya0ZvbGxvd0dsb2JzdGFyKCkge1xuICAgICAgICBpZiAodGhpcy4jaW5kZXggPT09IDAgfHwgIXRoaXMuaXNHbG9ic3RhcigpIHx8ICF0aGlzLiNmb2xsb3dHbG9ic3RhcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy4jZm9sbG93R2xvYnN0YXIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5QYXR0ZXJuID0gUGF0dGVybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUGF0dGVybiIsIm1pbmltYXRjaF8xIiwicmVxdWlyZSIsImlzUGF0dGVybkxpc3QiLCJwbCIsImxlbmd0aCIsImlzR2xvYkxpc3QiLCJnbCIsInBhdHRlcm5MaXN0IiwiZ2xvYkxpc3QiLCJpbmRleCIsInBsYXRmb3JtIiwicmVzdCIsImdsb2JTdHJpbmciLCJpc0RyaXZlIiwiaXNVTkMiLCJpc0Fic29sdXRlIiwiZm9sbG93R2xvYnN0YXIiLCJjb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsInAwIiwicDEiLCJwMiIsInAzIiwicHJlc3QiLCJnMCIsImcxIiwiZzIiLCJnMyIsImdyZXN0Iiwic2hpZnQiLCJwIiwiam9pbiIsImciLCJwYXR0ZXJuIiwiaXNTdHJpbmciLCJpc0dsb2JzdGFyIiwiR0xPQlNUQVIiLCJpc1JlZ0V4cCIsIlJlZ0V4cCIsInNsaWNlIiwiaGFzTW9yZSIsInVuZGVmaW5lZCIsInRlc3QiLCJyb290IiwiY2hlY2tGb2xsb3dHbG9ic3RhciIsIm1hcmtGb2xsb3dHbG9ic3RhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/processor.js":
/*!******************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/processor.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// synchronous utility for filtering entries and calculating subwalks\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\");\n/**\n * A cache of which patterns have been processed for a given Path\n */ class HasWalkedCache {\n    constructor(store = new Map()){\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached) cached.add(pattern.globString());\n        else this.store.set(fullpath, new Set([\n            pattern.globString()\n        ]));\n    }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */ class MatchRecord {\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [\n            ...this.store.entries()\n        ].map(([path, n])=>[\n                path,\n                !!(n & 2),\n                !!(n & 1)\n            ]);\n    }\n    constructor(){\n        this.store = new Map();\n    }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */ class SubWalks {\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find((p)=>p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        } else this.store.set(target, [\n            pattern\n        ]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */ if (!subs) {\n            throw new Error(\"attempting to walk unknown path\");\n        }\n        /* c8 ignore stop */ return subs;\n    }\n    entries() {\n        return this.keys().map((k)=>[\n                k,\n                this.store.get(k)\n            ]);\n    }\n    keys() {\n        return [\n            ...this.store.keys()\n        ].filter((t)=>t.canReaddir());\n    }\n    constructor(){\n        this.store = new Map();\n    }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */ class Processor {\n    constructor(opts, hasWalkedCache){\n        this.matches = new MatchRecord();\n        this.subwalks = new SubWalks();\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map((p)=>[\n                target,\n                p\n            ]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet){\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === \"/\" && this.opts.root !== undefined ? this.opts.root : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                } else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT()) continue;\n            let p;\n            let rest;\n            let changed = false;\n            while(typeof (p = pattern.pattern()) === \"string\" && (rest = pattern.rest())){\n                const c = t.resolve(p);\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern)) continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === \"string\") {\n                // must not be final entry, otherwise we would have\n                // concatenated it earlier.\n                const ifDir = p === \"..\" || p === \"\" || p === \".\";\n                this.matches.add(t.resolve(p), absolute, ifDir);\n                continue;\n            } else if (p === minimatch_1.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || (rp === \"\" || rp === \".\") && !rrest) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === \"\" || rp === \".\");\n                } else {\n                    if (rp === \"..\") {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */ const tp = t.parent || t;\n                        /* c8 ignore stop */ if (!rrest) this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            } else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries){\n            for (const pattern of patterns){\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch_1.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                } else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                } else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith(\".\")) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                } else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    } else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === \"string\" && // dots and empty were handled already\n            rp !== \"..\" && rp !== \"\" && rp !== \".\") {\n                this.testString(e, rp, rest.rest(), absolute);\n            } else if (rp === \"..\") {\n                /* c8 ignore start */ const ep = e.parent || e;\n                /* c8 ignore stop */ this.subwalks.add(ep, rest);\n            } else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name)) return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        } else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p)) return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        } else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\nexports.Processor = Processor; //# sourceMappingURL=processor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHFFQUFxRTtBQUNyRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDM0YsTUFBTU0sY0FBY0MsbUJBQU9BLENBQUMsMEZBQVc7QUFDdkM7O0NBRUMsR0FDRCxNQUFNRjtJQUVGRyxZQUFZQyxRQUFRLElBQUlDLEtBQUssQ0FBRTtRQUMzQixJQUFJLENBQUNELEtBQUssR0FBR0E7SUFDakI7SUFDQUUsT0FBTztRQUNILE9BQU8sSUFBSU4sZUFBZSxJQUFJSyxJQUFJLElBQUksQ0FBQ0QsS0FBSztJQUNoRDtJQUNBRyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ0wsS0FBSyxDQUFDTSxHQUFHLENBQUNGLE9BQU9HLFFBQVEsS0FBS0MsSUFBSUgsUUFBUUksVUFBVTtJQUNwRTtJQUNBQyxZQUFZTixNQUFNLEVBQUVDLE9BQU8sRUFBRTtRQUN6QixNQUFNRSxXQUFXSCxPQUFPRyxRQUFRO1FBQ2hDLE1BQU1JLFNBQVMsSUFBSSxDQUFDWCxLQUFLLENBQUNNLEdBQUcsQ0FBQ0M7UUFDOUIsSUFBSUksUUFDQUEsT0FBT0MsR0FBRyxDQUFDUCxRQUFRSSxVQUFVO2FBRTdCLElBQUksQ0FBQ1QsS0FBSyxDQUFDYSxHQUFHLENBQUNOLFVBQVUsSUFBSU8sSUFBSTtZQUFDVCxRQUFRSSxVQUFVO1NBQUc7SUFDL0Q7QUFDSjtBQUNBbEIsc0JBQXNCLEdBQUdLO0FBQ3pCOzs7O0NBSUMsR0FDRCxNQUFNRDtJQUVGaUIsSUFBSVIsTUFBTSxFQUFFVyxRQUFRLEVBQUVDLEtBQUssRUFBRTtRQUN6QixNQUFNQyxJQUFJLENBQUNGLFdBQVcsSUFBSSxLQUFNQyxDQUFBQSxRQUFRLElBQUk7UUFDNUMsTUFBTUUsVUFBVSxJQUFJLENBQUNsQixLQUFLLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDL0IsSUFBSSxDQUFDSixLQUFLLENBQUNhLEdBQUcsQ0FBQ1QsUUFBUWMsWUFBWUMsWUFBWUYsSUFBSUEsSUFBSUM7SUFDM0Q7SUFDQSx5QkFBeUI7SUFDekJFLFVBQVU7UUFDTixPQUFPO2VBQUksSUFBSSxDQUFDcEIsS0FBSyxDQUFDb0IsT0FBTztTQUFHLENBQUNDLEdBQUcsQ0FBQyxDQUFDLENBQUNDLE1BQU1MLEVBQUUsR0FBSztnQkFDaERLO2dCQUNBLENBQUMsQ0FBRUwsQ0FBQUEsSUFBSTtnQkFDUCxDQUFDLENBQUVBLENBQUFBLElBQUk7YUFDVjtJQUNMOzthQWJBakIsUUFBUSxJQUFJQzs7QUFjaEI7QUFDQVYsbUJBQW1CLEdBQUdJO0FBQ3RCOzs7Q0FHQyxHQUNELE1BQU1EO0lBRUZrQixJQUFJUixNQUFNLEVBQUVDLE9BQU8sRUFBRTtRQUNqQixJQUFJLENBQUNELE9BQU9tQixVQUFVLElBQUk7WUFDdEI7UUFDSjtRQUNBLE1BQU1DLE9BQU8sSUFBSSxDQUFDeEIsS0FBSyxDQUFDTSxHQUFHLENBQUNGO1FBQzVCLElBQUlvQixNQUFNO1lBQ04sSUFBSSxDQUFDQSxLQUFLQyxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVqQixVQUFVLE9BQU9KLFFBQVFJLFVBQVUsS0FBSztnQkFDMURlLEtBQUtHLElBQUksQ0FBQ3RCO1lBQ2Q7UUFDSixPQUVJLElBQUksQ0FBQ0wsS0FBSyxDQUFDYSxHQUFHLENBQUNULFFBQVE7WUFBQ0M7U0FBUTtJQUN4QztJQUNBQyxJQUFJRixNQUFNLEVBQUU7UUFDUixNQUFNb0IsT0FBTyxJQUFJLENBQUN4QixLQUFLLENBQUNNLEdBQUcsQ0FBQ0Y7UUFDNUIsbUJBQW1CLEdBQ25CLElBQUksQ0FBQ29CLE1BQU07WUFDUCxNQUFNLElBQUlJLE1BQU07UUFDcEI7UUFDQSxrQkFBa0IsR0FDbEIsT0FBT0o7SUFDWDtJQUNBSixVQUFVO1FBQ04sT0FBTyxJQUFJLENBQUNTLElBQUksR0FBR1IsR0FBRyxDQUFDUyxDQUFBQSxJQUFLO2dCQUFDQTtnQkFBRyxJQUFJLENBQUM5QixLQUFLLENBQUNNLEdBQUcsQ0FBQ3dCO2FBQUc7SUFDdEQ7SUFDQUQsT0FBTztRQUNILE9BQU87ZUFBSSxJQUFJLENBQUM3QixLQUFLLENBQUM2QixJQUFJO1NBQUcsQ0FBQ0UsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFVCxVQUFVO0lBQzFEOzthQTVCQXZCLFFBQVEsSUFBSUM7O0FBNkJoQjtBQUNBVixnQkFBZ0IsR0FBR0c7QUFDbkI7Ozs7O0NBS0MsR0FDRCxNQUFNRDtJQVFGTSxZQUFZa0MsSUFBSSxFQUFFQyxjQUFjLENBQUU7YUFObENDLFVBQVUsSUFBSXhDO2FBQ2R5QyxXQUFXLElBQUkxQztRQU1YLElBQUksQ0FBQ3VDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBRyxDQUFDLENBQUNKLEtBQUtJLE1BQU07UUFDM0IsSUFBSSxDQUFDQyxHQUFHLEdBQUcsQ0FBQyxDQUFDTCxLQUFLSyxHQUFHO1FBQ3JCLElBQUksQ0FBQ0osY0FBYyxHQUNmQSxpQkFBaUJBLGVBQWVoQyxJQUFJLEtBQUssSUFBSU47SUFDckQ7SUFDQTJDLGdCQUFnQm5DLE1BQU0sRUFBRW9DLFFBQVEsRUFBRTtRQUM5QixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsTUFBTUMsZ0JBQWdCRCxTQUFTbkIsR0FBRyxDQUFDSyxDQUFBQSxJQUFLO2dCQUFDdEI7Z0JBQVFzQjthQUFFO1FBQ25ELGdFQUFnRTtRQUNoRSx1Q0FBdUM7UUFDdkMsS0FBSyxJQUFJLENBQUNNLEdBQUczQixRQUFRLElBQUlvQyxjQUFlO1lBQ3BDLElBQUksQ0FBQ1AsY0FBYyxDQUFDeEIsV0FBVyxDQUFDc0IsR0FBRzNCO1lBQ25DLE1BQU1xQyxPQUFPckMsUUFBUXFDLElBQUk7WUFDekIsTUFBTTNCLFdBQVdWLFFBQVFzQyxVQUFVLE1BQU0sSUFBSSxDQUFDVixJQUFJLENBQUNsQixRQUFRLEtBQUs7WUFDaEUsa0NBQWtDO1lBQ2xDLElBQUkyQixNQUFNO2dCQUNOVixJQUFJQSxFQUFFWSxPQUFPLENBQUNGLFNBQVMsT0FBTyxJQUFJLENBQUNULElBQUksQ0FBQ1MsSUFBSSxLQUFLdkIsWUFDN0MsSUFBSSxDQUFDYyxJQUFJLENBQUNTLElBQUksR0FDWkE7Z0JBQ04sTUFBTUcsT0FBT3hDLFFBQVF3QyxJQUFJO2dCQUN6QixJQUFJLENBQUNBLE1BQU07b0JBQ1AsSUFBSSxDQUFDVixPQUFPLENBQUN2QixHQUFHLENBQUNvQixHQUFHLE1BQU07b0JBQzFCO2dCQUNKLE9BQ0s7b0JBQ0QzQixVQUFVd0M7Z0JBQ2Q7WUFDSjtZQUNBLElBQUliLEVBQUVjLFFBQVEsSUFDVjtZQUNKLElBQUlwQjtZQUNKLElBQUltQjtZQUNKLElBQUlFLFVBQVU7WUFDZCxNQUFPLE9BQVFyQixDQUFBQSxJQUFJckIsUUFBUUEsT0FBTyxFQUFDLE1BQU8sWUFDckN3QyxDQUFBQSxPQUFPeEMsUUFBUXdDLElBQUksRUFBQyxFQUFJO2dCQUN6QixNQUFNRyxJQUFJaEIsRUFBRVksT0FBTyxDQUFDbEI7Z0JBQ3BCTSxJQUFJZ0I7Z0JBQ0ozQyxVQUFVd0M7Z0JBQ1ZFLFVBQVU7WUFDZDtZQUNBckIsSUFBSXJCLFFBQVFBLE9BQU87WUFDbkJ3QyxPQUFPeEMsUUFBUXdDLElBQUk7WUFDbkIsSUFBSUUsU0FBUztnQkFDVCxJQUFJLElBQUksQ0FBQ2IsY0FBYyxDQUFDL0IsU0FBUyxDQUFDNkIsR0FBRzNCLFVBQ2pDO2dCQUNKLElBQUksQ0FBQzZCLGNBQWMsQ0FBQ3hCLFdBQVcsQ0FBQ3NCLEdBQUczQjtZQUN2QztZQUNBLHVEQUF1RDtZQUN2RCxxQ0FBcUM7WUFDckMsa0RBQWtEO1lBQ2xELElBQUksT0FBT3FCLE1BQU0sVUFBVTtnQkFDdkIsbURBQW1EO2dCQUNuRCwyQkFBMkI7Z0JBQzNCLE1BQU1WLFFBQVFVLE1BQU0sUUFBUUEsTUFBTSxNQUFNQSxNQUFNO2dCQUM5QyxJQUFJLENBQUNTLE9BQU8sQ0FBQ3ZCLEdBQUcsQ0FBQ29CLEVBQUVZLE9BQU8sQ0FBQ2xCLElBQUlYLFVBQVVDO2dCQUN6QztZQUNKLE9BQ0ssSUFBSVUsTUFBTTdCLFlBQVlvRCxRQUFRLEVBQUU7Z0JBQ2pDLHdDQUF3QztnQkFDeEMsNENBQTRDO2dCQUM1Qyx3REFBd0Q7Z0JBQ3hELDREQUE0RDtnQkFDNUQsZ0VBQWdFO2dCQUNoRSxJQUFJLENBQUNqQixFQUFFa0IsY0FBYyxNQUNqQixJQUFJLENBQUNiLE1BQU0sSUFDWGhDLFFBQVE4QyxtQkFBbUIsSUFBSTtvQkFDL0IsSUFBSSxDQUFDZixRQUFRLENBQUN4QixHQUFHLENBQUNvQixHQUFHM0I7Z0JBQ3pCO2dCQUNBLE1BQU0rQyxLQUFLUCxNQUFNeEM7Z0JBQ2pCLE1BQU1nRCxRQUFRUixNQUFNQTtnQkFDcEIsSUFBSSxDQUFDQSxRQUFTLENBQUNPLE9BQU8sTUFBTUEsT0FBTyxHQUFFLEtBQU0sQ0FBQ0MsT0FBUTtvQkFDaEQsaURBQWlEO29CQUNqRCw2Q0FBNkM7b0JBQzdDLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ3ZCLEdBQUcsQ0FBQ29CLEdBQUdqQixVQUFVcUMsT0FBTyxNQUFNQSxPQUFPO2dCQUN0RCxPQUNLO29CQUNELElBQUlBLE9BQU8sTUFBTTt3QkFDYix3REFBd0Q7d0JBQ3hELHdEQUF3RDt3QkFDeEQsbUJBQW1CLEdBQ25CLE1BQU1FLEtBQUt0QixFQUFFdUIsTUFBTSxJQUFJdkI7d0JBQ3ZCLGtCQUFrQixHQUNsQixJQUFJLENBQUNxQixPQUNELElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ3ZCLEdBQUcsQ0FBQzBDLElBQUl2QyxVQUFVOzZCQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDbUIsY0FBYyxDQUFDL0IsU0FBUyxDQUFDbUQsSUFBSUQsUUFBUTs0QkFDaEQsSUFBSSxDQUFDakIsUUFBUSxDQUFDeEIsR0FBRyxDQUFDMEMsSUFBSUQ7d0JBQzFCO29CQUNKO2dCQUNKO1lBQ0osT0FDSyxJQUFJM0IsYUFBYThCLFFBQVE7Z0JBQzFCLElBQUksQ0FBQ3BCLFFBQVEsQ0FBQ3hCLEdBQUcsQ0FBQ29CLEdBQUczQjtZQUN6QjtRQUNKO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQW9ELGlCQUFpQjtRQUNiLE9BQU8sSUFBSSxDQUFDckIsUUFBUSxDQUFDUCxJQUFJO0lBQzdCO0lBQ0E2QixRQUFRO1FBQ0osT0FBTyxJQUFJakUsVUFBVSxJQUFJLENBQUN3QyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxjQUFjO0lBQ3ZEO0lBQ0EsMERBQTBEO0lBQzFELHlDQUF5QztJQUN6Qyw2Q0FBNkM7SUFDN0MsMkJBQTJCO0lBQzNCeUIsY0FBY0osTUFBTSxFQUFFbkMsT0FBTyxFQUFFO1FBQzNCLE1BQU1vQixXQUFXLElBQUksQ0FBQ0osUUFBUSxDQUFDOUIsR0FBRyxDQUFDaUQ7UUFDbkMseURBQXlEO1FBQ3pELE1BQU1LLFVBQVUsSUFBSSxDQUFDRixLQUFLO1FBQzFCLEtBQUssTUFBTUcsS0FBS3pDLFFBQVM7WUFDckIsS0FBSyxNQUFNZixXQUFXbUMsU0FBVTtnQkFDNUIsTUFBTXpCLFdBQVdWLFFBQVFzQyxVQUFVO2dCQUNuQyxNQUFNakIsSUFBSXJCLFFBQVFBLE9BQU87Z0JBQ3pCLE1BQU13QyxPQUFPeEMsUUFBUXdDLElBQUk7Z0JBQ3pCLElBQUluQixNQUFNN0IsWUFBWW9ELFFBQVEsRUFBRTtvQkFDNUJXLFFBQVFFLFlBQVksQ0FBQ0QsR0FBR3hELFNBQVN3QyxNQUFNOUI7Z0JBQzNDLE9BQ0ssSUFBSVcsYUFBYThCLFFBQVE7b0JBQzFCSSxRQUFRRyxVQUFVLENBQUNGLEdBQUduQyxHQUFHbUIsTUFBTTlCO2dCQUNuQyxPQUNLO29CQUNENkMsUUFBUUksVUFBVSxDQUFDSCxHQUFHbkMsR0FBR21CLE1BQU05QjtnQkFDbkM7WUFDSjtRQUNKO1FBQ0EsT0FBTzZDO0lBQ1g7SUFDQUUsYUFBYUQsQ0FBQyxFQUFFeEQsT0FBTyxFQUFFd0MsSUFBSSxFQUFFOUIsUUFBUSxFQUFFO1FBQ3JDLElBQUksSUFBSSxDQUFDdUIsR0FBRyxJQUFJLENBQUN1QixFQUFFSSxJQUFJLENBQUNDLFVBQVUsQ0FBQyxNQUFNO1lBQ3JDLElBQUksQ0FBQzdELFFBQVE4RCxPQUFPLElBQUk7Z0JBQ3BCLElBQUksQ0FBQ2hDLE9BQU8sQ0FBQ3ZCLEdBQUcsQ0FBQ2lELEdBQUc5QyxVQUFVO1lBQ2xDO1lBQ0EsSUFBSThDLEVBQUV0QyxVQUFVLElBQUk7Z0JBQ2hCLDJEQUEyRDtnQkFDM0QsZ0VBQWdFO2dCQUNoRSwrREFBK0Q7Z0JBQy9ELGlFQUFpRTtnQkFDakUsdURBQXVEO2dCQUN2RCxJQUFJLElBQUksQ0FBQ2MsTUFBTSxJQUFJLENBQUN3QixFQUFFWCxjQUFjLElBQUk7b0JBQ3BDLElBQUksQ0FBQ2QsUUFBUSxDQUFDeEIsR0FBRyxDQUFDaUQsR0FBR3hEO2dCQUN6QixPQUNLLElBQUl3RCxFQUFFWCxjQUFjLElBQUk7b0JBQ3pCLElBQUlMLFFBQVF4QyxRQUFROEMsbUJBQW1CLElBQUk7d0JBQ3ZDLElBQUksQ0FBQ2YsUUFBUSxDQUFDeEIsR0FBRyxDQUFDaUQsR0FBR2hCO29CQUN6QixPQUNLLElBQUl4QyxRQUFRK0Qsa0JBQWtCLElBQUk7d0JBQ25DLElBQUksQ0FBQ2hDLFFBQVEsQ0FBQ3hCLEdBQUcsQ0FBQ2lELEdBQUd4RDtvQkFDekI7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0Esc0RBQXNEO1FBQ3RELFlBQVk7UUFDWixJQUFJd0MsTUFBTTtZQUNOLE1BQU1PLEtBQUtQLEtBQUt4QyxPQUFPO1lBQ3ZCLElBQUksT0FBTytDLE9BQU8sWUFDZCxzQ0FBc0M7WUFDdENBLE9BQU8sUUFDUEEsT0FBTyxNQUNQQSxPQUFPLEtBQUs7Z0JBQ1osSUFBSSxDQUFDWSxVQUFVLENBQUNILEdBQUdULElBQUlQLEtBQUtBLElBQUksSUFBSTlCO1lBQ3hDLE9BQ0ssSUFBSXFDLE9BQU8sTUFBTTtnQkFDbEIsbUJBQW1CLEdBQ25CLE1BQU1pQixLQUFLUixFQUFFTixNQUFNLElBQUlNO2dCQUN2QixrQkFBa0IsR0FDbEIsSUFBSSxDQUFDekIsUUFBUSxDQUFDeEIsR0FBRyxDQUFDeUQsSUFBSXhCO1lBQzFCLE9BQ0ssSUFBSU8sY0FBY0ksUUFBUTtnQkFDM0IsSUFBSSxDQUFDTyxVQUFVLENBQUNGLEdBQUdULElBQUlQLEtBQUtBLElBQUksSUFBSTlCO1lBQ3hDO1FBQ0o7SUFDSjtJQUNBZ0QsV0FBV0YsQ0FBQyxFQUFFbkMsQ0FBQyxFQUFFbUIsSUFBSSxFQUFFOUIsUUFBUSxFQUFFO1FBQzdCLElBQUksQ0FBQ1csRUFBRTRDLElBQUksQ0FBQ1QsRUFBRUksSUFBSSxHQUNkO1FBQ0osSUFBSSxDQUFDcEIsTUFBTTtZQUNQLElBQUksQ0FBQ1YsT0FBTyxDQUFDdkIsR0FBRyxDQUFDaUQsR0FBRzlDLFVBQVU7UUFDbEMsT0FDSztZQUNELElBQUksQ0FBQ3FCLFFBQVEsQ0FBQ3hCLEdBQUcsQ0FBQ2lELEdBQUdoQjtRQUN6QjtJQUNKO0lBQ0FtQixXQUFXSCxDQUFDLEVBQUVuQyxDQUFDLEVBQUVtQixJQUFJLEVBQUU5QixRQUFRLEVBQUU7UUFDN0IsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQzhDLEVBQUVVLE9BQU8sQ0FBQzdDLElBQ1g7UUFDSixJQUFJLENBQUNtQixNQUFNO1lBQ1AsSUFBSSxDQUFDVixPQUFPLENBQUN2QixHQUFHLENBQUNpRCxHQUFHOUMsVUFBVTtRQUNsQyxPQUNLO1lBQ0QsSUFBSSxDQUFDcUIsUUFBUSxDQUFDeEIsR0FBRyxDQUFDaUQsR0FBR2hCO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBdEQsaUJBQWlCLEdBQUdFLFdBQ3BCLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3Byb2Nlc3Nvci5qcz9mMjcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gc3luY2hyb25vdXMgdXRpbGl0eSBmb3IgZmlsdGVyaW5nIGVudHJpZXMgYW5kIGNhbGN1bGF0aW5nIHN1YndhbGtzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb2Nlc3NvciA9IGV4cG9ydHMuU3ViV2Fsa3MgPSBleHBvcnRzLk1hdGNoUmVjb3JkID0gZXhwb3J0cy5IYXNXYWxrZWRDYWNoZSA9IHZvaWQgMDtcbmNvbnN0IG1pbmltYXRjaF8xID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcbi8qKlxuICogQSBjYWNoZSBvZiB3aGljaCBwYXR0ZXJucyBoYXZlIGJlZW4gcHJvY2Vzc2VkIGZvciBhIGdpdmVuIFBhdGhcbiAqL1xuY2xhc3MgSGFzV2Fsa2VkQ2FjaGUge1xuICAgIHN0b3JlO1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlID0gbmV3IE1hcCgpKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIYXNXYWxrZWRDYWNoZShuZXcgTWFwKHRoaXMuc3RvcmUpKTtcbiAgICB9XG4gICAgaGFzV2Fsa2VkKHRhcmdldCwgcGF0dGVybikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXQodGFyZ2V0LmZ1bGxwYXRoKCkpPy5oYXMocGF0dGVybi5nbG9iU3RyaW5nKCkpO1xuICAgIH1cbiAgICBzdG9yZVdhbGtlZCh0YXJnZXQsIHBhdHRlcm4pIHtcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSB0YXJnZXQuZnVsbHBhdGgoKTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5zdG9yZS5nZXQoZnVsbHBhdGgpO1xuICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgY2FjaGVkLmFkZChwYXR0ZXJuLmdsb2JTdHJpbmcoKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0KGZ1bGxwYXRoLCBuZXcgU2V0KFtwYXR0ZXJuLmdsb2JTdHJpbmcoKV0pKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc1dhbGtlZENhY2hlID0gSGFzV2Fsa2VkQ2FjaGU7XG4vKipcbiAqIEEgcmVjb3JkIG9mIHdoaWNoIHBhdGhzIGhhdmUgYmVlbiBtYXRjaGVkIGluIGEgZ2l2ZW4gd2FsayBzdGVwLFxuICogYW5kIHdoZXRoZXIgdGhleSBvbmx5IGFyZSBjb25zaWRlcmVkIGEgbWF0Y2ggaWYgdGhleSBhcmUgYSBkaXJlY3RvcnksXG4gKiBhbmQgd2hldGhlciB0aGVpciBhYnNvbHV0ZSBvciByZWxhdGl2ZSBwYXRoIHNob3VsZCBiZSByZXR1cm5lZC5cbiAqL1xuY2xhc3MgTWF0Y2hSZWNvcmQge1xuICAgIHN0b3JlID0gbmV3IE1hcCgpO1xuICAgIGFkZCh0YXJnZXQsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBuID0gKGFic29sdXRlID8gMiA6IDApIHwgKGlmRGlyID8gMSA6IDApO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zdG9yZS5zZXQodGFyZ2V0LCBjdXJyZW50ID09PSB1bmRlZmluZWQgPyBuIDogbiAmIGN1cnJlbnQpO1xuICAgIH1cbiAgICAvLyBtYXRjaCwgYWJzb2x1dGUsIGlmZGlyXG4gICAgZW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnN0b3JlLmVudHJpZXMoKV0ubWFwKChbcGF0aCwgbl0pID0+IFtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAhIShuICYgMiksXG4gICAgICAgICAgICAhIShuICYgMSksXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWF0Y2hSZWNvcmQgPSBNYXRjaFJlY29yZDtcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHBhdHRlcm5zIHRoYXQgbXVzdCBiZSBwcm9jZXNzZWQgaW4gYSBzdWJzZXF1ZW50IHN0ZXBcbiAqIGZvciBhIGdpdmVuIHBhdGguXG4gKi9cbmNsYXNzIFN1YldhbGtzIHtcbiAgICBzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICBhZGQodGFyZ2V0LCBwYXR0ZXJuKSB7XG4gICAgICAgIGlmICghdGFyZ2V0LmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnMgPSB0aGlzLnN0b3JlLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoc3Vicykge1xuICAgICAgICAgICAgaWYgKCFzdWJzLmZpbmQocCA9PiBwLmdsb2JTdHJpbmcoKSA9PT0gcGF0dGVybi5nbG9iU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgc3Vicy5wdXNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0KHRhcmdldCwgW3BhdHRlcm5dKTtcbiAgICB9XG4gICAgZ2V0KHRhcmdldCkge1xuICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5zdG9yZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghc3Vicykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0aW5nIHRvIHdhbGsgdW5rbm93biBwYXRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHN1YnM7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5tYXAoayA9PiBbaywgdGhpcy5zdG9yZS5nZXQoayldKTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnN0b3JlLmtleXMoKV0uZmlsdGVyKHQgPT4gdC5jYW5SZWFkZGlyKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ViV2Fsa3MgPSBTdWJXYWxrcztcbi8qKlxuICogVGhlIGNsYXNzIHRoYXQgcHJvY2Vzc2VzIHBhdHRlcm5zIGZvciBhIGdpdmVuIHBhdGguXG4gKlxuICogSGFuZGxlcyBjaGlsZCBlbnRyeSBmaWx0ZXJpbmcsIGFuZCBkZXRlcm1pbmluZyB3aGV0aGVyIGEgcGF0aCdzXG4gKiBkaXJlY3RvcnkgY29udGVudHMgbXVzdCBiZSByZWFkLlxuICovXG5jbGFzcyBQcm9jZXNzb3Ige1xuICAgIGhhc1dhbGtlZENhY2hlO1xuICAgIG1hdGNoZXMgPSBuZXcgTWF0Y2hSZWNvcmQoKTtcbiAgICBzdWJ3YWxrcyA9IG5ldyBTdWJXYWxrcygpO1xuICAgIHBhdHRlcm5zO1xuICAgIGZvbGxvdztcbiAgICBkb3Q7XG4gICAgb3B0cztcbiAgICBjb25zdHJ1Y3RvcihvcHRzLCBoYXNXYWxrZWRDYWNoZSkge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmZvbGxvdyA9ICEhb3B0cy5mb2xsb3c7XG4gICAgICAgIHRoaXMuZG90ID0gISFvcHRzLmRvdDtcbiAgICAgICAgdGhpcy5oYXNXYWxrZWRDYWNoZSA9XG4gICAgICAgICAgICBoYXNXYWxrZWRDYWNoZSA/IGhhc1dhbGtlZENhY2hlLmNvcHkoKSA6IG5ldyBIYXNXYWxrZWRDYWNoZSgpO1xuICAgIH1cbiAgICBwcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdTZXQgPSBwYXR0ZXJucy5tYXAocCA9PiBbdGFyZ2V0LCBwXSk7XG4gICAgICAgIC8vIG1hcCBvZiBwYXRocyB0byB0aGUgbWFnaWMtc3RhcnRpbmcgc3Vid2Fsa3MgdGhleSBuZWVkIHRvIHdhbGtcbiAgICAgICAgLy8gZmlyc3QgaXRlbSBpbiBwYXR0ZXJucyBpcyB0aGUgZmlsdGVyXG4gICAgICAgIGZvciAobGV0IFt0LCBwYXR0ZXJuXSBvZiBwcm9jZXNzaW5nU2V0KSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dhbGtlZENhY2hlLnN0b3JlV2Fsa2VkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHBhdHRlcm4ucm9vdCgpO1xuICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwYXR0ZXJuLmlzQWJzb2x1dGUoKSAmJiB0aGlzLm9wdHMuYWJzb2x1dGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgLy8gc3RhcnQgYWJzb2x1dGUgcGF0dGVybnMgYXQgcm9vdFxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgICB0ID0gdC5yZXNvbHZlKHJvb3QgPT09ICcvJyAmJiB0aGlzLm9wdHMucm9vdCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLnJvb3RcbiAgICAgICAgICAgICAgICAgICAgOiByb290KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gcGF0dGVybi5yZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQodCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0LmlzRU5PRU5UKCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICAgIGxldCByZXN0O1xuICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2YgKHAgPSBwYXR0ZXJuLnBhdHRlcm4oKSkgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgKHJlc3QgPSBwYXR0ZXJuLnJlc3QoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gdC5yZXNvbHZlKHApO1xuICAgICAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXN0O1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHBhdHRlcm4ucGF0dGVybigpO1xuICAgICAgICAgICAgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXYWxrZWRDYWNoZS5oYXNXYWxrZWQodCwgcGF0dGVybikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzV2Fsa2VkQ2FjaGUuc3RvcmVXYWxrZWQodCwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3cgd2UgaGF2ZSBlaXRoZXIgYSBmaW5hbCBzdHJpbmcgZm9yIGEga25vd24gZW50cnksXG4gICAgICAgICAgICAvLyBtb3JlIHN0cmluZ3MgZm9yIGFuIHVua25vd24gZW50cnksXG4gICAgICAgICAgICAvLyBvciBhIHBhdHRlcm4gc3RhcnRpbmcgd2l0aCBtYWdpYywgbW91bnRlZCBvbiB0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIG11c3Qgbm90IGJlIGZpbmFsIGVudHJ5LCBvdGhlcndpc2Ugd2Ugd291bGQgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIGNvbmNhdGVuYXRlZCBpdCBlYXJsaWVyLlxuICAgICAgICAgICAgICAgIGNvbnN0IGlmRGlyID0gcCA9PT0gJy4uJyB8fCBwID09PSAnJyB8fCBwID09PSAnLic7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZCh0LnJlc29sdmUocCksIGFic29sdXRlLCBpZkRpcik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwID09PSBtaW5pbWF0Y2hfMS5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHJlc3QsIG1hdGNoIGFuZCBzdWJ3YWxrIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAvLyBpZiByZXN0LCBwcm9jZXNzIHJlc3QgYW5kIHN1YndhbGsgcGF0dGVyblxuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBzeW1saW5rLCBidXQgd2UgZGlkbid0IGdldCBoZXJlIGJ5IHdheSBvZiBhXG4gICAgICAgICAgICAgICAgLy8gZ2xvYnN0YXIgbWF0Y2ggKG1lYW5pbmcgaXQncyB0aGUgZmlyc3QgdGltZSBUSElTIGdsb2JzdGFyXG4gICAgICAgICAgICAgICAgLy8gaGFzIHRyYXZlcnNlZCBhIHN5bWxpbmspLCB0aGVuIHdlIGZvbGxvdyBpdC4gT3RoZXJ3aXNlLCBzdG9wLlxuICAgICAgICAgICAgICAgIGlmICghdC5pc1N5bWJvbGljTGluaygpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9sbG93IHx8XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uY2hlY2tGb2xsb3dHbG9ic3RhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHQsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBycCA9IHJlc3Q/LnBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBycmVzdCA9IHJlc3Q/LnJlc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3QgfHwgKChycCA9PT0gJycgfHwgcnAgPT09ICcuJykgJiYgIXJyZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IEhBUyB0byBiZSBhIGRpciBpZiBpdCBlbmRzIGluICoqLyBvciAqKi8uXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBlbmRpbmcgaW4gKiogd2lsbCBtYXRjaCBmaWxlcyBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHQsIGFic29sdXRlLCBycCA9PT0gJycgfHwgcnAgPT09ICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnAgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd291bGQgbWVhbiB5b3UncmUgbWF0Y2hpbmcgKiovLi4gYXQgdGhlIGZzIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbm8gdGhhbmtzLCBJJ20gbm90IGdvbm5hIHRlc3QgdGhhdCBzcGVjaWZpYyBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cCA9IHQucGFyZW50IHx8IHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFycmVzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKHRwLCBhYnNvbHV0ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5oYXNXYWxrZWRDYWNoZS5oYXNXYWxrZWQodHAsIHJyZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKHRwLCBycmVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQodCwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN1YndhbGtUYXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ3YWxrcy5rZXlzKCk7XG4gICAgfVxuICAgIGNoaWxkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3Nvcih0aGlzLm9wdHMsIHRoaXMuaGFzV2Fsa2VkQ2FjaGUpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gYSBuZXcgUHJvY2Vzc29yIGNvbnRhaW5pbmcgdGhlIHN1YndhbGtzIGZvciBlYWNoXG4gICAgLy8gY2hpbGQgZW50cnksIGFuZCBhIHNldCBvZiBtYXRjaGVzLCBhbmRcbiAgICAvLyBhIGhhc1dhbGtlZENhY2hlIHRoYXQncyBhIGNvcHkgb2YgdGhpcyBvbmVcbiAgICAvLyB0aGVuIHdlJ3JlIGdvaW5nIHRvIGNhbGxcbiAgICBmaWx0ZXJFbnRyaWVzKHBhcmVudCwgZW50cmllcykge1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IHRoaXMuc3Vid2Fsa3MuZ2V0KHBhcmVudCk7XG4gICAgICAgIC8vIHB1dCBtYXRjaGVzIGFuZCBlbnRyeSB3YWxrcyBpbnRvIHRoZSByZXN1bHRzIHByb2Nlc3NvclxuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5jaGlsZCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGUgPSBwYXR0ZXJuLmlzQWJzb2x1dGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGF0dGVybi5wYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhdHRlcm4ucmVzdCgpO1xuICAgICAgICAgICAgICAgIGlmIChwID09PSBtaW5pbWF0Y2hfMS5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnRlc3RHbG9ic3RhcihlLCBwYXR0ZXJuLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy50ZXN0UmVnRXhwKGUsIHAsIHJlc3QsIGFic29sdXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMudGVzdFN0cmluZyhlLCBwLCByZXN0LCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICB0ZXN0R2xvYnN0YXIoZSwgcGF0dGVybiwgcmVzdCwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZG90IHx8ICFlLm5hbWUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICBpZiAoIXBhdHRlcm4uaGFzTW9yZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzLmFkZChlLCBhYnNvbHV0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gZm9sbG93IG1vZGUgb3IgaXQncyBub3QgYSBzeW1saW5rLCBqdXN0IGtlZXBcbiAgICAgICAgICAgICAgICAvLyB0ZXN0aW5nIHRoZSBzYW1lIHBhdHRlcm4uIElmIHRoZXJlJ3MgbW9yZSBhZnRlciB0aGUgZ2xvYnN0YXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB0aGlzIHN5bWxpbmsgY29uc3VtZXMgdGhlIGdsb2JzdGFyLiBJZiBub3QsIHRoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gZm9sbG93IGF0IG1vc3QgT05FIHN5bWxpbmsgYWxvbmcgdGhlIHdheSwgc28gd2UgbWFyayBpdCwgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBhbHNvIGNoZWNrcyB0byBlbnN1cmUgdGhhdCBpdCB3YXNuJ3QgYWxyZWFkeSBtYXJrZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9sbG93IHx8ICFlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCAmJiBwYXR0ZXJuLmNoZWNrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0dGVybi5tYXJrRm9sbG93R2xvYnN0YXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ3YWxrcy5hZGQoZSwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIE5FWFQgdGhpbmcgbWF0Y2hlcyB0aGlzIGVudHJ5LCB0aGVuIGFsc28gYWRkXG4gICAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgY29uc3QgcnAgPSByZXN0LnBhdHRlcm4oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnAgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgLy8gZG90cyBhbmQgZW1wdHkgd2VyZSBoYW5kbGVkIGFscmVhZHlcbiAgICAgICAgICAgICAgICBycCAhPT0gJy4uJyAmJlxuICAgICAgICAgICAgICAgIHJwICE9PSAnJyAmJlxuICAgICAgICAgICAgICAgIHJwICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RTdHJpbmcoZSwgcnAsIHJlc3QucmVzdCgpLCBhYnNvbHV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChycCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGVwID0gZS5wYXJlbnQgfHwgZTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGVwLCByZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0UmVnRXhwKGUsIHJwLCByZXN0LnJlc3QoKSwgYWJzb2x1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRlc3RSZWdFeHAoZSwgcCwgcmVzdCwgYWJzb2x1dGUpIHtcbiAgICAgICAgaWYgKCFwLnRlc3QoZS5uYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZXMuYWRkKGUsIGFic29sdXRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN1YndhbGtzLmFkZChlLCByZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0ZXN0U3RyaW5nKGUsIHAsIHJlc3QsIGFic29sdXRlKSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4/XG4gICAgICAgIGlmICghZS5pc05hbWVkKHApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJlc3QpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSwgYWJzb2x1dGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3Vid2Fsa3MuYWRkKGUsIHJlc3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzb3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUHJvY2Vzc29yIiwiU3ViV2Fsa3MiLCJNYXRjaFJlY29yZCIsIkhhc1dhbGtlZENhY2hlIiwibWluaW1hdGNoXzEiLCJyZXF1aXJlIiwiY29uc3RydWN0b3IiLCJzdG9yZSIsIk1hcCIsImNvcHkiLCJoYXNXYWxrZWQiLCJ0YXJnZXQiLCJwYXR0ZXJuIiwiZ2V0IiwiZnVsbHBhdGgiLCJoYXMiLCJnbG9iU3RyaW5nIiwic3RvcmVXYWxrZWQiLCJjYWNoZWQiLCJhZGQiLCJzZXQiLCJTZXQiLCJhYnNvbHV0ZSIsImlmRGlyIiwibiIsImN1cnJlbnQiLCJ1bmRlZmluZWQiLCJlbnRyaWVzIiwibWFwIiwicGF0aCIsImNhblJlYWRkaXIiLCJzdWJzIiwiZmluZCIsInAiLCJwdXNoIiwiRXJyb3IiLCJrZXlzIiwiayIsImZpbHRlciIsInQiLCJvcHRzIiwiaGFzV2Fsa2VkQ2FjaGUiLCJtYXRjaGVzIiwic3Vid2Fsa3MiLCJmb2xsb3ciLCJkb3QiLCJwcm9jZXNzUGF0dGVybnMiLCJwYXR0ZXJucyIsInByb2Nlc3NpbmdTZXQiLCJyb290IiwiaXNBYnNvbHV0ZSIsInJlc29sdmUiLCJyZXN0IiwiaXNFTk9FTlQiLCJjaGFuZ2VkIiwiYyIsIkdMT0JTVEFSIiwiaXNTeW1ib2xpY0xpbmsiLCJjaGVja0ZvbGxvd0dsb2JzdGFyIiwicnAiLCJycmVzdCIsInRwIiwicGFyZW50IiwiUmVnRXhwIiwic3Vid2Fsa1RhcmdldHMiLCJjaGlsZCIsImZpbHRlckVudHJpZXMiLCJyZXN1bHRzIiwiZSIsInRlc3RHbG9ic3RhciIsInRlc3RSZWdFeHAiLCJ0ZXN0U3RyaW5nIiwibmFtZSIsInN0YXJ0c1dpdGgiLCJoYXNNb3JlIiwibWFya0ZvbGxvd0dsb2JzdGFyIiwiZXAiLCJ0ZXN0IiwiaXNOYW1lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/dist/commonjs/walker.js":
/*!***************************************************!*\
  !*** ./node_modules/glob/dist/commonjs/walker.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */ const minipass_1 = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/commonjs/index.js\");\nconst ignore_js_1 = __webpack_require__(/*! ./ignore.js */ \"(rsc)/./node_modules/glob/dist/commonjs/ignore.js\");\nconst processor_js_1 = __webpack_require__(/*! ./processor.js */ \"(rsc)/./node_modules/glob/dist/commonjs/processor.js\");\nconst makeIgnore = (ignore, opts)=>typeof ignore === \"string\" ? new ignore_js_1.Ignore([\n        ignore\n    ], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */ class GlobUtil {\n    #onResume;\n    #ignore;\n    #sep;\n    constructor(patterns, path, opts){\n        this.seen = new Set();\n        this.paused = false;\n        this.aborted = false;\n        this.#onResume = [];\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === \"win32\" ? \"\\\\\" : \"/\";\n        this.includeChildMatches = opts.includeChildMatches !== false;\n        if (opts.ignore || !this.includeChildMatches) {\n            this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n            if (!this.includeChildMatches && typeof this.#ignore.add !== \"function\") {\n                const m = \"cannot ignore child matches, ignore lacks add() method.\";\n                throw new Error(m);\n            }\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */ this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */ if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener(\"abort\", ()=>{\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */ if (this.signal?.aborted) return;\n        /* c8 ignore stop */ this.paused = false;\n        let fn = undefined;\n        while(!this.paused && (fn = this.#onResume.shift())){\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted) return;\n        /* c8 ignore start */ if (!this.paused) {\n            fn();\n        } else {\n            /* c8 ignore stop */ this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir) return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || await e.realpath();\n            if (!rpc) return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? await e.lstat() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = await s.realpath();\n            /* c8 ignore start */ if (target && (target.isUnknown() || this.opts.stat)) {\n                await target.lstat();\n            }\n        /* c8 ignore stop */ }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir) return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc) return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        const s = needStat ? e.lstatSync() : e;\n        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n            const target = s.realpathSync();\n            if (target && (target?.isUnknown() || this.opts.stat)) {\n                target.lstatSync();\n            }\n        }\n        return this.matchCheckTest(s, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e)) return;\n        // we know we have an ignore if this is false, but TS doesn't\n        if (!this.includeChildMatches && this.#ignore?.add) {\n            const ign = `${e.relativePosix()}/**`;\n            this.#ignore.add(ign);\n        }\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : \"\";\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        } else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        } else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith(\"..\" + this.#sep) ? \".\" + this.#sep : \"\";\n            this.matchEmit(!rel ? \".\" + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p) this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p) this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */ if (this.signal?.aborted) cb();\n        /* c8 ignore stop */ this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target)) return cb();\n        if (this.signal?.aborted) cb();\n        if (this.paused) {\n            this.onResume(()=>this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = ()=>{\n            if (--tasks === 0) cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()){\n            if (this.#ignored(m)) continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(()=>next());\n        }\n        for (const t of processor.subwalkTargets()){\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir()) this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries)=>this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = ()=>{\n            if (--tasks === 0) cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()){\n            if (this.#ignored(m)) continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(()=>next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()){\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */ if (this.signal?.aborted) cb();\n        /* c8 ignore stop */ this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target)) return cb();\n        if (this.signal?.aborted) cb();\n        if (this.paused) {\n            this.onResume(()=>this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = ()=>{\n            if (--tasks === 0) cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()){\n            if (this.#ignored(m)) continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()){\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = ()=>{\n            if (--tasks === 0) cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()){\n            if (this.#ignored(m)) continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()){\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nexports.GlobUtil = GlobUtil;\nclass GlobWalker extends GlobUtil {\n    constructor(patterns, path, opts){\n        super(patterns, path, opts);\n        this.matches = new Set();\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted) throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej)=>{\n            this.walkCB(this.path, this.patterns, ()=>{\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                } else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted) throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, ()=>{\n            if (this.signal?.aborted) throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nexports.GlobWalker = GlobWalker;\nclass GlobStream extends GlobUtil {\n    constructor(patterns, path, opts){\n        super(patterns, path, opts);\n        this.results = new minipass_1.Minipass({\n            signal: this.signal,\n            objectMode: true\n        });\n        this.results.on(\"drain\", ()=>this.resume());\n        this.results.on(\"resume\", ()=>this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing) this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(()=>{\n                this.walkCB(target, this.patterns, ()=>this.results.end());\n            });\n        } else {\n            this.walkCB(target, this.patterns, ()=>this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, ()=>this.results.end());\n        return this.results;\n    }\n}\nexports.GlobStream = GlobStream; //# sourceMappingURL=walker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9kaXN0L2NvbW1vbmpzL3dhbGtlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLGtCQUFrQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ2xFOzs7OztDQUtDLEdBQ0QsTUFBTUssYUFBYUMsbUJBQU9BLENBQUMsc0VBQVU7QUFDckMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsc0VBQWE7QUFDekMsTUFBTUUsaUJBQWlCRixtQkFBT0EsQ0FBQyw0RUFBZ0I7QUFDL0MsTUFBTUcsYUFBYSxDQUFDQyxRQUFRQyxPQUFTLE9BQU9ELFdBQVcsV0FBVyxJQUFJSCxZQUFZSyxNQUFNLENBQUM7UUFBQ0Y7S0FBTyxFQUFFQyxRQUM3RkUsTUFBTUMsT0FBTyxDQUFDSixVQUFVLElBQUlILFlBQVlLLE1BQU0sQ0FBQ0YsUUFBUUMsUUFDbkREO0FBQ1Y7O0NBRUMsR0FDRCxNQUFNTjtJQU9GLENBQUNXLFFBQVEsQ0FBTTtJQUNmLENBQUNMLE1BQU0sQ0FBQztJQUNSLENBQUNNLEdBQUcsQ0FBQztJQUlMQyxZQUFZQyxRQUFRLEVBQUVDLElBQUksRUFBRVIsSUFBSSxDQUFFO2FBVGxDUyxPQUFPLElBQUlDO2FBQ1hDLFNBQVM7YUFDVEMsVUFBVTthQUNWLENBQUNSLFFBQVEsR0FBRyxFQUFFO1FBT1YsSUFBSSxDQUFDRyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ1IsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQyxDQUFDSyxHQUFHLEdBQUcsQ0FBQ0wsS0FBS2EsS0FBSyxJQUFJYixLQUFLYyxRQUFRLEtBQUssVUFBVSxPQUFPO1FBQzlELElBQUksQ0FBQ0MsbUJBQW1CLEdBQUdmLEtBQUtlLG1CQUFtQixLQUFLO1FBQ3hELElBQUlmLEtBQUtELE1BQU0sSUFBSSxDQUFDLElBQUks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TixTQUFTLElBQUk7WUFDcEJNLE9BQU9ILEtBQUssR0FBR3VDLElBQUksQ0FBQztnQkFDaEIsSUFBSSxDQUFDVixNQUFNLENBQUMxQixRQUFRLElBQUksQ0FBQ3hDLFFBQVEsRUFBRSxJQUFNLElBQUksQ0FBQ21HLE9BQU8sQ0FBQ08sR0FBRztZQUM3RDtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUN4QyxNQUFNLENBQUMxQixRQUFRLElBQUksQ0FBQ3hDLFFBQVEsRUFBRSxJQUFNLElBQUksQ0FBQ21HLE9BQU8sQ0FBQ08sR0FBRztRQUM3RDtRQUNBLE9BQU8sSUFBSSxDQUFDUCxPQUFPO0lBQ3ZCO0lBQ0FRLGFBQWE7UUFDVCxJQUFJLElBQUksQ0FBQzFHLElBQUksQ0FBQ2lDLFNBQVMsSUFBSTtZQUN2QixJQUFJLENBQUNqQyxJQUFJLENBQUM4QyxTQUFTO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDeUMsVUFBVSxDQUFDLElBQUksQ0FBQ3ZGLElBQUksRUFBRSxJQUFJLENBQUNELFFBQVEsRUFBRSxJQUFNLElBQUksQ0FBQ21HLE9BQU8sQ0FBQ08sR0FBRztRQUNoRSxPQUFPLElBQUksQ0FBQ1AsT0FBTztJQUN2QjtBQUNKO0FBQ0FySCxrQkFBa0IsR0FBR0UsWUFDckIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGhvdG8tc2t1LXByb2Nlc3Nvci8uL25vZGVfbW9kdWxlcy9nbG9iL2Rpc3QvY29tbW9uanMvd2Fsa2VyLmpzPzA0ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdsb2JTdHJlYW0gPSBleHBvcnRzLkdsb2JXYWxrZXIgPSBleHBvcnRzLkdsb2JVdGlsID0gdm9pZCAwO1xuLyoqXG4gKiBTaW5nbGUtdXNlIHV0aWxpdHkgY2xhc3NlcyB0byBwcm92aWRlIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIHtAbGluayBHbG9ifVxuICogbWV0aG9kcy5cbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IG1pbmlwYXNzXzEgPSByZXF1aXJlKFwibWluaXBhc3NcIik7XG5jb25zdCBpZ25vcmVfanNfMSA9IHJlcXVpcmUoXCIuL2lnbm9yZS5qc1wiKTtcbmNvbnN0IHByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vcHJvY2Vzc29yLmpzXCIpO1xuY29uc3QgbWFrZUlnbm9yZSA9IChpZ25vcmUsIG9wdHMpID0+IHR5cGVvZiBpZ25vcmUgPT09ICdzdHJpbmcnID8gbmV3IGlnbm9yZV9qc18xLklnbm9yZShbaWdub3JlXSwgb3B0cylcbiAgICA6IEFycmF5LmlzQXJyYXkoaWdub3JlKSA/IG5ldyBpZ25vcmVfanNfMS5JZ25vcmUoaWdub3JlLCBvcHRzKVxuICAgICAgICA6IGlnbm9yZTtcbi8qKlxuICogYmFzaWMgd2Fsa2luZyB1dGlsaXRpZXMgdGhhdCBhbGwgdGhlIGdsb2Igd2Fsa2VyIHR5cGVzIHVzZVxuICovXG5jbGFzcyBHbG9iVXRpbCB7XG4gICAgcGF0aDtcbiAgICBwYXR0ZXJucztcbiAgICBvcHRzO1xuICAgIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgYWJvcnRlZCA9IGZhbHNlO1xuICAgICNvblJlc3VtZSA9IFtdO1xuICAgICNpZ25vcmU7XG4gICAgI3NlcDtcbiAgICBzaWduYWw7XG4gICAgbWF4RGVwdGg7XG4gICAgaW5jbHVkZUNoaWxkTWF0Y2hlcztcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICB0aGlzLnBhdHRlcm5zID0gcGF0dGVybnM7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuI3NlcCA9ICFvcHRzLnBvc2l4ICYmIG9wdHMucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnXFxcXCcgOiAnLyc7XG4gICAgICAgIHRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyA9IG9wdHMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAhPT0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRzLmlnbm9yZSB8fCAhdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLiNpZ25vcmUgPSBtYWtlSWdub3JlKG9wdHMuaWdub3JlID8/IFtdLCBvcHRzKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbmNsdWRlQ2hpbGRNYXRjaGVzICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMuI2lnbm9yZS5hZGQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gJ2Nhbm5vdCBpZ25vcmUgY2hpbGQgbWF0Y2hlcywgaWdub3JlIGxhY2tzIGFkZCgpIG1ldGhvZC4nO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZ25vcmUsIGFsd2F5cyBzZXQgd2l0aCBtYXhEZXB0aCwgYnV0IGl0J3Mgb3B0aW9uYWwgb24gdGhlXG4gICAgICAgIC8vIEdsb2JPcHRpb25zIHR5cGVcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIHRoaXMubWF4RGVwdGggPSBvcHRzLm1heERlcHRoIHx8IEluZmluaXR5O1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAob3B0cy5zaWduYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsID0gb3B0cy5zaWduYWw7XG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNvblJlc3VtZS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2lnbm9yZWQocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWVuLmhhcyhwYXRoKSB8fCAhIXRoaXMuI2lnbm9yZT8uaWdub3JlZD8uKHBhdGgpO1xuICAgIH1cbiAgICAjY2hpbGRyZW5JZ25vcmVkKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4jaWdub3JlPy5jaGlsZHJlbklnbm9yZWQ/LihwYXRoKTtcbiAgICB9XG4gICAgLy8gYmFja3ByZXNzdXJlIG1lY2hhbmlzbVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZuID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZSAoIXRoaXMucGF1c2VkICYmIChmbiA9IHRoaXMuI29uUmVzdW1lLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVzdW1lKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jb25SZXN1bWUucHVzaChmbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZG8gdGhlIHJlcXVpc2l0ZSByZWFscGF0aC9zdGF0IGNoZWNraW5nLCBhbmQgcmV0dXJuIHRoZSBwYXRoXG4gICAgLy8gdG8gYWRkIG9yIHVuZGVmaW5lZCB0byBmaWx0ZXIgaXQgb3V0LlxuICAgIGFzeW5jIG1hdGNoQ2hlY2soZSwgaWZEaXIpIHtcbiAgICAgICAgaWYgKGlmRGlyICYmIHRoaXMub3B0cy5ub2RpcilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBycGM7XG4gICAgICAgIGlmICh0aGlzLm9wdHMucmVhbHBhdGgpIHtcbiAgICAgICAgICAgIHJwYyA9IGUucmVhbHBhdGhDYWNoZWQoKSB8fCAoYXdhaXQgZS5yZWFscGF0aCgpKTtcbiAgICAgICAgICAgIGlmICghcnBjKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlID0gcnBjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRTdGF0ID0gZS5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdDtcbiAgICAgICAgY29uc3QgcyA9IG5lZWRTdGF0ID8gYXdhaXQgZS5sc3RhdCgpIDogZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5mb2xsb3cgJiYgdGhpcy5vcHRzLm5vZGlyICYmIHM/LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IHMucmVhbHBhdGgoKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodGFyZ2V0LmlzVW5rbm93bigpIHx8IHRoaXMub3B0cy5zdGF0KSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRhcmdldC5sc3RhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaENoZWNrVGVzdChzLCBpZkRpcik7XG4gICAgfVxuICAgIG1hdGNoQ2hlY2tUZXN0KGUsIGlmRGlyKSB7XG4gICAgICAgIHJldHVybiAoZSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4RGVwdGggPT09IEluZmluaXR5IHx8IGUuZGVwdGgoKSA8PSB0aGlzLm1heERlcHRoKSAmJlxuICAgICAgICAgICAgKCFpZkRpciB8fCBlLmNhblJlYWRkaXIoKSkgJiZcbiAgICAgICAgICAgICghdGhpcy5vcHRzLm5vZGlyIHx8ICFlLmlzRGlyZWN0b3J5KCkpICYmXG4gICAgICAgICAgICAoIXRoaXMub3B0cy5ub2RpciB8fFxuICAgICAgICAgICAgICAgICF0aGlzLm9wdHMuZm9sbG93IHx8XG4gICAgICAgICAgICAgICAgIWUuaXNTeW1ib2xpY0xpbmsoKSB8fFxuICAgICAgICAgICAgICAgICFlLnJlYWxwYXRoQ2FjaGVkKCk/LmlzRGlyZWN0b3J5KCkpICYmXG4gICAgICAgICAgICAhdGhpcy4jaWdub3JlZChlKSkgP1xuICAgICAgICAgICAgZVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG1hdGNoQ2hlY2tTeW5jKGUsIGlmRGlyKSB7XG4gICAgICAgIGlmIChpZkRpciAmJiB0aGlzLm9wdHMubm9kaXIpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcnBjO1xuICAgICAgICBpZiAodGhpcy5vcHRzLnJlYWxwYXRoKSB7XG4gICAgICAgICAgICBycGMgPSBlLnJlYWxwYXRoQ2FjaGVkKCkgfHwgZS5yZWFscGF0aFN5bmMoKTtcbiAgICAgICAgICAgIGlmICghcnBjKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlID0gcnBjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRTdGF0ID0gZS5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdDtcbiAgICAgICAgY29uc3QgcyA9IG5lZWRTdGF0ID8gZS5sc3RhdFN5bmMoKSA6IGU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZm9sbG93ICYmIHRoaXMub3B0cy5ub2RpciAmJiBzPy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBzLnJlYWxwYXRoU3luYygpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodGFyZ2V0Py5pc1Vua25vd24oKSB8fCB0aGlzLm9wdHMuc3RhdCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQubHN0YXRTeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hDaGVja1Rlc3QocywgaWZEaXIpO1xuICAgIH1cbiAgICBtYXRjaEZpbmlzaChlLCBhYnNvbHV0ZSkge1xuICAgICAgICBpZiAodGhpcy4jaWdub3JlZChlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gd2Uga25vdyB3ZSBoYXZlIGFuIGlnbm9yZSBpZiB0aGlzIGlzIGZhbHNlLCBidXQgVFMgZG9lc24ndFxuICAgICAgICBpZiAoIXRoaXMuaW5jbHVkZUNoaWxkTWF0Y2hlcyAmJiB0aGlzLiNpZ25vcmU/LmFkZCkge1xuICAgICAgICAgICAgY29uc3QgaWduID0gYCR7ZS5yZWxhdGl2ZVBvc2l4KCl9LyoqYDtcbiAgICAgICAgICAgIHRoaXMuI2lnbm9yZS5hZGQoaWduKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYnMgPSB0aGlzLm9wdHMuYWJzb2x1dGUgPT09IHVuZGVmaW5lZCA/IGFic29sdXRlIDogdGhpcy5vcHRzLmFic29sdXRlO1xuICAgICAgICB0aGlzLnNlZW4uYWRkKGUpO1xuICAgICAgICBjb25zdCBtYXJrID0gdGhpcy5vcHRzLm1hcmsgJiYgZS5pc0RpcmVjdG9yeSgpID8gdGhpcy4jc2VwIDogJyc7XG4gICAgICAgIC8vIG9rLCB3ZSBoYXZlIHdoYXQgd2UgbmVlZCFcbiAgICAgICAgaWYgKHRoaXMub3B0cy53aXRoRmlsZVR5cGVzKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdChlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhYnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFicyA9IHRoaXMub3B0cy5wb3NpeCA/IGUuZnVsbHBhdGhQb3NpeCgpIDogZS5mdWxscGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5tYXRjaEVtaXQoYWJzICsgbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZWwgPSB0aGlzLm9wdHMucG9zaXggPyBlLnJlbGF0aXZlUG9zaXgoKSA6IGUucmVsYXRpdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZSA9IHRoaXMub3B0cy5kb3RSZWxhdGl2ZSAmJiAhcmVsLnN0YXJ0c1dpdGgoJy4uJyArIHRoaXMuI3NlcCkgP1xuICAgICAgICAgICAgICAgICcuJyArIHRoaXMuI3NlcFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoRW1pdCghcmVsID8gJy4nICsgbWFyayA6IHByZSArIHJlbCArIG1hcmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1hdGNoKGUsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBwID0gYXdhaXQgdGhpcy5tYXRjaENoZWNrKGUsIGlmRGlyKTtcbiAgICAgICAgaWYgKHApXG4gICAgICAgICAgICB0aGlzLm1hdGNoRmluaXNoKHAsIGFic29sdXRlKTtcbiAgICB9XG4gICAgbWF0Y2hTeW5jKGUsIGFic29sdXRlLCBpZkRpcikge1xuICAgICAgICBjb25zdCBwID0gdGhpcy5tYXRjaENoZWNrU3luYyhlLCBpZkRpcik7XG4gICAgICAgIGlmIChwKVxuICAgICAgICAgICAgdGhpcy5tYXRjaEZpbmlzaChwLCBhYnNvbHV0ZSk7XG4gICAgfVxuICAgIHdhbGtDQih0YXJnZXQsIHBhdHRlcm5zLCBjYikge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy53YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIG5ldyBwcm9jZXNzb3JfanNfMS5Qcm9jZXNzb3IodGhpcy5vcHRzKSwgY2IpO1xuICAgIH1cbiAgICB3YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NoaWxkcmVuSWdub3JlZCh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblJlc3VtZSgoKSA9PiB0aGlzLndhbGtDQjIodGFyZ2V0LCBwYXR0ZXJucywgcHJvY2Vzc29yLCBjYikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzUGF0dGVybnModGFyZ2V0LCBwYXR0ZXJucyk7XG4gICAgICAgIC8vIGRvbmUgcHJvY2Vzc2luZy4gIGFsbCBvZiB0aGUgYWJvdmUgaXMgc3luYywgY2FuIGJlIGFic3RyYWN0ZWQgb3V0LlxuICAgICAgICAvLyBzdWJ3YWxrcyBpcyBhIG1hcCBvZiBwYXRocyB0byB0aGUgZW50cnkgZmlsdGVycyB0aGV5IG5lZWRcbiAgICAgICAgLy8gbWF0Y2hlcyBpcyBhIG1hcCBvZiBwYXRocyB0byBbYWJzb2x1dGUsIGlmRGlyXSB0dXBsZXMuXG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChtLCBhYnNvbHV0ZSwgaWZEaXIpLnRoZW4oKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgcHJvY2Vzc29yLnN1YndhbGtUYXJnZXRzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSAmJiB0LmRlcHRoKCkgPj0gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuQ2FjaGVkID0gdC5yZWFkZGlyQ2FjaGVkKCk7XG4gICAgICAgICAgICBpZiAodC5jYWxsZWRSZWFkZGlyKCkpXG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQ0IzKHQsIGNoaWxkcmVuQ2FjaGVkLCBwcm9jZXNzb3IsIG5leHQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5yZWFkZGlyQ0IoKF8sIGVudHJpZXMpID0+IHRoaXMud2Fsa0NCMyh0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIG5leHQpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQjModGFyZ2V0LCBlbnRyaWVzLCBwcm9jZXNzb3IsIGNiKSB7XG4gICAgICAgIHByb2Nlc3NvciA9IHByb2Nlc3Nvci5maWx0ZXJFbnRyaWVzKHRhcmdldCwgZW50cmllcyk7XG4gICAgICAgIGxldCB0YXNrcyA9IDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoLS10YXNrcyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IFttLCBhYnNvbHV0ZSwgaWZEaXJdIG9mIHByb2Nlc3Nvci5tYXRjaGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lnbm9yZWQobSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy5tYXRjaChtLCBhYnNvbHV0ZSwgaWZEaXIpLnRoZW4oKCkgPT4gbmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXQsIHBhdHRlcm5zXSBvZiBwcm9jZXNzb3Iuc3Vid2Fsa3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IyKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3Nvci5jaGlsZCgpLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQlN5bmModGFyZ2V0LCBwYXR0ZXJucywgY2IpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMud2Fsa0NCMlN5bmModGFyZ2V0LCBwYXR0ZXJucywgbmV3IHByb2Nlc3Nvcl9qc18xLlByb2Nlc3Nvcih0aGlzLm9wdHMpLCBjYik7XG4gICAgfVxuICAgIHdhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpIHtcbiAgICAgICAgaWYgKHRoaXMuI2NoaWxkcmVuSWdub3JlZCh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblJlc3VtZSgoKSA9PiB0aGlzLndhbGtDQjJTeW5jKHRhcmdldCwgcGF0dGVybnMsIHByb2Nlc3NvciwgY2IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzb3IucHJvY2Vzc1BhdHRlcm5zKHRhcmdldCwgcGF0dGVybnMpO1xuICAgICAgICAvLyBkb25lIHByb2Nlc3NpbmcuICBhbGwgb2YgdGhlIGFib3ZlIGlzIHN5bmMsIGNhbiBiZSBhYnN0cmFjdGVkIG91dC5cbiAgICAgICAgLy8gc3Vid2Fsa3MgaXMgYSBtYXAgb2YgcGF0aHMgdG8gdGhlIGVudHJ5IGZpbHRlcnMgdGhleSBuZWVkXG4gICAgICAgIC8vIG1hdGNoZXMgaXMgYSBtYXAgb2YgcGF0aHMgdG8gW2Fic29sdXRlLCBpZkRpcl0gdHVwbGVzLlxuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5tYXRjaFN5bmMobSwgYWJzb2x1dGUsIGlmRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgcHJvY2Vzc29yLnN1YndhbGtUYXJnZXRzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoICE9PSBJbmZpbml0eSAmJiB0LmRlcHRoKCkgPj0gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFza3MrKztcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdC5yZWFkZGlyU3luYygpO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IzU3luYyh0LCBjaGlsZHJlbiwgcHJvY2Vzc29yLCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfVxuICAgIHdhbGtDQjNTeW5jKHRhcmdldCwgZW50cmllcywgcHJvY2Vzc29yLCBjYikge1xuICAgICAgICBwcm9jZXNzb3IgPSBwcm9jZXNzb3IuZmlsdGVyRW50cmllcyh0YXJnZXQsIGVudHJpZXMpO1xuICAgICAgICBsZXQgdGFza3MgPSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKC0tdGFza3MgPT09IDApXG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBbbSwgYWJzb2x1dGUsIGlmRGlyXSBvZiBwcm9jZXNzb3IubWF0Y2hlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpZ25vcmVkKG0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5tYXRjaFN5bmMobSwgYWJzb2x1dGUsIGlmRGlyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXQsIHBhdHRlcm5zXSBvZiBwcm9jZXNzb3Iuc3Vid2Fsa3MuZW50cmllcygpKSB7XG4gICAgICAgICAgICB0YXNrcysrO1xuICAgICAgICAgICAgdGhpcy53YWxrQ0IyU3luYyh0YXJnZXQsIHBhdHRlcm5zLCBwcm9jZXNzb3IuY2hpbGQoKSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2xvYlV0aWwgPSBHbG9iVXRpbDtcbmNsYXNzIEdsb2JXYWxrZXIgZXh0ZW5kcyBHbG9iVXRpbCB7XG4gICAgbWF0Y2hlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICBzdXBlcihwYXR0ZXJucywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIG1hdGNoRW1pdChlKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcy5hZGQoZSk7XG4gICAgfVxuICAgIGFzeW5jIHdhbGsoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZ25hbD8uYWJvcnRlZClcbiAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc1Vua25vd24oKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYXRoLmxzdGF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndhbGtDQih0aGlzLnBhdGgsIHRoaXMucGF0dGVybnMsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqKHRoaXMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXModGhpcy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXM7XG4gICAgfVxuICAgIHdhbGtTeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduYWw/LmFib3J0ZWQpXG4gICAgICAgICAgICB0aHJvdyB0aGlzLnNpZ25hbC5yZWFzb247XG4gICAgICAgIGlmICh0aGlzLnBhdGguaXNVbmtub3duKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aC5sc3RhdFN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RoaW5nIGZvciB0aGUgY2FsbGJhY2sgdG8gZG8sIGJlY2F1c2UgdGhpcyBuZXZlciBwYXVzZXNcbiAgICAgICAgdGhpcy53YWxrQ0JTeW5jKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsPy5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXM7XG4gICAgfVxufVxuZXhwb3J0cy5HbG9iV2Fsa2VyID0gR2xvYldhbGtlcjtcbmNsYXNzIEdsb2JTdHJlYW0gZXh0ZW5kcyBHbG9iVXRpbCB7XG4gICAgcmVzdWx0cztcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJucywgcGF0aCwgb3B0cykge1xuICAgICAgICBzdXBlcihwYXR0ZXJucywgcGF0aCwgb3B0cyk7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IG5ldyBtaW5pcGFzc18xLk1pbmlwYXNzKHtcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXN1bHRzLm9uKCdkcmFpbicsICgpID0+IHRoaXMucmVzdW1lKCkpO1xuICAgICAgICB0aGlzLnJlc3VsdHMub24oJ3Jlc3VtZScsICgpID0+IHRoaXMucmVzdW1lKCkpO1xuICAgIH1cbiAgICBtYXRjaEVtaXQoZSkge1xuICAgICAgICB0aGlzLnJlc3VsdHMud3JpdGUoZSk7XG4gICAgICAgIGlmICghdGhpcy5yZXN1bHRzLmZsb3dpbmcpXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICAgIHN0cmVhbSgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICB0YXJnZXQubHN0YXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtDQih0YXJnZXQsIHRoaXMucGF0dGVybnMsICgpID0+IHRoaXMucmVzdWx0cy5lbmQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2Fsa0NCKHRhcmdldCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzO1xuICAgIH1cbiAgICBzdHJlYW1TeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoLmlzVW5rbm93bigpKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGgubHN0YXRTeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWxrQ0JTeW5jKHRoaXMucGF0aCwgdGhpcy5wYXR0ZXJucywgKCkgPT4gdGhpcy5yZXN1bHRzLmVuZCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0cztcbiAgICB9XG59XG5leHBvcnRzLkdsb2JTdHJlYW0gPSBHbG9iU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Fsa2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkdsb2JTdHJlYW0iLCJHbG9iV2Fsa2VyIiwiR2xvYlV0aWwiLCJtaW5pcGFzc18xIiwicmVxdWlyZSIsImlnbm9yZV9qc18xIiwicHJvY2Vzc29yX2pzXzEiLCJtYWtlSWdub3JlIiwiaWdub3JlIiwib3B0cyIsIklnbm9yZSIsIkFycmF5IiwiaXNBcnJheSIsIm9uUmVzdW1lIiwic2VwIiwiY29uc3RydWN0b3IiLCJwYXR0ZXJucyIsInBhdGgiLCJzZWVuIiwiU2V0IiwicGF1c2VkIiwiYWJvcnRlZCIsInBvc2l4IiwicGxhdGZvcm0iLCJpbmNsdWRlQ2hpbGRNYXRjaGVzIiwiYWRkIiwibSIsIkVycm9yIiwibWF4RGVwdGgiLCJJbmZpbml0eSIsInNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJsZW5ndGgiLCJpZ25vcmVkIiwiaGFzIiwiY2hpbGRyZW5JZ25vcmVkIiwicGF1c2UiLCJyZXN1bWUiLCJmbiIsInVuZGVmaW5lZCIsInNoaWZ0IiwicHVzaCIsIm1hdGNoQ2hlY2siLCJlIiwiaWZEaXIiLCJub2RpciIsInJwYyIsInJlYWxwYXRoIiwicmVhbHBhdGhDYWNoZWQiLCJuZWVkU3RhdCIsImlzVW5rbm93biIsInN0YXQiLCJzIiwibHN0YXQiLCJmb2xsb3ciLCJpc1N5bWJvbGljTGluayIsInRhcmdldCIsIm1hdGNoQ2hlY2tUZXN0IiwiZGVwdGgiLCJjYW5SZWFkZGlyIiwiaXNEaXJlY3RvcnkiLCJtYXRjaENoZWNrU3luYyIsInJlYWxwYXRoU3luYyIsImxzdGF0U3luYyIsIm1hdGNoRmluaXNoIiwiYWJzb2x1dGUiLCJpZ24iLCJyZWxhdGl2ZVBvc2l4IiwiYWJzIiwibWFyayIsIndpdGhGaWxlVHlwZXMiLCJtYXRjaEVtaXQiLCJmdWxscGF0aFBvc2l4IiwiZnVsbHBhdGgiLCJyZWwiLCJyZWxhdGl2ZSIsInByZSIsImRvdFJlbGF0aXZlIiwic3RhcnRzV2l0aCIsIm1hdGNoIiwicCIsIm1hdGNoU3luYyIsIndhbGtDQiIsImNiIiwid2Fsa0NCMiIsIlByb2Nlc3NvciIsInByb2Nlc3NvciIsInByb2Nlc3NQYXR0ZXJucyIsInRhc2tzIiwibmV4dCIsIm1hdGNoZXMiLCJlbnRyaWVzIiwidGhlbiIsInQiLCJzdWJ3YWxrVGFyZ2V0cyIsImNoaWxkcmVuQ2FjaGVkIiwicmVhZGRpckNhY2hlZCIsImNhbGxlZFJlYWRkaXIiLCJ3YWxrQ0IzIiwicmVhZGRpckNCIiwiXyIsImZpbHRlckVudHJpZXMiLCJzdWJ3YWxrcyIsImNoaWxkIiwid2Fsa0NCU3luYyIsIndhbGtDQjJTeW5jIiwiY2hpbGRyZW4iLCJyZWFkZGlyU3luYyIsIndhbGtDQjNTeW5jIiwid2FsayIsInJlYXNvbiIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJ3YWxrU3luYyIsInJlc3VsdHMiLCJNaW5pcGFzcyIsIm9iamVjdE1vZGUiLCJvbiIsIndyaXRlIiwiZmxvd2luZyIsInN0cmVhbSIsImVuZCIsInN0cmVhbVN5bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/dist/commonjs/walker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.assertValidPattern = void 0;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern)=>{\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n};\nexports.assertValidPattern = assertValidPattern; //# sourceMappingURL=assert-valid-pattern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDBCQUEwQixHQUFHLEtBQUs7QUFDbEMsTUFBTUcscUJBQXFCLE9BQU87QUFDbEMsTUFBTUQscUJBQXFCLENBQUNFO0lBQ3hCLElBQUksT0FBT0EsWUFBWSxVQUFVO1FBQzdCLE1BQU0sSUFBSUMsVUFBVTtJQUN4QjtJQUNBLElBQUlELFFBQVFFLE1BQU0sR0FBR0gsb0JBQW9CO1FBQ3JDLE1BQU0sSUFBSUUsVUFBVTtJQUN4QjtBQUNKO0FBQ0FMLDBCQUEwQixHQUFHRSxvQkFDN0IsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGhvdG8tc2t1LXByb2Nlc3Nvci8uL25vZGVfbW9kdWxlcy9nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3NlcnQtdmFsaWQtcGF0dGVybi5qcz84OTBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRWYWxpZFBhdHRlcm4gPSB2b2lkIDA7XG5jb25zdCBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjQ7XG5jb25zdCBhc3NlcnRWYWxpZFBhdHRlcm4gPSAocGF0dGVybikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJyk7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRQYXR0ZXJuID0gYXNzZXJ0VmFsaWRQYXR0ZXJuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LXZhbGlkLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYXNzZXJ0VmFsaWRQYXR0ZXJuIiwiTUFYX1BBVFRFUk5fTEVOR1RIIiwicGF0dGVybiIsIlR5cGVFcnJvciIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js":
/*!***********************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AST = void 0;\nconst brace_expressions_js_1 = __webpack_require__(/*! ./brace-expressions.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js\");\nconst types = new Set([\n    \"!\",\n    \"?\",\n    \"+\",\n    \"*\",\n    \"@\"\n]);\nconst isExtglobType = (c)=>types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = \"(?!(?:^|/)\\\\.\\\\.?(?:$|/))\";\nconst startNoDot = \"(?!\\\\.)\";\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set([\n    \"[\",\n    \".\"\n]);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set([\n    \"..\",\n    \".\"\n]);\nconst reSpecials = new Set(\"().*{}+?[]^$\\\\!\");\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n// any single thing other than /\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + \"+?\";\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    #root;\n    #hasMagic;\n    #uflag;\n    #parts;\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt;\n    constructor(type, parent, options = {}){\n        this.#uflag = false;\n        this.#parts = [];\n        this.#filledNegs = false;\n        this.#emptyExt = false;\n        this.type = type;\n        // extglobs are inherently magical\n        if (type) this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === \"!\" && !this.#root.#filledNegs) this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */ if (this.#hasMagic !== undefined) return this.#hasMagic;\n        /* c8 ignore stop */ for (const p of this.#parts){\n            if (typeof p === \"string\") continue;\n            if (p.type || p.hasMagic) return this.#hasMagic = true;\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined) return this.#toString;\n        if (!this.type) {\n            return this.#toString = this.#parts.map((p)=>String(p)).join(\"\");\n        } else {\n            return this.#toString = this.type + \"(\" + this.#parts.map((p)=>String(p)).join(\"|\") + \")\";\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */ if (this !== this.#root) throw new Error(\"should only call on root\");\n        if (this.#filledNegs) return this;\n        /* c8 ignore stop */ // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while(n = this.#negs.pop()){\n            if (n.type !== \"!\") continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while(pp){\n                for(let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++){\n                    for (const part of n.#parts){\n                        /* c8 ignore start */ if (typeof part === \"string\") {\n                            throw new Error(\"string part in extglob AST??\");\n                        }\n                        /* c8 ignore stop */ part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts){\n            if (p === \"\") continue;\n            /* c8 ignore start */ if (typeof p !== \"string\" && !(p instanceof AST && p.#parent === this)) {\n                throw new Error(\"invalid part: \" + p);\n            }\n            /* c8 ignore stop */ this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null ? this.#parts.slice().map((p)=>typeof p === \"string\" ? p : p.toJSON()) : [\n            this.type,\n            ...this.#parts.map((p)=>p.toJSON())\n        ];\n        if (this.isStart() && !this.type) ret.unshift([]);\n        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === \"!\")) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this) return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart()) return false;\n        if (this.#parentIndex === 0) return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for(let i = 0; i < this.#parentIndex; i++){\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === \"!\")) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this) return true;\n        if (this.#parent?.type === \"!\") return true;\n        if (!this.#parent?.isEnd()) return false;\n        if (!this.type) return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */ const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */ return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === \"string\") this.push(part);\n        else this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts){\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = \"\";\n            while(i < str.length){\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === \"\\\\\") {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === \"^\" || c === \"!\") {\n                            braceNeg = true;\n                        }\n                    } else if (c === \"]\" && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                } else if (c === \"[\") {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === \"(\") {\n                    ast.push(acc);\n                    acc = \"\";\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = \"\";\n        while(i < str.length){\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === \"\\\\\") {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === \"^\" || c === \"!\") {\n                        braceNeg = true;\n                    }\n                } else if (c === \"]\" && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            } else if (c === \"[\") {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === \"(\") {\n                part.push(acc);\n                acc = \"\";\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === \"|\") {\n                part.push(acc);\n                acc = \"\";\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === \")\") {\n                if (acc === \"\" && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = \"\";\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [\n            str.substring(pos - 1)\n        ];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */ if (this !== this.#root) return this.#root.toMMPattern();\n        /* c8 ignore stop */ const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? \"i\" : \"\") + (uflag ? \"u\" : \"\");\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this) this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts.map((p)=>{\n                const [re, _, hasMagic, uflag] = typeof p === \"string\" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            }).join(\"\");\n            let start = \"\";\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === \"string\") {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = // dots are allowed, and the pattern starts with [ or .\n                        dot && aps.has(src.charAt(0)) || // the pattern starts with \\., and then [ or .\n                        src.startsWith(\"\\\\.\") && aps.has(src.charAt(2)) || // the pattern starts with \\.\\., and then [ or .\n                        src.startsWith(\"\\\\.\\\\.\") && aps.has(src.charAt(4));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : \"\";\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = \"\";\n            if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === \"!\") {\n                end = \"(?:$|\\\\/)\";\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                this.#hasMagic = !!this.#hasMagic,\n                this.#uflag\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === \"*\" || this.type === \"+\";\n        // some kind of extglob\n        const start = this.type === \"!\" ? \"(?:(?!(?:\" : \"(?:\";\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== \"!\") {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [\n                s\n            ];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [\n                s,\n                (0, unescape_js_1.unescape)(this.toString()),\n                false,\n                false\n            ];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? \"\" : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = \"\";\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = \"\";\n        if (this.type === \"!\" && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : \"\") + starNoEmpty;\n        } else {\n            const close = this.type === \"!\" ? \"))\" + (this.isStart() && !dot && !allowDot ? startNoDot : \"\") + star + \")\" : this.type === \"@\" ? \")\" : this.type === \"?\" ? \")?\" : this.type === \"+\" && bodyDotAllowed ? \")\" : this.type === \"*\" && bodyDotAllowed ? `)?` : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            this.#hasMagic = !!this.#hasMagic,\n            this.#uflag\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts.map((p)=>{\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */ if (typeof p === \"string\") {\n                throw new Error(\"string type in extglob ast??\");\n            }\n            /* c8 ignore stop */ // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        }).filter((p)=>!(this.isStart() && this.isEnd()) || !!p).join(\"|\");\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = \"\";\n        let uflag = false;\n        for(let i = 0; i < glob.length; i++){\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? \"\\\\\" : \"\") + c;\n                continue;\n            }\n            if (c === \"\\\\\") {\n                if (i === glob.length - 1) {\n                    re += \"\\\\\\\\\";\n                } else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === \"[\") {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === \"*\") {\n                if (noEmpty && glob === \"*\") re += starNoEmpty;\n                else re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === \"?\") {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [\n            re,\n            (0, unescape_js_1.unescape)(glob),\n            !!hasMagic,\n            uflag\n        ];\n    }\n}\nexports.AST = AST; //# sourceMappingURL=ast.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOEJBQThCO0FBQzlCQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsV0FBVyxHQUFHLEtBQUs7QUFDbkIsTUFBTUcseUJBQXlCQyxtQkFBT0EsQ0FBQyxtSEFBd0I7QUFDL0QsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxpR0FBZTtBQUM3QyxNQUFNRSxRQUFRLElBQUlDLElBQUk7SUFBQztJQUFLO0lBQUs7SUFBSztJQUFLO0NBQUk7QUFDL0MsTUFBTUMsZ0JBQWdCLENBQUNDLElBQU1ILE1BQU1JLEdBQUcsQ0FBQ0Q7QUFDdkMsaUVBQWlFO0FBQ2pFLGdFQUFnRTtBQUNoRSwwQ0FBMEM7QUFDMUMsdUVBQXVFO0FBQ3ZFLE1BQU1FLG1CQUFtQjtBQUN6QixNQUFNQyxhQUFhO0FBQ25CLHVFQUF1RTtBQUN2RSxxRUFBcUU7QUFDckUscUVBQXFFO0FBQ3JFLE1BQU1DLGtCQUFrQixJQUFJTixJQUFJO0lBQUM7SUFBSztDQUFJO0FBQzFDLDBEQUEwRDtBQUMxRCxNQUFNTyxXQUFXLElBQUlQLElBQUk7SUFBQztJQUFNO0NBQUk7QUFDcEMsTUFBTVEsYUFBYSxJQUFJUixJQUFJO0FBQzNCLE1BQU1TLGVBQWUsQ0FBQ0MsSUFBTUEsRUFBRUMsT0FBTyxDQUFDLDRCQUE0QjtBQUNsRSxnQ0FBZ0M7QUFDaEMsTUFBTUMsUUFBUTtBQUNkLGdDQUFnQztBQUNoQyxNQUFNQyxPQUFPRCxRQUFRO0FBQ3JCLDBFQUEwRTtBQUMxRSxzQ0FBc0M7QUFDdEMsTUFBTUUsY0FBY0YsUUFBUTtBQUM1Qix5RUFBeUU7QUFDekUsMkRBQTJEO0FBQzNELE1BQU1qQjtJQUVGLENBQUNvQixJQUFJLENBQUM7SUFDTixDQUFDQyxRQUFRLENBQUM7SUFDVixDQUFDQyxLQUFLLENBQVM7SUFDZixDQUFD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LE1BQU07Z0JBQ1osSUFBSXNDLE1BQU00QixLQUFLdkMsTUFBTSxHQUFHLEdBQUc7b0JBQ3ZCd0MsTUFBTTtnQkFDVixPQUNLO29CQUNEYixXQUFXO2dCQUNmO2dCQUNBO1lBQ0o7WUFDQSxJQUFJdEQsTUFBTSxLQUFLO2dCQUNYLE1BQU0sQ0FBQ21GLEtBQUtrQixXQUFXQyxVQUFVQyxNQUFNLEdBQUcsQ0FBQyxHQUFHN0csdUJBQXVCOEcsVUFBVSxFQUFFdEMsTUFBTTVCO2dCQUN2RixJQUFJZ0UsVUFBVTtvQkFDVm5DLE1BQU1nQjtvQkFDTnBFLFFBQVFBLFNBQVNzRjtvQkFDakIvRCxLQUFLZ0UsV0FBVztvQkFDaEJ4RixXQUFXQSxZQUFZeUY7b0JBQ3ZCO2dCQUNKO1lBQ0o7WUFDQSxJQUFJdkcsTUFBTSxLQUFLO2dCQUNYLElBQUlrRixXQUFXaEIsU0FBUyxLQUNwQkMsTUFBTXZEO3FCQUVOdUQsTUFBTXhEO2dCQUNWRyxXQUFXO2dCQUNYO1lBQ0o7WUFDQSxJQUFJZCxNQUFNLEtBQUs7Z0JBQ1htRSxNQUFNekQ7Z0JBQ05JLFdBQVc7Z0JBQ1g7WUFDSjtZQUNBcUQsTUFBTTVELGFBQWFQO1FBQ3ZCO1FBQ0EsT0FBTztZQUFDbUU7WUFBSyxJQUFHdkUsY0FBY2tHLFFBQVEsRUFBRTVCO1lBQU8sQ0FBQyxDQUFDcEQ7WUFBVUM7U0FBTTtJQUNyRTtBQUNKO0FBQ0F4QixXQUFXLEdBQUdFLEtBQ2QsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGhvdG8tc2t1LXByb2Nlc3Nvci8uL25vZGVfbW9kdWxlcy9nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3QuanM/MDk1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHBhcnNlIGEgc2luZ2xlIHBhdGggcG9ydGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BU1QgPSB2b2lkIDA7XG5jb25zdCBicmFjZV9leHByZXNzaW9uc19qc18xID0gcmVxdWlyZShcIi4vYnJhY2UtZXhwcmVzc2lvbnMuanNcIik7XG5jb25zdCB1bmVzY2FwZV9qc18xID0gcmVxdWlyZShcIi4vdW5lc2NhcGUuanNcIik7XG5jb25zdCB0eXBlcyA9IG5ldyBTZXQoWychJywgJz8nLCAnKycsICcqJywgJ0AnXSk7XG5jb25zdCBpc0V4dGdsb2JUeXBlID0gKGMpID0+IHR5cGVzLmhhcyhjKTtcbi8vIFBhdHRlcm5zIHRoYXQgZ2V0IHByZXBlbmRlZCB0byBiaW5kIHRvIHRoZSBzdGFydCBvZiBlaXRoZXIgdGhlXG4vLyBlbnRpcmUgc3RyaW5nLCBvciBqdXN0IGEgc2luZ2xlIHBhdGggcG9ydGlvbiwgdG8gcHJldmVudCBkb3RzXG4vLyBhbmQvb3IgdHJhdmVyc2FsIHBhdHRlcm5zLCB3aGVuIG5lZWRlZC5cbi8vIEV4dHMgZG9uJ3QgbmVlZCB0aGUgXiBvciAvIGJpdCwgYmVjYXVzZSB0aGUgcm9vdCBiaW5kcyB0aGF0IGFscmVhZHkuXG5jb25zdCBzdGFydE5vVHJhdmVyc2FsID0gJyg/ISg/Ol58LylcXFxcLlxcXFwuPyg/OiR8LykpJztcbmNvbnN0IHN0YXJ0Tm9Eb3QgPSAnKD8hXFxcXC4pJztcbi8vIGNoYXJhY3RlcnMgdGhhdCBpbmRpY2F0ZSBhIHN0YXJ0IG9mIHBhdHRlcm4gbmVlZHMgdGhlIFwibm8gZG90c1wiIGJpdCxcbi8vIGJlY2F1c2UgYSBkb3QgKm1pZ2h0KiBiZSBtYXRjaGVkLiAoIGlzIG5vdCBpbiB0aGUgbGlzdCwgYmVjYXVzZSBpblxuLy8gdGhlIGNhc2Ugb2YgYSBjaGlsZCBleHRnbG9iLCBpdCB3aWxsIGhhbmRsZSB0aGUgcHJldmVudGlvbiBpdHNlbGYuXG5jb25zdCBhZGRQYXR0ZXJuU3RhcnQgPSBuZXcgU2V0KFsnWycsICcuJ10pO1xuLy8gY2FzZXMgd2hlcmUgdHJhdmVyc2FsIGlzIEEtT0ssIG5vIGRvdCBwcmV2ZW50aW9uIG5lZWRlZFxuY29uc3QganVzdERvdHMgPSBuZXcgU2V0KFsnLi4nLCAnLiddKTtcbmNvbnN0IHJlU3BlY2lhbHMgPSBuZXcgU2V0KCcoKS4qe30rP1tdXiRcXFxcIScpO1xuY29uc3QgcmVnRXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG5jb25zdCBxbWFyayA9ICdbXi9dJztcbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nO1xuLy8gdXNlICsgd2hlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0ICpzb21ldGhpbmcqIG1hdGNoZXMsIGJlY2F1c2UgdGhlICogaXNcbi8vIHRoZSBvbmx5IHRoaW5nIGluIHRoZSBwYXRoIHBvcnRpb24uXG5jb25zdCBzdGFyTm9FbXB0eSA9IHFtYXJrICsgJys/Jztcbi8vIHJlbW92ZSB0aGUgXFwgY2hhcnMgdGhhdCB3ZSBhZGRlZCBpZiB3ZSBlbmQgdXAgZG9pbmcgYSBub25tYWdpYyBjb21wYXJlXG4vLyBjb25zdCBkZXNsYXNoID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG5jbGFzcyBBU1Qge1xuICAgIHR5cGU7XG4gICAgI3Jvb3Q7XG4gICAgI2hhc01hZ2ljO1xuICAgICN1ZmxhZyA9IGZhbHNlO1xuICAgICNwYXJ0cyA9IFtdO1xuICAgICNwYXJlbnQ7XG4gICAgI3BhcmVudEluZGV4O1xuICAgICNuZWdzO1xuICAgICNmaWxsZWROZWdzID0gZmFsc2U7XG4gICAgI29wdGlvbnM7XG4gICAgI3RvU3RyaW5nO1xuICAgIC8vIHNldCB0byB0cnVlIGlmIGl0J3MgYW4gZXh0Z2xvYiB3aXRoIG5vIGNoaWxkcmVuXG4gICAgLy8gKHdoaWNoIHJlYWxseSBtZWFucyBvbmUgY2hpbGQgb2YgJycpXG4gICAgI2VtcHR5RXh0ID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IodHlwZSwgcGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLy8gZXh0Z2xvYnMgYXJlIGluaGVyZW50bHkgbWFnaWNhbFxuICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLiNyb290ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNyb290IDogdGhpcztcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBvcHRpb25zIDogdGhpcy4jcm9vdC4jb3B0aW9ucztcbiAgICAgICAgdGhpcy4jbmVncyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBbXSA6IHRoaXMuI3Jvb3QuI25lZ3M7XG4gICAgICAgIGlmICh0eXBlID09PSAnIScgJiYgIXRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MpXG4gICAgICAgICAgICB0aGlzLiNuZWdzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuI3BhcmVudEluZGV4ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNwYXJ0cy5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBnZXQgaGFzTWFnaWMoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy4jaGFzTWFnaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNoYXNNYWdpYztcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHAudHlwZSB8fCBwLmhhc01hZ2ljKVxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jaGFzTWFnaWMgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RlOiB3aWxsIGJlIHVuZGVmaW5lZCB1bnRpbCB3ZSBnZW5lcmF0ZSB0aGUgcmVnZXhwIHNyYyBhbmQgZmluZCBvdXRcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhc01hZ2ljO1xuICAgIH1cbiAgICAvLyByZWNvbnN0cnVjdHMgdGhlIHBhdHRlcm5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3RvU3RyaW5nICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jdG9TdHJpbmc7XG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID0gdGhpcy4jcGFydHMubWFwKHAgPT4gU3RyaW5nKHApKS5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID1cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgKyAnKCcgKyB0aGlzLiNwYXJ0cy5tYXAocCA9PiBTdHJpbmcocCkpLmpvaW4oJ3wnKSArICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2ZpbGxOZWdzKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMuI3Jvb3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBvbmx5IGNhbGwgb24gcm9vdCcpO1xuICAgICAgICBpZiAodGhpcy4jZmlsbGVkTmVncylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAvLyBjYWxsIHRvU3RyaW5nKCkgb25jZSB0byBmaWxsIHRoaXMgb3V0XG4gICAgICAgIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy4jZmlsbGVkTmVncyA9IHRydWU7XG4gICAgICAgIGxldCBuO1xuICAgICAgICB3aGlsZSAoKG4gPSB0aGlzLiNuZWdzLnBvcCgpKSkge1xuICAgICAgICAgICAgaWYgKG4udHlwZSAhPT0gJyEnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gd2FsayB1cCB0aGUgdHJlZSwgYXBwZW5kaW5nIGV2ZXJ0aGluZyB0aGF0IGNvbWVzIEFGVEVSIHBhcmVudEluZGV4XG4gICAgICAgICAgICBsZXQgcCA9IG47XG4gICAgICAgICAgICBsZXQgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocHApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcC4jcGFyZW50SW5kZXggKyAxOyAhcHAudHlwZSAmJiBpIDwgcHAuI3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBuLiNwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgcGFydCBpbiBleHRnbG9iIEFTVD8/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5SW4ocHAuI3BhcnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gcHA7XG4gICAgICAgICAgICAgICAgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHB1c2goLi4ucGFydHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJycpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycgJiYgIShwIGluc3RhbmNlb2YgQVNUICYmIHAuI3BhcmVudCA9PT0gdGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFydDogJyArIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI3BhcnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLnR5cGUgPT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy4jcGFydHMuc2xpY2UoKS5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHAudG9KU09OKCkpKVxuICAgICAgICAgICAgOiBbdGhpcy50eXBlLCAuLi50aGlzLiNwYXJ0cy5tYXAocCA9PiBwLnRvSlNPTigpKV07XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiAhdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0LnVuc2hpZnQoW10pO1xuICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAodGhpcyA9PT0gdGhpcy4jcm9vdCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLiNyb290LiNmaWxsZWROZWdzICYmIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc1N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBpZiAodGhpcy50eXBlKSByZXR1cm4gISF0aGlzLiNwYXJlbnQ/LmlzU3RhcnQoKVxuICAgICAgICBpZiAoIXRoaXMuI3BhcmVudD8uaXNTdGFydCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50SW5kZXggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBBSEVBRCBvZiB0aGlzIGlzIGEgbmVnYXRpb24sIHRoZW4gaXQncyBzdGlsbCB0aGUgXCJzdGFydFwiXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiNwYXJlbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jcGFyZW50SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHAgPSBwLiNwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICghKHBwIGluc3RhbmNlb2YgQVNUICYmIHBwLnR5cGUgPT09ICchJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRW5kKCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLiNwYXJlbnQ/LmlzRW5kKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudD8uaXNFbmQoKTtcbiAgICAgICAgLy8gaWYgbm90IHJvb3QsIGl0J2xsIGFsd2F5cyBoYXZlIGEgcGFyZW50XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcGFydHMubGVuZ3RoIDogMDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudEluZGV4ID09PSBwbCAtIDE7XG4gICAgfVxuICAgIGNvcHlJbihwYXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucHVzaChwYXJ0LmNsb25lKHRoaXMpKTtcbiAgICB9XG4gICAgY2xvbmUocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgQVNUKHRoaXMudHlwZSwgcGFyZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBjLmNvcHlJbihwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUFTVChzdHIsIGFzdCwgcG9zLCBvcHQpIHtcbiAgICAgICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBicmFjZVN0YXJ0ID0gLTE7XG4gICAgICAgIGxldCBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXN0LnR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgb2YgYSBleHRnbG9iLCBhcHBlbmQgdW50aWwgd2UgZmluZCBhIHN0YXJ0XG4gICAgICAgICAgICBsZXQgaSA9IHBvcztcbiAgICAgICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBzdGFydHMgdGhhdCBhcmUgZXNjYXBlZFxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGluZyB8fCBjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluQnJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGJyYWNlU3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXScgJiYgIShpID09PSBicmFjZVN0YXJ0ICsgMiAmJiBicmFjZU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQubm9leHQgJiYgaXNFeHRnbG9iVHlwZShjKSAmJiBzdHIuY2hhckF0KGkpID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzdC5wdXNoKGFjYyk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYiwgcG9zIGlzIGF0IHRoZSAoXG4gICAgICAgIC8vIGZpbmQgdGhlIG5leHQgfCBvciApXG4gICAgICAgIGxldCBpID0gcG9zICsgMTtcbiAgICAgICAgbGV0IHBhcnQgPSBuZXcgQVNUKG51bGwsIGFzdCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgIC8vIHN0YXJ0cyB0aGF0IGFyZSBlc2NhcGVkXG4gICAgICAgICAgICBpZiAoZXNjYXBpbmcgfHwgYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5CcmFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBicmFjZVN0YXJ0ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICddJyAmJiAhKGkgPT09IGJyYWNlU3RhcnQgKyAyICYmIGJyYWNlTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgaW5CcmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0V4dGdsb2JUeXBlKGMpICYmIHN0ci5jaGFyQXQoaSkgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgcGFydCk7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IEFTVChudWxsLCBhc3QpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmIChhY2MgPT09ICcnICYmIGFzdC4jcGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdC4jZW1wdHlFeHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QucHVzaCguLi5wYXJ0cywgcGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgfVxuICAgICAgICAvLyB1bmZpbmlzaGVkIGV4dGdsb2JcbiAgICAgICAgLy8gaWYgd2UgZ290IGhlcmUsIGl0IHdhcyBhIG1hbGZvcm1lZCBleHRnbG9iISBub3QgYW4gZXh0Z2xvYiwgYnV0XG4gICAgICAgIC8vIG1heWJlIHNvbWV0aGluZyBlbHNlIGluIHRoZXJlLlxuICAgICAgICBhc3QudHlwZSA9IG51bGw7XG4gICAgICAgIGFzdC4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGFzdC4jcGFydHMgPSBbc3RyLnN1YnN0cmluZyhwb3MgLSAxKV07XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUdsb2IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBBU1QobnVsbCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgQVNULiNwYXJzZUFTVChwYXR0ZXJuLCBhc3QsIDAsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gaWYgdGhlcmUncyBtYWdpYywgb3IgdGhlIHVuZXNjYXBlZFxuICAgIC8vIHN0cmluZyBpZiBub3QuXG4gICAgdG9NTVBhdHRlcm4oKSB7XG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiByb290XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4jcm9vdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyb290LnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGNvbnN0IGdsb2IgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IFtyZSwgYm9keSwgaGFzTWFnaWMsIHVmbGFnXSA9IHRoaXMudG9SZWdFeHBTb3VyY2UoKTtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gbm9jYXNlIG1vZGUsIGFuZCBub3Qgbm9jYXNlTWFnaWNPbmx5LCB0aGVuIHdlIGRvXG4gICAgICAgIC8vIHN0aWxsIG5lZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gaWYgd2UgaGF2ZSB0byBjYXNlLWluc2Vuc2l0aXZlbHlcbiAgICAgICAgLy8gbWF0Y2ggY2FwaXRhbC9sb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgICAgY29uc3QgYW55TWFnaWMgPSBoYXNNYWdpYyB8fFxuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgfHxcbiAgICAgICAgICAgICh0aGlzLiNvcHRpb25zLm5vY2FzZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNvcHRpb25zLm5vY2FzZU1hZ2ljT25seSAmJlxuICAgICAgICAgICAgICAgIGdsb2IudG9VcHBlckNhc2UoKSAhPT0gZ2xvYi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFhbnlNYWdpYykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSAodGhpcy4jb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJykgKyAodWZsYWcgPyAndScgOiAnJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoYF4ke3JlfSRgLCBmbGFncyksIHtcbiAgICAgICAgICAgIF9zcmM6IHJlLFxuICAgICAgICAgICAgX2dsb2I6IGdsb2IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdGhlIHN0cmluZyBtYXRjaCwgdGhlIHJlZ2V4cCBzb3VyY2UsIHdoZXRoZXIgdGhlcmUncyBtYWdpY1xuICAgIC8vIGluIHRoZSByZWdleHAgKHNvIGEgcmVndWxhciBleHByZXNzaW9uIGlzIHJlcXVpcmVkKSBhbmQgd2hldGhlciBvclxuICAgIC8vIG5vdCB0aGUgdWZsYWcgaXMgbmVlZGVkIGZvciB0aGUgcmVndWxhciBleHByZXNzaW9uIChmb3IgcG9zaXggY2xhc3NlcylcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGluamVjdGluZyB0aGUgc3RhcnQvZW5kIGF0IHRoaXMgcG9pbnQsIGp1c3QgcmV0dXJuXG4gICAgLy8gdGhlIEJPRFkgb2YgdGhlIHJlZ2V4cCwgYWxvbmcgd2l0aCB0aGUgc3RhcnQvZW5kIHBvcnRpb25zIHN1aXRhYmxlXG4gICAgLy8gZm9yIGJpbmRpbmcgdGhlIHN0YXJ0L2VuZCBpbiBlaXRoZXIgYSBqb2luZWQgZnVsbC1wYXRoIG1ha2VSZSBjb250ZXh0XG4gICAgLy8gKHdoZXJlIHdlIGJpbmQgdG8gKF58LyksIG9yIGEgc3RhbmRhbG9uZSBtYXRjaFBhcnQgY29udGV4dCAod2hlcmVcbiAgICAvLyB3ZSBiaW5kIHRvIF4sIGFuZCBub3QgLykuICBPdGhlcndpc2Ugc2xhc2hlcyBnZXQgZHVwZWQhXG4gICAgLy9cbiAgICAvLyBJbiBwYXJ0LW1hdGNoaW5nIG1vZGUsIHRoZSBzdGFydCBpczpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogXig/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogXlxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IF4oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbm90IGlzRW5kKCk6IG5vdGhpbmdcbiAgICAvLyAtIGVsc2U6ICRcbiAgICAvL1xuICAgIC8vIEluIGZ1bGwtcGF0aCBtYXRjaGluZyBtb2RlLCB3ZSBwdXQgdGhlIHNsYXNoIGF0IHRoZSBTVEFSVCBvZiB0aGVcbiAgICAvLyBwYXR0ZXJuLCBzbyBzdGFydCBpczpcbiAgICAvLyAtIGlmIGZpcnN0IHBhdHRlcm46IHNhbWUgYXMgcGFydC1tYXRjaGluZyBtb2RlXG4gICAgLy8gLSBpZiBub3QgaXNTdGFydCgpOiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogLyg/IVxcLlxcLj8oPzokfC8pKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogL1xuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IC8oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbGFzdCBwYXR0ZXJuLCBzYW1lIGFzIHBhcnQtbWF0Y2hpbmcgbW9kZVxuICAgIC8vIC0gZWxzZSBub3RoaW5nXG4gICAgLy9cbiAgICAvLyBBbHdheXMgcHV0IHRoZSAoPzokfC8pIG9uIG5lZ2F0ZWQgdGFpbHMsIHRob3VnaCwgYmVjYXVzZSB0aGF0IGhhcyB0byBiZVxuICAgIC8vIHRoZXJlIHRvIGJpbmQgdGhlIGVuZCBvZiB0aGUgbmVnYXRlZCBwYXR0ZXJuIHBvcnRpb24sIGFuZCBpdCdzIGVhc2llciB0b1xuICAgIC8vIGp1c3Qgc3RpY2sgaXQgaW4gbm93IHJhdGhlciB0aGFuIHRyeSB0byBpbmplY3QgaXQgbGF0ZXIgaW4gdGhlIG1pZGRsZSBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuLlxuICAgIC8vXG4gICAgLy8gV2UgY2FuIGp1c3QgYWx3YXlzIHJldHVybiB0aGUgc2FtZSBlbmQsIGFuZCBsZWF2ZSBpdCB1cCB0byB0aGUgY2FsbGVyXG4gICAgLy8gdG8ga25vdyB3aGV0aGVyIGl0J3MgZ29pbmcgdG8gYmUgdXNlZCBqb2luZWQgb3IgaW4gcGFydHMuXG4gICAgLy8gQW5kLCBpZiB0aGUgc3RhcnQgaXMgYWRqdXN0ZWQgc2xpZ2h0bHksIGNhbiBkbyB0aGUgc2FtZSB0aGVyZTpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogKD86L3xeKSg/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogKD86L3xeKVxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6ICg/Oi98XikoPyFcXC4pXG4gICAgLy9cbiAgICAvLyBCdXQgaXQncyBiZXR0ZXIgdG8gaGF2ZSBhIHNpbXBsZXIgYmluZGluZyB3aXRob3V0IGEgY29uZGl0aW9uYWwsIGZvclxuICAgIC8vIHBlcmZvcm1hbmNlLCBzbyBwcm9iYWJseSBiZXR0ZXIgdG8gcmV0dXJuIGJvdGggc3RhcnQgb3B0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZW4gdGhlIGNhbGxlciBqdXN0IGlnbm9yZXMgdGhlIGVuZCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgcGF0dGVybixcbiAgICAvLyBhbmQgdGhlIHN0YXJ0IGFsd2F5cyBnZXRzIGFwcGxpZWQuXG4gICAgLy9cbiAgICAvLyBCdXQgdGhhdCdzIGFsd2F5cyBnb2luZyB0byBiZSAkIGlmIGl0J3MgdGhlIGVuZGluZyBwYXR0ZXJuLCBvciBub3RoaW5nLFxuICAgIC8vIHNvIHRoZSBjYWxsZXIgY2FuIGp1c3QgYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGJ1aWxkaW5nLlxuICAgIC8vXG4gICAgLy8gU28gdGhlIHRvZG8gaXM6XG4gICAgLy8gLSBiZXR0ZXIgZGV0ZWN0IHdoYXQga2luZCBvZiBzdGFydCBpcyBuZWVkZWRcbiAgICAvLyAtIHJldHVybiBib3RoIGZsYXZvcnMgb2Ygc3RhcnRpbmcgcGF0dGVyblxuICAgIC8vIC0gYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGNyZWF0aW5nIHRoZSBhY3R1YWwgUmVnRXhwXG4gICAgLy9cbiAgICAvLyBBaCwgYnV0IHdhaXQsIG5vLCB0aGF0IGFsbCBvbmx5IGFwcGxpZXMgdG8gdGhlIHJvb3Qgd2hlbiB0aGUgZmlyc3QgcGF0dGVyblxuICAgIC8vIGlzIG5vdCBhbiBleHRnbG9iLiBJZiB0aGUgZmlyc3QgcGF0dGVybiBJUyBhbiBleHRnbG9iLCB0aGVuIHdlIG5lZWQgYWxsXG4gICAgLy8gdGhhdCBkb3QgcHJldmVudGlvbiBiaXogdG8gbGl2ZSBpbiB0aGUgZXh0Z2xvYiBwb3J0aW9ucywgYmVjYXVzZSBlZ1xuICAgIC8vICsoKnwueCopIGNhbiBtYXRjaCAueHkgYnV0IG5vdCAueXguXG4gICAgLy9cbiAgICAvLyBTbywgcmV0dXJuIHRoZSB0d28gZmxhdm9ycyBpZiBpdCdzICNyb290IGFuZCB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IGFuXG4gICAgLy8gQVNULCBvdGhlcndpc2UgbGVhdmUgaXQgdG8gdGhlIGNoaWxkIEFTVCB0byBoYW5kbGUgaXQsIGFuZCB0aGVyZSxcbiAgICAvLyB1c2UgdGhlICg/Ol58Lykgc3R5bGUgb2Ygc3RhcnQgYmluZGluZy5cbiAgICAvL1xuICAgIC8vIEV2ZW4gc2ltcGxpZmllZCBmdXJ0aGVyOlxuICAgIC8vIC0gU2luY2UgdGhlIHN0YXJ0IGZvciBhIGpvaW4gaXMgZWcgLyg/IVxcLikgYW5kIHRoZSBzdGFydCBmb3IgYSBwYXJ0XG4gICAgLy8gaXMgXig/IVxcLiksIHdlIGNhbiBqdXN0IHByZXBlbmQgKD8hXFwuKSB0byB0aGUgcGF0dGVybiAoZWl0aGVyIHJvb3RcbiAgICAvLyBvciBzdGFydCBvciB3aGF0ZXZlcikgYW5kIHByZXBlbmQgXiBvciAvIGF0IHRoZSBSZWdleHAgY29uc3RydWN0aW9uLlxuICAgIHRvUmVnRXhwU291cmNlKGFsbG93RG90KSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IGFsbG93RG90ID8/ICEhdGhpcy4jb3B0aW9ucy5kb3Q7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy4jZmlsbE5lZ3MoKTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vRW1wdHkgPSB0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCk7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSB0aGlzLiNwYXJ0c1xuICAgICAgICAgICAgICAgIC5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3JlLCBfLCBoYXNNYWdpYywgdWZsYWddID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gQVNULiNwYXJzZUdsb2IocCwgdGhpcy4jaGFzTWFnaWMsIG5vRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIDogcC50b1JlZ0V4cFNvdXJjZShhbGxvd0RvdCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB0aGlzLiNoYXNNYWdpYyB8fCBoYXNNYWdpYztcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyA9IHRoaXMuI3VmbGFnIHx8IHVmbGFnO1xuICAgICAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuI3BhcnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzdHJpbmcgdGhhdCB3aWxsIG1hdGNoIHRoZSBzdGFydCBvZiB0aGUgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBwcm90ZWN0IGFnYWluc3QgZG90cyBhbmQgc3VjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gJy4nIGFuZCAnLi4nIGNhbm5vdCBtYXRjaCB1bmxlc3MgdGhlIHBhdHRlcm4gaXMgdGhhdCBleGFjdGx5LFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0IHN0YXJ0cyB3aXRoIC4gb3IgZG90OnRydWUgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3RUcmF2QWxsb3dlZCA9IHRoaXMuI3BhcnRzLmxlbmd0aCA9PT0gMSAmJiBqdXN0RG90cy5oYXModGhpcy4jcGFydHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvdFRyYXZBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHMgPSBhZGRQYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgcG9zc2liaWxpdHkgb2YgbWF0Y2hpbmcgLiBvciAuLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcmV2ZW50IHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9UcmF2ID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3RzIGFyZSBhbGxvd2VkLCBhbmQgdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAoZG90ICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgwKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggXFwuLCBhbmQgdGhlbiBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3JjLnN0YXJ0c1dpdGgoJ1xcXFwuJykgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDIpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBcXC5cXC4sIGFuZCB0aGVuIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcmMuc3RhcnRzV2l0aCgnXFxcXC5cXFxcLicpICYmIGFwcy5oYXMoc3JjLmNoYXJBdCg0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwcmV2ZW50IGRvdHMgaWYgaXQgY2FuJ3QgbWF0Y2ggYSBkb3QsIG9yIGlmIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Yi1wYXR0ZXJuIHdpbGwgYmUgcHJldmVudGluZyBpdCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9Eb3QgPSAhZG90ICYmICFhbGxvd0RvdCAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBuZWVkTm9UcmF2ID8gc3RhcnROb1RyYXZlcnNhbCA6IG5lZWROb0RvdCA/IHN0YXJ0Tm9Eb3QgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgXCJlbmQgb2YgcGF0aCBwb3J0aW9uXCIgcGF0dGVybiB0byBuZWdhdGlvbiB0YWlsc1xuICAgICAgICAgICAgbGV0IGVuZCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJykge1xuICAgICAgICAgICAgICAgIGVuZCA9ICcoPzokfFxcXFwvKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbCA9IHN0YXJ0ICsgc3JjICsgZW5kO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBmaW5hbCxcbiAgICAgICAgICAgICAgICAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkoc3JjKSxcbiAgICAgICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGJvZHkgKnR3aWNlKiBpZiBpdCdzIGEgcmVwZWF0IHBhdHRlcm5cbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0LCBvbmNlIGluIG5vZG90IG1vZGUsIHRoZW4gYWdhaW4gaW4gZG90IG1vZGUsIHNvIGFcbiAgICAgICAgLy8gcGF0dGVybiBsaWtlICooPykgY2FuIG1hdGNoICd4LnknXG4gICAgICAgIGNvbnN0IHJlcGVhdGVkID0gdGhpcy50eXBlID09PSAnKicgfHwgdGhpcy50eXBlID09PSAnKyc7XG4gICAgICAgIC8vIHNvbWUga2luZCBvZiBleHRnbG9iXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy50eXBlID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonO1xuICAgICAgICBsZXQgYm9keSA9IHRoaXMuI3BhcnRzVG9SZWdFeHAoZG90KTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSAmJiAhYm9keSAmJiB0aGlzLnR5cGUgIT09ICchJykge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBleHRnbG9iLCBoYXMgdG8gYXQgbGVhc3QgYmUgKnNvbWV0aGluZyogcHJlc2VudCwgaWYgaXQnc1xuICAgICAgICAgICAgLy8gdGhlIGVudGlyZSBwYXRoIHBvcnRpb24uXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy4jcGFydHMgPSBbc107XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gW3MsICgwLCB1bmVzY2FwZV9qc18xLnVuZXNjYXBlKSh0aGlzLnRvU3RyaW5nKCkpLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFhYWCBhYnN0cmFjdCBvdXQgdGhpcyBtYXAgbWV0aG9kXG4gICAgICAgIGxldCBib2R5RG90QWxsb3dlZCA9ICFyZXBlYXRlZCB8fCBhbGxvd0RvdCB8fCBkb3QgfHwgIXN0YXJ0Tm9Eb3RcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogdGhpcy4jcGFydHNUb1JlZ0V4cCh0cnVlKTtcbiAgICAgICAgaWYgKGJvZHlEb3RBbGxvd2VkID09PSBib2R5KSB7XG4gICAgICAgICAgICBib2R5RG90QWxsb3dlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5RG90QWxsb3dlZCkge1xuICAgICAgICAgICAgYm9keSA9IGAoPzoke2JvZHl9KSg/OiR7Ym9keURvdEFsbG93ZWR9KSo/YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBlbXB0eSAhKCkgaXMgZXhhY3RseSBlcXVpdmFsZW50IHRvIGEgc3Rhck5vRW1wdHlcbiAgICAgICAgbGV0IGZpbmFsID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICchJyAmJiB0aGlzLiNlbXB0eUV4dCkge1xuICAgICAgICAgICAgZmluYWwgPSAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCA/IHN0YXJ0Tm9Eb3QgOiAnJykgKyBzdGFyTm9FbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlID0gdGhpcy50eXBlID09PSAnISdcbiAgICAgICAgICAgICAgICA/IC8vICEoKSBtdXN0IG1hdGNoIHNvbWV0aGluZyxidXQgISh4KSBjYW4gbWF0Y2ggJydcbiAgICAgICAgICAgICAgICAgICAgJykpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCAmJiAhYWxsb3dEb3QgPyBzdGFydE5vRG90IDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICdAJ1xuICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJz8nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcpPydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKycgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKicgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKT9gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYCkke3RoaXMudHlwZX1gO1xuICAgICAgICAgICAgZmluYWwgPSBzdGFydCArIGJvZHkgKyBjbG9zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmluYWwsXG4gICAgICAgICAgICAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkoYm9keSksXG4gICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgIHRoaXMuI3VmbGFnLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAjcGFydHNUb1JlZ0V4cChkb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcnRzXG4gICAgICAgICAgICAubWFwKHAgPT4ge1xuICAgICAgICAgICAgLy8gZXh0Z2xvYiBBU1RzIHNob3VsZCBvbmx5IGNvbnRhaW4gcGFyZW50IEFTVHNcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHR5cGUgaW4gZXh0Z2xvYiBhc3Q/PycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIC8vIGNhbiBpZ25vcmUgaGFzTWFnaWMsIGJlY2F1c2UgZXh0Z2xvYnMgYXJlIGFscmVhZHkgYWx3YXlzIG1hZ2ljXG4gICAgICAgICAgICBjb25zdCBbcmUsIF8sIF9oYXNNYWdpYywgdWZsYWddID0gcC50b1JlZ0V4cFNvdXJjZShkb3QpO1xuICAgICAgICAgICAgdGhpcy4jdWZsYWcgPSB0aGlzLiN1ZmxhZyB8fCB1ZmxhZztcbiAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIocCA9PiAhKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSkgfHwgISFwKVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUdsb2IoZ2xvYiwgaGFzTWFnaWMsIG5vRW1wdHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlID0gJyc7XG4gICAgICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBnbG9iLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmUgKz0gKHJlU3BlY2lhbHMuaGFzKGMpID8gJ1xcXFwnIDogJycpICsgYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZ2xvYi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9ICdcXFxcXFxcXCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzcmMsIG5lZWRVZmxhZywgY29uc3VtZWQsIG1hZ2ljXSA9ICgwLCBicmFjZV9leHByZXNzaW9uc19qc18xLnBhcnNlQ2xhc3MpKGdsb2IsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICByZSArPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIHVmbGFnID0gdWZsYWcgfHwgbmVlZFVmbGFnO1xuICAgICAgICAgICAgICAgICAgICBpICs9IGNvbnN1bWVkIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBtYWdpYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGlmIChub0VtcHR5ICYmIGdsb2IgPT09ICcqJylcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3Rhck5vRW1wdHk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZSArPSBzdGFyO1xuICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICByZSArPSBxbWFyaztcbiAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZSArPSByZWdFeHBFc2NhcGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZSwgKDAsIHVuZXNjYXBlX2pzXzEudW5lc2NhcGUpKGdsb2IpLCAhIWhhc01hZ2ljLCB1ZmxhZ107XG4gICAgfVxufVxuZXhwb3J0cy5BU1QgPSBBU1Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQVNUIiwiYnJhY2VfZXhwcmVzc2lvbnNfanNfMSIsInJlcXVpcmUiLCJ1bmVzY2FwZV9qc18xIiwidHlwZXMiLCJTZXQiLCJpc0V4dGdsb2JUeXBlIiwiYyIsImhhcyIsInN0YXJ0Tm9UcmF2ZXJzYWwiLCJzdGFydE5vRG90IiwiYWRkUGF0dGVyblN0YXJ0IiwianVzdERvdHMiLCJyZVNwZWNpYWxzIiwicmVnRXhwRXNjYXBlIiwicyIsInJlcGxhY2UiLCJxbWFyayIsInN0YXIiLCJzdGFyTm9FbXB0eSIsInJvb3QiLCJoYXNNYWdpYyIsInVmbGFnIiwicGFydHMiLCJwYXJlbnQiLCJwYXJlbnRJbmRleCIsIm5lZ3MiLCJmaWxsZWROZWdzIiwib3B0aW9ucyIsInRvU3RyaW5nIiwiZW1wdHlFeHQiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJwdXNoIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwicCIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJmaWxsTmVncyIsIkVycm9yIiwibiIsInBvcCIsInBwIiwiaSIsInBhcnQiLCJjb3B5SW4iLCJ0b0pTT04iLCJyZXQiLCJzbGljZSIsImlzU3RhcnQiLCJ1bnNoaWZ0IiwiaXNFbmQiLCJwbCIsImNsb25lIiwicGFyc2VBU1QiLCJzdHIiLCJhc3QiLCJwb3MiLCJvcHQiLCJlc2NhcGluZyIsImluQnJhY2UiLCJicmFjZVN0YXJ0IiwiYnJhY2VOZWciLCJhY2MiLCJjaGFyQXQiLCJub2V4dCIsImV4dCIsInN1YnN0cmluZyIsImZyb21HbG9iIiwicGF0dGVybiIsInRvTU1QYXR0ZXJuIiwiZ2xvYiIsInJlIiwiYm9keSIsInRvUmVnRXhwU291cmNlIiwiYW55TWFnaWMiLCJub2Nhc2UiLCJub2Nhc2VNYWdpY09ubHkiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiZmxhZ3MiLCJhc3NpZ24iLCJSZWdFeHAiLCJfc3JjIiwiX2dsb2IiLCJhbGxvd0RvdCIsImRvdCIsIm5vRW1wdHkiLCJzcmMiLCJfIiwicGFyc2VHbG9iIiwic3RhcnQiLCJkb3RUcmF2QWxsb3dlZCIsImFwcyIsIm5lZWROb1RyYXYiLCJzdGFydHNXaXRoIiwibmVlZE5vRG90IiwiZW5kIiwiZmluYWwiLCJ1bmVzY2FwZSIsInJlcGVhdGVkIiwicGFydHNUb1JlZ0V4cCIsImJvZHlEb3RBbGxvd2VkIiwiY2xvc2UiLCJfaGFzTWFnaWMiLCJmaWx0ZXIiLCJuZWVkVWZsYWciLCJjb25zdW1lZCIsIm1hZ2ljIiwicGFyc2VDbGFzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    \"[:alnum:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\",\n        true\n    ],\n    \"[:alpha:]\": [\n        \"\\\\p{L}\\\\p{Nl}\",\n        true\n    ],\n    \"[:ascii:]\": [\n        \"\\\\x\" + \"00-\\\\x\" + \"7f\",\n        false\n    ],\n    \"[:blank:]\": [\n        \"\\\\p{Zs}\\\\t\",\n        true\n    ],\n    \"[:cntrl:]\": [\n        \"\\\\p{Cc}\",\n        true\n    ],\n    \"[:digit:]\": [\n        \"\\\\p{Nd}\",\n        true\n    ],\n    \"[:graph:]\": [\n        \"\\\\p{Z}\\\\p{C}\",\n        true,\n        true\n    ],\n    \"[:lower:]\": [\n        \"\\\\p{Ll}\",\n        true\n    ],\n    \"[:print:]\": [\n        \"\\\\p{C}\",\n        true\n    ],\n    \"[:punct:]\": [\n        \"\\\\p{P}\",\n        true\n    ],\n    \"[:space:]\": [\n        \"\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f\",\n        true\n    ],\n    \"[:upper:]\": [\n        \"\\\\p{Lu}\",\n        true\n    ],\n    \"[:word:]\": [\n        \"\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}\",\n        true\n    ],\n    \"[:xdigit:]\": [\n        \"A-Fa-f0-9\",\n        false\n    ]\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s)=>s.replace(/[[\\]\\\\-]/g, \"\\\\$&\");\n// escape all regexp magic characters\nconst regexpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges)=>ranges.join(\"\");\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position)=>{\n    const pos = position;\n    /* c8 ignore start */ if (glob.charAt(pos) !== \"[\") {\n        throw new Error(\"not in a brace expression\");\n    }\n    /* c8 ignore stop */ const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = \"\";\n    WHILE: while(i < glob.length){\n        const c = glob.charAt(i);\n        if ((c === \"!\" || c === \"^\") && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === \"]\" && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === \"\\\\\") {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n        // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === \"[\" && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)){\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return [\n                            \"$.\",\n                            false,\n                            glob.length - pos,\n                            true\n                        ];\n                    }\n                    i += cls.length;\n                    if (neg) negs.push(unip);\n                    else ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + \"-\" + braceEscape(c));\n            } else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = \"\";\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith(\"-]\", i + 1)) {\n            ranges.push(braceEscape(c + \"-\"));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith(\"-\", i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return [\n            \"\",\n            false,\n            0,\n            false\n        ];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return [\n            \"$.\",\n            false,\n            glob.length - pos,\n            true\n        ];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 && ranges.length === 1 && /^\\\\?.$/.test(ranges[0]) && !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [\n            regexpEscape(r),\n            false,\n            endPos - pos,\n            false\n        ];\n    }\n    const sranges = \"[\" + (negate ? \"^\" : \"\") + rangesToString(ranges) + \"]\";\n    const snegs = \"[\" + (negate ? \"\" : \"^\") + rangesToString(negs) + \"]\";\n    const comb = ranges.length && negs.length ? \"(\" + sranges + \"|\" + snegs + \")\" : ranges.length ? sranges : snegs;\n    return [\n        comb,\n        uflag,\n        endPos - pos,\n        true\n    ];\n};\nexports.parseClass = parseClass; //# sourceMappingURL=brace-expressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYnJhY2UtZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYix3RUFBd0U7QUFDeEUsd0NBQXdDO0FBQ3hDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQiw4REFBOEQ7QUFDOUQsTUFBTUcsZUFBZTtJQUNqQixhQUFhO1FBQUM7UUFBd0I7S0FBSztJQUMzQyxhQUFhO1FBQUM7UUFBaUI7S0FBSztJQUNwQyxhQUFhO1FBQUMsUUFBUSxXQUFXO1FBQU07S0FBTTtJQUM3QyxhQUFhO1FBQUM7UUFBYztLQUFLO0lBQ2pDLGFBQWE7UUFBQztRQUFXO0tBQUs7SUFDOUIsYUFBYTtRQUFDO1FBQVc7S0FBSztJQUM5QixhQUFhO1FBQUM7UUFBZ0I7UUFBTTtLQUFLO0lBQ3pDLGFBQWE7UUFBQztRQUFXO0tBQUs7SUFDOUIsYUFBYTtRQUFDO1FBQVU7S0FBSztJQUM3QixhQUFhO1FBQUM7UUFBVTtLQUFLO0lBQzdCLGFBQWE7UUFBQztRQUF5QjtLQUFLO0lBQzVDLGFBQWE7UUFBQztRQUFXO0tBQUs7SUFDOUIsWUFBWTtRQUFDO1FBQStCO0tBQUs7SUFDakQsY0FBYztRQUFDO1FBQWE7S0FBTTtBQUN0QztBQUNBLCtEQUErRDtBQUMvRCxtQkFBbUI7QUFDbkIsTUFBTUMsY0FBYyxDQUFDQyxJQUFNQSxFQUFFQyxPQUFPLENBQUMsYUFBYTtBQUNsRCxxQ0FBcUM7QUFDckMsTUFBTUMsZUFBZSxDQUFDRixJQUFNQSxFQUFFQyxPQUFPLENBQUMsNEJBQTRCO0FBQ2xFLDREQUE0RDtBQUM1RCxNQUFNRSxpQkFBaUIsQ0FBQ0MsU0FBV0EsT0FBT0MsSUFBSSxDQUFDO0FBQy9DLCtEQUErRDtBQUMvRCxrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLHlDQUF5QztBQUN6QyxpRUFBaUU7QUFDakUsNkJBQTZCO0FBQzdCLE1BQU1SLGFBQWEsQ0FBQ1MsTUFBTUM7SUFDdEIsTUFBTUMsTUFBTUQ7SUFDWixtQkFBbUIsR0FDbkIsSUFBSUQsS0FBS0csTUFBTSxDQUFDRCxTQUFTLEtBQUs7UUFDMUIsTUFBTSxJQUFJRSxNQUFNO0lBQ3BCO0lBQ0Esa0JBQWtCLEdBQ2xCLE1BQU1OLFNBQVMsRUFBRTtJQUNqQixNQUFNTyxPQUFPLEVBQUU7SUFDZixJQUFJQyxJQUFJSixNQUFNO0lBQ2QsSUFBSUssV0FBVztJQUNmLElBQUlDLFFBQVE7SUFDWixJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsU0FBUztJQUNiLElBQUlDLFNBQVNUO0lBQ2IsSUFBSVUsYUFBYTtJQUNqQkMsT0FBTyxNQUFPUCxJQUFJTixLQUFLYyxNQUFNLENBQUU7UUFDM0IsTUFBTUMsSUFBSWYsS0FBS0csTUFBTSxDQUFDRztRQUN0QixJQUFJLENBQUNTLE1BQU0sT0FBT0EsTUFBTSxHQUFFLEtBQU1ULE1BQU1KLE1BQU0sR0FBRztZQUMzQ1EsU0FBUztZQUNUSjtZQUNBO1FBQ0o7UUFDQSxJQUFJUyxNQUFNLE9BQU9SLFlBQVksQ0FBQ0UsVUFBVTtZQUNwQ0UsU0FBU0wsSUFBSTtZQUNiO1FBQ0o7UUFDQUMsV0FBVztRQUNYLElBQUlRLE1BQU0sTUFBTTtZQUNaLElBQUksQ0FBQ04sVUFBVTtnQkFDWEEsV0FBVztnQkFDWEg7Z0JBQ0E7WUFDSjtRQUNBLDBEQUEwRDtRQUM5RDtRQUNBLElBQUlTLE1BQU0sT0FBTyxDQUFDTixVQUFVO1lBQ3hCLDREQUE0RDtZQUM1RCxLQUFLLE1BQU0sQ0FBQ08sS0FBSyxDQUFDQyxNQUFNQyxHQUFHQyxJQUFJLENBQUMsSUFBSWhDLE9BQU9pQyxPQUFPLENBQUM1QixjQUFlO2dCQUM5RCxJQUFJUSxLQUFLcUIsVUFBVSxDQUFDTCxLQUFLVixJQUFJO29CQUN6QiwrQ0FBK0M7b0JBQy9DLElBQUlNLFlBQVk7d0JBQ1osT0FBTzs0QkFBQzs0QkFBTTs0QkFBT1osS0FBS2MsTUFBTSxHQUFHWjs0QkFBSzt5QkFBSztvQkFDakQ7b0JBQ0FJLEtBQUtVLElBQUlGLE1BQU07b0JBQ2YsSUFBSUssS0FDQWQsS0FBS2lCLElBQUksQ0FBQ0w7eUJBRVZuQixPQUFPd0IsSUFBSSxDQUFDTDtvQkFDaEJULFFBQVFBLFNBQVNVO29CQUNqQixTQUFTTDtnQkFDYjtZQUNKO1FBQ0o7UUFDQSxnREFBZ0Q7UUFDaERKLFdBQVc7UUFDWCxJQUFJRyxZQUFZO1lBQ1osc0RBQXNEO1lBQ3RELG1CQUFtQjtZQUNuQixJQUFJRyxJQUFJSCxZQUFZO2dCQUNoQmQsT0FBT3dCLElBQUksQ0FBQzdCLFlBQVltQixjQUFjLE1BQU1uQixZQUFZc0I7WUFDNUQsT0FDSyxJQUFJQSxNQUFNSCxZQUFZO2dCQUN2QmQsT0FBT3dCLElBQUksQ0FBQzdCLFlBQVlzQjtZQUM1QjtZQUNBSCxhQUFhO1lBQ2JOO1lBQ0E7UUFDSjtRQUNBLHFDQUFxQztRQUNyQyw4REFBOEQ7UUFDOUQsSUFBSU4sS0FBS3FCLFVBQVUsQ0FBQyxNQUFNZixJQUFJLElBQUk7WUFDOUJSLE9BQU93QixJQUFJLENBQUM3QixZQUFZc0IsSUFBSTtZQUM1QlQsS0FBSztZQUNMO1FBQ0o7UUFDQSxJQUFJTixLQUFLcUIsVUFBVSxDQUFDLEtBQUtmLElBQUksSUFBSTtZQUM3Qk0sYUFBYUc7WUFDYlQsS0FBSztZQUNMO1FBQ0o7UUFDQSxvREFBb0Q7UUFDcERSLE9BQU93QixJQUFJLENBQUM3QixZQUFZc0I7UUFDeEJUO0lBQ0o7SUFDQSxJQUFJSyxTQUFTTCxHQUFHO1FBQ1osc0RBQXNEO1FBQ3RELCtDQUErQztRQUMvQyxPQUFPO1lBQUM7WUFBSTtZQUFPO1lBQUc7U0FBTTtJQUNoQztJQUNBLGdFQUFnRTtJQUNoRSxrRUFBa0U7SUFDbEUsSUFBSSxDQUFDUixPQUFPZ0IsTUFBTSxJQUFJLENBQUNULEtBQUtTLE1BQU0sRUFBRTtRQUNoQyxPQUFPO1lBQUM7WUFBTTtZQUFPZCxLQUFLYyxNQUFNLEdBQUdaO1lBQUs7U0FBSztJQUNqRDtJQUNBLHlFQUF5RTtJQUN6RSxzRUFBc0U7SUFDdEUseUVBQXlFO0lBQ3pFLHNFQUFzRTtJQUN0RSxJQUFJRyxLQUFLUyxNQUFNLEtBQUssS0FDaEJoQixPQUFPZ0IsTUFBTSxLQUFLLEtBQ2xCLFNBQVNTLElBQUksQ0FBQ3pCLE1BQU0sQ0FBQyxFQUFFLEtBQ3ZCLENBQUNZLFFBQVE7UUFDVCxNQUFNYyxJQUFJMUIsTUFBTSxDQUFDLEVBQUUsQ0FBQ2dCLE1BQU0sS0FBSyxJQUFJaEIsTUFBTSxDQUFDLEVBQUUsQ0FBQzJCLEtBQUssQ0FBQyxDQUFDLEtBQUszQixNQUFNLENBQUMsRUFBRTtRQUNsRSxPQUFPO1lBQUNGLGFBQWE0QjtZQUFJO1lBQU9iLFNBQVNUO1lBQUs7U0FBTTtJQUN4RDtJQUNBLE1BQU13QixVQUFVLE1BQU9oQixDQUFBQSxTQUFTLE1BQU0sRUFBQyxJQUFLYixlQUFlQyxVQUFVO0lBQ3JFLE1BQU02QixRQUFRLE1BQU9qQixDQUFBQSxTQUFTLEtBQUssR0FBRSxJQUFLYixlQUFlUSxRQUFRO0lBQ2pFLE1BQU11QixPQUFPOUIsT0FBT2dCLE1BQU0sSUFBSVQsS0FBS1MsTUFBTSxHQUNuQyxNQUFNWSxVQUFVLE1BQU1DLFFBQVEsTUFDOUI3QixPQUFPZ0IsTUFBTSxHQUNUWSxVQUNBQztJQUNWLE9BQU87UUFBQ0M7UUFBTXBCO1FBQU9HLFNBQVNUO1FBQUs7S0FBSztBQUM1QztBQUNBYixrQkFBa0IsR0FBR0UsWUFDckIsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGhvdG8tc2t1LXByb2Nlc3Nvci8uL25vZGVfbW9kdWxlcy9nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9icmFjZS1leHByZXNzaW9ucy5qcz8zZmJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gdHJhbnNsYXRlIHRoZSB2YXJpb3VzIHBvc2l4IGNoYXJhY3RlciBjbGFzc2VzIGludG8gdW5pY29kZSBwcm9wZXJ0aWVzXG4vLyB0aGlzIHdvcmtzIGFjcm9zcyBhbGwgdW5pY29kZSBsb2NhbGVzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQ2xhc3MgPSB2b2lkIDA7XG4vLyB7IDxwb3NpeCBjbGFzcz46IFs8dHJhbnNsYXRpb24+LCAvdSBmbGFnIHJlcXVpcmVkLCBuZWdhdGVkXVxuY29uc3QgcG9zaXhDbGFzc2VzID0ge1xuICAgICdbOmFsbnVtOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6YWxwaGE6XSc6IFsnXFxcXHB7TH1cXFxccHtObH0nLCB0cnVlXSxcbiAgICAnWzphc2NpaTpdJzogWydcXFxceCcgKyAnMDAtXFxcXHgnICsgJzdmJywgZmFsc2VdLFxuICAgICdbOmJsYW5rOl0nOiBbJ1xcXFxwe1pzfVxcXFx0JywgdHJ1ZV0sXG4gICAgJ1s6Y250cmw6XSc6IFsnXFxcXHB7Q2N9JywgdHJ1ZV0sXG4gICAgJ1s6ZGlnaXQ6XSc6IFsnXFxcXHB7TmR9JywgdHJ1ZV0sXG4gICAgJ1s6Z3JhcGg6XSc6IFsnXFxcXHB7Wn1cXFxccHtDfScsIHRydWUsIHRydWVdLFxuICAgICdbOmxvd2VyOl0nOiBbJ1xcXFxwe0xsfScsIHRydWVdLFxuICAgICdbOnByaW50Ol0nOiBbJ1xcXFxwe0N9JywgdHJ1ZV0sXG4gICAgJ1s6cHVuY3Q6XSc6IFsnXFxcXHB7UH0nLCB0cnVlXSxcbiAgICAnWzpzcGFjZTpdJzogWydcXFxccHtafVxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLCB0cnVlXSxcbiAgICAnWzp1cHBlcjpdJzogWydcXFxccHtMdX0nLCB0cnVlXSxcbiAgICAnWzp3b3JkOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9XFxcXHB7TmR9XFxcXHB7UGN9JywgdHJ1ZV0sXG4gICAgJ1s6eGRpZ2l0Ol0nOiBbJ0EtRmEtZjAtOScsIGZhbHNlXSxcbn07XG4vLyBvbmx5IG5lZWQgdG8gZXNjYXBlIGEgZmV3IHRoaW5ncyBpbnNpZGUgb2YgYnJhY2UgZXhwcmVzc2lvbnNcbi8vIGVzY2FwZXM6IFsgXFwgXSAtXG5jb25zdCBicmFjZUVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1tbXFxdXFxcXC1dL2csICdcXFxcJCYnKTtcbi8vIGVzY2FwZSBhbGwgcmVnZXhwIG1hZ2ljIGNoYXJhY3RlcnNcbmNvbnN0IHJlZ2V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4vLyBldmVyeXRoaW5nIGhhcyBhbHJlYWR5IGJlZW4gZXNjYXBlZCwgd2UganVzdCBoYXZlIHRvIGpvaW5cbmNvbnN0IHJhbmdlc1RvU3RyaW5nID0gKHJhbmdlcykgPT4gcmFuZ2VzLmpvaW4oJycpO1xuLy8gdGFrZXMgYSBnbG9iIHN0cmluZyBhdCBhIHBvc2l4IGJyYWNlIGV4cHJlc3Npb24sIGFuZCByZXR1cm5zXG4vLyBhbiBlcXVpdmFsZW50IHJlZ3VsYXIgZXhwcmVzc2lvbiBzb3VyY2UsIGFuZCBib29sZWFuIGluZGljYXRpbmdcbi8vIHdoZXRoZXIgdGhlIC91IGZsYWcgbmVlZHMgdG8gYmUgYXBwbGllZCwgYW5kIHRoZSBudW1iZXIgb2YgY2hhcnNcbi8vIGNvbnN1bWVkIHRvIHBhcnNlIHRoZSBjaGFyYWN0ZXIgY2xhc3MuXG4vLyBUaGlzIGFsc28gcmVtb3ZlcyBvdXQgb2Ygb3JkZXIgcmFuZ2VzLCBhbmQgcmV0dXJucyAoJC4pIGlmIHRoZVxuLy8gZW50aXJlIGNsYXNzIGp1c3Qgbm8gZ29vZC5cbmNvbnN0IHBhcnNlQ2xhc3MgPSAoZ2xvYiwgcG9zaXRpb24pID0+IHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbjtcbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAoZ2xvYi5jaGFyQXQocG9zKSAhPT0gJ1snKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGluIGEgYnJhY2UgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGNvbnN0IG5lZ3MgPSBbXTtcbiAgICBsZXQgaSA9IHBvcyArIDE7XG4gICAgbGV0IHNhd1N0YXJ0ID0gZmFsc2U7XG4gICAgbGV0IHVmbGFnID0gZmFsc2U7XG4gICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgbGV0IG5lZ2F0ZSA9IGZhbHNlO1xuICAgIGxldCBlbmRQb3MgPSBwb3M7XG4gICAgbGV0IHJhbmdlU3RhcnQgPSAnJztcbiAgICBXSElMRTogd2hpbGUgKGkgPCBnbG9iLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gZ2xvYi5jaGFyQXQoaSk7XG4gICAgICAgIGlmICgoYyA9PT0gJyEnIHx8IGMgPT09ICdeJykgJiYgaSA9PT0gcG9zICsgMSkge1xuICAgICAgICAgICAgbmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnXScgJiYgc2F3U3RhcnQgJiYgIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICBlbmRQb3MgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNhd1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgaWYgKCFlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVkIFxcIGNoYXIsIGZhbGwgdGhyb3VnaCBhbmQgdHJlYXQgbGlrZSBub3JtYWwgY2hhclxuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAnWycgJiYgIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICAvLyBlaXRoZXIgYSBwb3NpeCBjbGFzcywgYSBjb2xsYXRpb24gZXF1aXZhbGVudCwgb3IganVzdCBhIFtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NscywgW3VuaXAsIHUsIG5lZ11dIG9mIE9iamVjdC5lbnRyaWVzKHBvc2l4Q2xhc3NlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKGNscywgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZCwgW2EtW10gaXMgZmluZSwgYnV0IG5vdCBbYS1bOmFscGhhXV1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpICs9IGNscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWdzLnB1c2godW5pcCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICB1ZmxhZyA9IHVmbGFnIHx8IHU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIFdISUxFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgaXQncyBqdXN0IGEgbm9ybWFsIGNoYXJhY3RlciwgZWZmZWN0aXZlbHlcbiAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgIC8vIHRocm93IHRoaXMgcmFuZ2UgYXdheSBpZiBpdCdzIG5vdCB2YWxpZCwgYnV0IG90aGVyc1xuICAgICAgICAgICAgLy8gY2FuIHN0aWxsIG1hdGNoLlxuICAgICAgICAgICAgaWYgKGMgPiByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUocmFuZ2VTdGFydCkgKyAnLScgKyBicmFjZUVzY2FwZShjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2VTdGFydCA9ICcnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IG1pZ2h0IGJlIHRoZSBzdGFydCBvZiBhIHJhbmdlLlxuICAgICAgICAvLyBjYW4gYmUgZWl0aGVyIGMtZCBvciBjLV0gb3IgYzxtb3JlLi4uPl0gb3IgY10gYXQgdGhpcyBwb2ludFxuICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKCctXScsIGkgKyAxKSkge1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYyArICctJykpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLScsIGkgKyAxKSkge1xuICAgICAgICAgICAgcmFuZ2VTdGFydCA9IGM7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgdGhlIHN0YXJ0IG9mIGEgcmFuZ2UsIGp1c3QgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoZW5kUG9zIDwgaSkge1xuICAgICAgICAvLyBkaWRuJ3Qgc2VlIHRoZSBlbmQgb2YgdGhlIGNsYXNzLCBub3QgYSB2YWxpZCBjbGFzcyxcbiAgICAgICAgLy8gYnV0IG1pZ2h0IHN0aWxsIGJlIHZhbGlkIGFzIGEgbGl0ZXJhbCBtYXRjaC5cbiAgICAgICAgcmV0dXJuIFsnJywgZmFsc2UsIDAsIGZhbHNlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG5vIHJhbmdlcyBhbmQgbm8gbmVnYXRlcywgdGhlbiB3ZSBoYXZlIGEgcmFuZ2UgdGhhdFxuICAgIC8vIGNhbm5vdCBwb3NzaWJseSBtYXRjaCBhbnl0aGluZywgYW5kIHRoYXQgcG9pc29ucyB0aGUgd2hvbGUgZ2xvYlxuICAgIGlmICghcmFuZ2VzLmxlbmd0aCAmJiAhbmVncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFsnJC4nLCBmYWxzZSwgZ2xvYi5sZW5ndGggLSBwb3MsIHRydWVdO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3Qgb25lIHBvc2l0aXZlIHJhbmdlLCBhbmQgaXQncyBhIHNpbmdsZSBjaGFyYWN0ZXIsIHRoZW4gdGhhdCdzXG4gICAgLy8gbm90IGFjdHVhbGx5IGEgbWFnaWMgcGF0dGVybiwgaXQncyBqdXN0IHRoYXQgb25lIGxpdGVyYWwgY2hhcmFjdGVyLlxuICAgIC8vIHdlIHNob3VsZCBub3QgdHJlYXQgdGhhdCBhcyBcIm1hZ2ljXCIsIHdlIHNob3VsZCBqdXN0IHJldHVybiB0aGUgbGl0ZXJhbFxuICAgIC8vIGNoYXJhY3Rlci4gW19dIGlzIGEgcGVyZmVjdGx5IHZhbGlkIHdheSB0byBlc2NhcGUgZ2xvYiBtYWdpYyBjaGFycy5cbiAgICBpZiAobmVncy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgcmFuZ2VzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAvXlxcXFw/LiQvLnRlc3QocmFuZ2VzWzBdKSAmJlxuICAgICAgICAhbmVnYXRlKSB7XG4gICAgICAgIGNvbnN0IHIgPSByYW5nZXNbMF0ubGVuZ3RoID09PSAyID8gcmFuZ2VzWzBdLnNsaWNlKC0xKSA6IHJhbmdlc1swXTtcbiAgICAgICAgcmV0dXJuIFtyZWdleHBFc2NhcGUociksIGZhbHNlLCBlbmRQb3MgLSBwb3MsIGZhbHNlXTtcbiAgICB9XG4gICAgY29uc3Qgc3JhbmdlcyA9ICdbJyArIChuZWdhdGUgPyAnXicgOiAnJykgKyByYW5nZXNUb1N0cmluZyhyYW5nZXMpICsgJ10nO1xuICAgIGNvbnN0IHNuZWdzID0gJ1snICsgKG5lZ2F0ZSA/ICcnIDogJ14nKSArIHJhbmdlc1RvU3RyaW5nKG5lZ3MpICsgJ10nO1xuICAgIGNvbnN0IGNvbWIgPSByYW5nZXMubGVuZ3RoICYmIG5lZ3MubGVuZ3RoXG4gICAgICAgID8gJygnICsgc3JhbmdlcyArICd8JyArIHNuZWdzICsgJyknXG4gICAgICAgIDogcmFuZ2VzLmxlbmd0aFxuICAgICAgICAgICAgPyBzcmFuZ2VzXG4gICAgICAgICAgICA6IHNuZWdzO1xuICAgIHJldHVybiBbY29tYiwgdWZsYWcsIGVuZFBvcyAtIHBvcywgdHJ1ZV07XG59O1xuZXhwb3J0cy5wYXJzZUNsYXNzID0gcGFyc2VDbGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyYWNlLWV4cHJlc3Npb25zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlQ2xhc3MiLCJwb3NpeENsYXNzZXMiLCJicmFjZUVzY2FwZSIsInMiLCJyZXBsYWNlIiwicmVnZXhwRXNjYXBlIiwicmFuZ2VzVG9TdHJpbmciLCJyYW5nZXMiLCJqb2luIiwiZ2xvYiIsInBvc2l0aW9uIiwicG9zIiwiY2hhckF0IiwiRXJyb3IiLCJuZWdzIiwiaSIsInNhd1N0YXJ0IiwidWZsYWciLCJlc2NhcGluZyIsIm5lZ2F0ZSIsImVuZFBvcyIsInJhbmdlU3RhcnQiLCJXSElMRSIsImxlbmd0aCIsImMiLCJjbHMiLCJ1bmlwIiwidSIsIm5lZyIsImVudHJpZXMiLCJzdGFydHNXaXRoIiwicHVzaCIsInRlc3QiLCJyIiwic2xpY2UiLCJzcmFuZ2VzIiwic25lZ3MiLCJjb21iIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js":
/*!**************************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.escape = void 0;\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */ const escape = (s, { windowsPathsNoEscape = false } = {})=>{\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape ? s.replace(/[?*()[\\]]/g, \"[$&]\") : s.replace(/[?*()[\\]\\\\]/g, \"\\\\$&\");\n};\nexports.escape = escape; //# sourceMappingURL=escape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvZXNjYXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0Qjs7Ozs7Ozs7Q0FRQyxHQUNELE1BQU1FLFNBQVMsQ0FBQ0MsR0FBRyxFQUFFQyx1QkFBdUIsS0FBSyxFQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3JELHdEQUF3RDtJQUN4RCw0REFBNEQ7SUFDNUQsc0RBQXNEO0lBQ3RELE9BQU9BLHVCQUNERCxFQUFFRSxPQUFPLENBQUMsY0FBYyxVQUN4QkYsRUFBRUUsT0FBTyxDQUFDLGdCQUFnQjtBQUNwQztBQUNBTCxjQUFjLEdBQUdFLFFBQ2pCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvZXNjYXBlLmpzPzljYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVzY2FwZSA9IHZvaWQgMDtcbi8qKlxuICogRXNjYXBlIGFsbCBtYWdpYyBjaGFyYWN0ZXJzIGluIGEgZ2xvYiBwYXR0ZXJuLlxuICpcbiAqIElmIHRoZSB7QGxpbmsgd2luZG93c1BhdGhzTm9Fc2NhcGUgfCBHbG9iT3B0aW9ucy53aW5kb3dzUGF0aHNOb0VzY2FwZX1cbiAqIG9wdGlvbiBpcyB1c2VkLCB0aGVuIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQgYnkgd3JhcHBpbmcgaW4gYFtdYCwgYmVjYXVzZVxuICogYSBtYWdpYyBjaGFyYWN0ZXIgd3JhcHBlZCBpbiBhIGNoYXJhY3RlciBjbGFzcyBjYW4gb25seSBiZSBzYXRpc2ZpZWQgYnlcbiAqIHRoYXQgZXhhY3QgY2hhcmFjdGVyLiAgSW4gdGhpcyBtb2RlLCBgXFxgIGlzIF9ub3RfIGVzY2FwZWQsIGJlY2F1c2UgaXQgaXNcbiAqIG5vdCBpbnRlcnByZXRlZCBhcyBhIG1hZ2ljIGNoYXJhY3RlciwgYnV0IGluc3RlYWQgYXMgYSBwYXRoIHNlcGFyYXRvci5cbiAqL1xuY29uc3QgZXNjYXBlID0gKHMsIHsgd2luZG93c1BhdGhzTm9Fc2NhcGUgPSBmYWxzZSwgfSA9IHt9KSA9PiB7XG4gICAgLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgK0AhIGJlY2F1c2Ugd2UgZXNjYXBlIHRoZSBwYXJlbnNcbiAgICAvLyB0aGF0IG1ha2UgdGhvc2UgbWFnaWMsIGFuZCBlc2NhcGluZyAhIGFzIFshXSBpc24ndCB2YWxpZCxcbiAgICAvLyBiZWNhdXNlIFshXV0gaXMgYSB2YWxpZCBnbG9iIGNsYXNzIG1lYW5pbmcgbm90ICddJy5cbiAgICByZXR1cm4gd2luZG93c1BhdGhzTm9Fc2NhcGVcbiAgICAgICAgPyBzLnJlcGxhY2UoL1s/KigpW1xcXV0vZywgJ1skJl0nKVxuICAgICAgICA6IHMucmVwbGFjZSgvWz8qKClbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufTtcbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVzY2FwZSIsInMiLCJ3aW5kb3dzUGF0aHNOb0VzY2FwZSIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(__webpack_require__(/*! brace-expansion */ \"(rsc)/./node_modules/glob/node_modules/brace-expansion/index.js\"));\nconst assert_valid_pattern_js_1 = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\");\nconst ast_js_1 = __webpack_require__(/*! ./ast.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js\");\nconst escape_js_1 = __webpack_require__(/*! ./escape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js\");\nconst minimatch = (p, pattern, options = {})=>{\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext)=>(f)=>!f.startsWith(\".\") && f.endsWith(ext);\nconst starDotExtTestDot = (ext)=>(f)=>f.endsWith(ext);\nconst starDotExtTestNocase = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>!f.startsWith(\".\") && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext)=>{\n    ext = ext.toLowerCase();\n    return (f)=>f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f)=>!f.startsWith(\".\") && f.includes(\".\");\nconst starDotStarTestDot = (f)=>f !== \".\" && f !== \"..\" && f.includes(\".\");\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f)=>f !== \".\" && f !== \"..\" && f.startsWith(\".\");\nconst starRE = /^\\*+$/;\nconst starTest = (f)=>f.length !== 0 && !f.startsWith(\".\");\nconst starTestDot = (f)=>f.length !== 0 && f !== \".\" && f !== \"..\";\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    if (!ext) return noext;\n    ext = ext.toLowerCase();\n    return (f)=>noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExtDot([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = \"\"])=>{\n    const noext = qmarksTestNoExt([\n        $0\n    ]);\n    return !ext ? noext : (f)=>noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && !f.startsWith(\".\");\n};\nconst qmarksTestNoExtDot = ([$0])=>{\n    const len = $0.length;\n    return (f)=>f.length === len && f !== \".\" && f !== \"..\";\n};\n/* c8 ignore start */ const defaultPlatform = typeof process === \"object\" && process ? typeof process.env === \"object\" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : \"posix\";\nconst path = {\n    win32: {\n        sep: \"\\\\\"\n    },\n    posix: {\n        sep: \"/\"\n    }\n};\n/* c8 ignore stop */ exports.sep = defaultPlatform === \"win32\" ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol(\"globstar **\");\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\nconst filter = (pattern, options = {})=>(p)=>(0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {})=>Object.assign({}, a, b);\nconst defaults = (def)=>{\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {})=>orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}){\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */ constructor(type, parent, options = {}){\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */ static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {})=>orig.unescape(s, ext(def, options)),\n        escape: (s, options = {})=>orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {})=>orig.filter(pattern, ext(def, options)),\n        defaults: (options)=>orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {})=>orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {})=>orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {})=>orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {})=>{\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {})=>new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {})=>{\n    const mm = new Minimatch(pattern, options);\n    list = list.filter((f)=>mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\nclass Minimatch {\n    constructor(pattern, options = {}){\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === \"win32\";\n        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, \"/\");\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set){\n            for (const part of pattern){\n                if (typeof part !== \"string\") return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) {}\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === \"#\") {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [\n            ...new Set(this.braceExpand())\n        ];\n        if (options.debug) {\n            this.debug = (...args)=>console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map((s)=>this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __)=>{\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === \"\" && s[1] === \"\" && (s[2] === \"?\" || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [\n                        ...s.slice(0, 4),\n                        ...s.slice(4).map((ss)=>this.parse(ss))\n                    ];\n                } else if (isDrive) {\n                    return [\n                        s[0],\n                        ...s.slice(1).map((ss)=>this.parse(ss))\n                    ];\n                }\n            }\n            return s.map((ss)=>this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter((s)=>s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for(let i = 0; i < this.set.length; i++){\n                const p = this.set[i];\n                if (p[0] === \"\" && p[1] === \"\" && this.globParts[i][2] === \"?\" && typeof p[3] === \"string\" && /^[a-z]:$/i.test(p[3])) {\n                    p[2] = \"?\";\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for(let i = 0; i < globParts.length; i++){\n                for(let j = 0; j < globParts[i].length; j++){\n                    if (globParts[i][j] === \"**\") {\n                        globParts[i][j] = \"*\";\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        } else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        } else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map((parts)=>{\n            let gs = -1;\n            while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                let i = gs;\n                while(parts[i + 1] === \"**\"){\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map((parts)=>{\n            parts = parts.reduce((set, part)=>{\n                const prev = set[set.length - 1];\n                if (part === \"**\" && prev === \"**\") {\n                    return set;\n                }\n                if (part === \"..\") {\n                    if (prev && prev !== \"..\" && prev !== \".\" && prev !== \"**\") {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [\n                \"\"\n            ] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for(let i = 1; i < parts.length - 1; i++){\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                    if (p === \".\" || p === \"\") {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                const p = parts[dd - 1];\n                if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        }while (didSomething);\n        return parts.length === 0 ? [\n            \"\"\n        ] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts){\n                let gs = -1;\n                while(-1 !== (gs = parts.indexOf(\"**\", gs + 1))){\n                    let gss = gs;\n                    while(parts[gss + 1] === \"**\"){\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== \"..\") continue;\n                    if (!p || p === \".\" || p === \"..\" || !p2 || p2 === \".\" || p2 === \"..\") {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = \"**\";\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for(let i = 1; i < parts.length - 1; i++){\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === \"\" && parts[0] === \"\") continue;\n                        if (p === \".\" || p === \"\") {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === \".\" && parts.length === 2 && (parts[1] === \".\" || parts[1] === \"\")) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while(-1 !== (dd = parts.indexOf(\"..\", dd + 1))){\n                    const p = parts[dd - 1];\n                    if (p && p !== \".\" && p !== \"..\" && p !== \"**\") {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === \"**\";\n                        const splin = needDot ? [\n                            \".\"\n                        ] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0) parts.push(\"\");\n                        dd -= 2;\n                    }\n                }\n            }\n        }while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for(let i = 0; i < globParts.length - 1; i++){\n            for(let j = i + 1; j < globParts.length; j++){\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter((gs)=>gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = \"\";\n        while(ai < a.length && bi < b.length){\n            if (a[ai] === b[bi]) {\n                result.push(which === \"b\" ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            } else if (emptyGSMatch && a[ai] === \"**\" && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            } else if (emptyGSMatch && b[bi] === \"**\" && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            } else if (a[ai] === \"*\" && b[bi] && (this.options.dot || !b[bi].startsWith(\".\")) && b[bi] !== \"**\") {\n                if (which === \"b\") return false;\n                which = \"a\";\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            } else if (b[bi] === \"*\" && a[ai] && (this.options.dot || !a[ai].startsWith(\".\")) && a[ai] !== \"**\") {\n                if (which === \"a\") return false;\n                which = \"b\";\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            } else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate) return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for(let i = 0; i < pattern.length && pattern.charAt(i) === \"!\"; i++){\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset) this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === \"string\" && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive && file[0] === \"\" && file[1] === \"\" && file[2] === \"?\" && /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === \"string\" && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive && pattern[0] === \"\" && pattern[1] === \"\" && pattern[2] === \"?\" && typeof pattern[3] === \"string\" && /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === \"number\" && typeof pdi === \"number\") {\n                const [fd, pd] = [\n                    file[fdi],\n                    pattern[pdi]\n                ];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    } else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug(\"matchOne\", this, {\n            file,\n            pattern\n        });\n        this.debug(\"matchOne\", file.length, pattern.length);\n        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n            this.debug(\"matchOne loop\");\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */ if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */ if (p === exports.GLOBSTAR) {\n                this.debug(\"GLOBSTAR\", [\n                    pattern,\n                    p,\n                    f\n                ]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug(\"** at the end\");\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for(; fi < fl; fi++){\n                        if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while(fr < fl){\n                    var swallowee = file[fr];\n                    this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug(\"globstar found match!\", fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    } else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                            this.debug(\"dot detected!\", file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug(\"globstar swallow a segment, and continue\");\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */ if (partial) {\n                    // ran out of file\n                    this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */ return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === \"string\") {\n                hit = f === p;\n                this.debug(\"string match\", p, f, hit);\n            } else {\n                hit = p.test(f);\n                this.debug(\"pattern match\", p, f, hit);\n            }\n            if (!hit) return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        } else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        } else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === \"\";\n        /* c8 ignore start */ } else {\n            // should be unreachable.\n            throw new Error(\"wtf?\");\n        }\n    /* c8 ignore stop */ }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === \"**\") return exports.GLOBSTAR;\n        if (pattern === \"\") return \"\";\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if (m = pattern.match(starRE)) {\n            fastTest = options.dot ? starTestDot : starTest;\n        } else if (m = pattern.match(starDotExtRE)) {\n            fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n        } else if (m = pattern.match(qmarksRE)) {\n            fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n        } else if (m = pattern.match(starDotStarRE)) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        } else if (m = pattern.match(dotStarRE)) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === \"object\") {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, \"test\", {\n                value: fastTest\n            });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false) return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n        const flags = new Set(options.nocase ? [\n            \"i\"\n        ] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set.map((pattern)=>{\n            const pp = pattern.map((p)=>{\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(\"\"))flags.add(f);\n                }\n                return typeof p === \"string\" ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;\n            });\n            pp.forEach((p, i)=>{\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = \"(?:\\\\/|\" + twoStar + \"\\\\/)?\" + next;\n                    } else {\n                        pp[i] = twoStar;\n                    }\n                } else if (next === undefined) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\" + twoStar + \")?\";\n                } else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + \"(?:\\\\/|\\\\/\" + twoStar + \"\\\\/)\" + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter((p)=>p !== exports.GLOBSTAR).join(\"/\");\n        }).join(\"|\");\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? [\n            \"(?:\",\n            \")\"\n        ] : [\n            \"\",\n            \"\"\n        ];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = \"^\" + open + re + close + \"$\";\n        // can match anything, as long as it's not this.\n        if (this.negate) re = \"^(?!\" + re + \").+$\";\n        try {\n            this.regexp = new RegExp(re, [\n                ...flags\n            ].join(\"\"));\n        /* c8 ignore start */ } catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */ return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split(\"/\");\n        } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return [\n                \"\",\n                ...p.split(/\\/+/)\n            ];\n        } else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug(\"match\", f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === \"\";\n        }\n        if (f === \"/\" && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split(\"\\\\\").join(\"/\");\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, \"split\", ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, \"set\", set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for(let i = ff.length - 2; !filename && i >= 0; i--){\n                filename = ff[i];\n            }\n        }\n        for(let i = 0; i < set.length; i++){\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [\n                    filename\n                ];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */ var ast_js_2 = __webpack_require__(/*! ./ast.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js\");\nObject.defineProperty(exports, \"AST\", ({\n    enumerable: true,\n    get: function() {\n        return ast_js_2.AST;\n    }\n}));\nvar escape_js_2 = __webpack_require__(/*! ./escape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js\");\nObject.defineProperty(exports, \"escape\", ({\n    enumerable: true,\n    get: function() {\n        return escape_js_2.escape;\n    }\n}));\nvar unescape_js_2 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js\");\nObject.defineProperty(exports, \"unescape\", ({\n    enumerable: true,\n    get: function() {\n        return unescape_js_2.unescape;\n    }\n}));\n/* c8 ignore stop */ exports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHQSxXQUFXLEdBQUdBLGlCQUFpQixHQUFHQSxhQUFhLEdBQUdBLGNBQWMsR0FBR0EsbUJBQW1CLEdBQUdBLGdCQUFnQixHQUFHQSxjQUFjLEdBQUdBLGdCQUFnQixHQUFHQSxXQUFXLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDM04sTUFBTWMsb0JBQW9CbkIsZ0JBQWdCb0IsbUJBQU9BLENBQUMsd0ZBQWlCO0FBQ25FLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMseUhBQTJCO0FBQ3JFLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHVGQUFVO0FBQ25DLE1BQU1HLGNBQWNILG1CQUFPQSxDQUFDLDZGQUFhO0FBQ3pDLE1BQU1JLGdCQUFnQkosbUJBQU9BLENBQUMsaUdBQWU7QUFDN0MsTUFBTUYsWUFBWSxDQUFDTyxHQUFHQyxTQUFTQyxVQUFVLENBQUMsQ0FBQztJQUN0QyxJQUFHTiwwQkFBMEJPLGtCQUFrQixFQUFFRjtJQUNsRCxvQ0FBb0M7SUFDcEMsSUFBSSxDQUFDQyxRQUFRRSxTQUFTLElBQUlILFFBQVFJLE1BQU0sQ0FBQyxPQUFPLEtBQUs7UUFDakQsT0FBTztJQUNYO0lBQ0EsT0FBTyxJQUFJcEIsVUFBVWdCLFNBQVNDLFNBQVNoQixLQUFLLENBQUNjO0FBQ2pEO0FBQ0FwQixpQkFBaUIsR0FBR2E7QUFDcEIsd0RBQXdEO0FBQ3hELE1BQU1hLGVBQWU7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O1FBQ0EsT0FBTyxJQUFJLENBQUN6RyxNQUFNO0lBQ3RCO0lBQ0EsT0FBT3ZGLFNBQVMrRCxHQUFHLEVBQUU7UUFDakIsT0FBT3hFLFFBQVFhLFNBQVMsQ0FBQ0osUUFBUSxDQUFDK0QsS0FBS25FLFNBQVM7SUFDcEQ7QUFDSjtBQUNBTCxpQkFBaUIsR0FBR0s7QUFDcEIsbUJBQW1CLEdBQ25CLElBQUlxTSxXQUFXM0wsbUJBQU9BLENBQUMsdUZBQVU7QUFDakNqQix1Q0FBc0M7SUFBRTZNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLFNBQVN0TSxHQUFHO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdEcsSUFBSXlNLGNBQWM5TCxtQkFBT0EsQ0FBQyw2RkFBYTtBQUN2Q2pCLDBDQUF5QztJQUFFNk0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsWUFBWTFNLE1BQU07SUFBRTtBQUFFLENBQUMsRUFBQztBQUMvRyxJQUFJMk0sZ0JBQWdCL0wsbUJBQU9BLENBQUMsaUdBQWU7QUFDM0NqQiw0Q0FBMkM7SUFBRTZNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLGNBQWM1TSxRQUFRO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckgsa0JBQWtCLEdBQ2xCRixxQkFBcUIsR0FBR2lCLFNBQVNiLEdBQUc7QUFDcENKLDJCQUEyQixHQUFHSztBQUM5Qkwsd0JBQXdCLEdBQUdrQixZQUFZZixNQUFNO0FBQzdDSCwwQkFBMEIsR0FBR21CLGNBQWNqQixRQUFRLEVBQ25ELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvaW5kZXguanM/MDRlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5lc2NhcGUgPSBleHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuQVNUID0gZXhwb3J0cy5NaW5pbWF0Y2ggPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5tYWtlUmUgPSBleHBvcnRzLmJyYWNlRXhwYW5kID0gZXhwb3J0cy5kZWZhdWx0cyA9IGV4cG9ydHMuZmlsdGVyID0gZXhwb3J0cy5HTE9CU1RBUiA9IGV4cG9ydHMuc2VwID0gZXhwb3J0cy5taW5pbWF0Y2ggPSB2b2lkIDA7XG5jb25zdCBicmFjZV9leHBhbnNpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYnJhY2UtZXhwYW5zaW9uXCIpKTtcbmNvbnN0IGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEgPSByZXF1aXJlKFwiLi9hc3NlcnQtdmFsaWQtcGF0dGVybi5qc1wiKTtcbmNvbnN0IGFzdF9qc18xID0gcmVxdWlyZShcIi4vYXN0LmpzXCIpO1xuY29uc3QgZXNjYXBlX2pzXzEgPSByZXF1aXJlKFwiLi9lc2NhcGUuanNcIik7XG5jb25zdCB1bmVzY2FwZV9qc18xID0gcmVxdWlyZShcIi4vdW5lc2NhcGUuanNcIik7XG5jb25zdCBtaW5pbWF0Y2ggPSAocCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgKDAsIGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEuYXNzZXJ0VmFsaWRQYXR0ZXJuKShwYXR0ZXJuKTtcbiAgICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKTtcbn07XG5leHBvcnRzLm1pbmltYXRjaCA9IG1pbmltYXRjaDtcbi8vIE9wdGltaXplZCBjaGVja2luZyBmb3IgdGhlIG1vc3QgY29tbW9uIGdsb2IgcGF0dGVybnMuXG5jb25zdCBzdGFyRG90RXh0UkUgPSAvXlxcKisoW14rQCE/XFwqXFxbXFwoXSopJC87XG5jb25zdCBzdGFyRG90RXh0VGVzdCA9IChleHQpID0+IChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi5lbmRzV2l0aChleHQpO1xuY29uc3Qgc3RhckRvdEV4dFRlc3REb3QgPSAoZXh0KSA9PiAoZikgPT4gZi5lbmRzV2l0aChleHQpO1xuY29uc3Qgc3RhckRvdEV4dFRlc3ROb2Nhc2UgPSAoZXh0KSA9PiB7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3Qgc3RhckRvdEV4dFRlc3ROb2Nhc2VEb3QgPSAoZXh0KSA9PiB7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBzdGFyRG90U3RhclJFID0gL15cXCorXFwuXFwqKyQvO1xuY29uc3Qgc3RhckRvdFN0YXJUZXN0ID0gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLmluY2x1ZGVzKCcuJyk7XG5jb25zdCBzdGFyRG90U3RhclRlc3REb3QgPSAoZikgPT4gZiAhPT0gJy4nICYmIGYgIT09ICcuLicgJiYgZi5pbmNsdWRlcygnLicpO1xuY29uc3QgZG90U3RhclJFID0gL15cXC5cXCorJC87XG5jb25zdCBkb3RTdGFyVGVzdCA9IChmKSA9PiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJyAmJiBmLnN0YXJ0c1dpdGgoJy4nKTtcbmNvbnN0IHN0YXJSRSA9IC9eXFwqKyQvO1xuY29uc3Qgc3RhclRlc3QgPSAoZikgPT4gZi5sZW5ndGggIT09IDAgJiYgIWYuc3RhcnRzV2l0aCgnLicpO1xuY29uc3Qgc3RhclRlc3REb3QgPSAoZikgPT4gZi5sZW5ndGggIT09IDAgJiYgZiAhPT0gJy4nICYmIGYgIT09ICcuLic7XG5jb25zdCBxbWFya3NSRSA9IC9eXFw/KyhbXitAIT9cXCpcXFtcXChdKik/JC87XG5jb25zdCBxbWFya3NUZXN0Tm9jYXNlID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHQoWyQwXSk7XG4gICAgaWYgKCFleHQpXG4gICAgICAgIHJldHVybiBub2V4dDtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IG5vZXh0KGYpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb2Nhc2VEb3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dERvdChbJDBdKTtcbiAgICBpZiAoIWV4dClcbiAgICAgICAgcmV0dXJuIG5vZXh0O1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gbm9leHQoZikgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdERvdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0RG90KFskMF0pO1xuICAgIHJldHVybiAhZXh0ID8gbm9leHQgOiAoZikgPT4gbm9leHQoZikgJiYgZi5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dChbJDBdKTtcbiAgICByZXR1cm4gIWV4dCA/IG5vZXh0IDogKGYpID0+IG5vZXh0KGYpICYmIGYuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9FeHQgPSAoWyQwXSkgPT4ge1xuICAgIGNvbnN0IGxlbiA9ICQwLmxlbmd0aDtcbiAgICByZXR1cm4gKGYpID0+IGYubGVuZ3RoID09PSBsZW4gJiYgIWYuc3RhcnRzV2l0aCgnLicpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb0V4dERvdCA9IChbJDBdKSA9PiB7XG4gICAgY29uc3QgbGVuID0gJDAubGVuZ3RoO1xuICAgIHJldHVybiAoZikgPT4gZi5sZW5ndGggPT09IGxlbiAmJiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJztcbn07XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGRlZmF1bHRQbGF0Zm9ybSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzc1xuICAgID8gKHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19NSU5JTUFUQ0hfVEVTVElOR19QTEFURk9STV9fKSB8fFxuICAgICAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAncG9zaXgnKTtcbmNvbnN0IHBhdGggPSB7XG4gICAgd2luMzI6IHsgc2VwOiAnXFxcXCcgfSxcbiAgICBwb3NpeDogeyBzZXA6ICcvJyB9LFxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5leHBvcnRzLnNlcCA9IGRlZmF1bHRQbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHBhdGgud2luMzIuc2VwIDogcGF0aC5wb3NpeC5zZXA7XG5leHBvcnRzLm1pbmltYXRjaC5zZXAgPSBleHBvcnRzLnNlcDtcbmV4cG9ydHMuR0xPQlNUQVIgPSBTeW1ib2woJ2dsb2JzdGFyICoqJyk7XG5leHBvcnRzLm1pbmltYXRjaC5HTE9CU1RBUiA9IGV4cG9ydHMuR0xPQlNUQVI7XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFwvKSkuKSo/Jztcbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pXFxcXC4pLikqPyc7XG5jb25zdCBmaWx0ZXIgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiAocCkgPT4gKDAsIGV4cG9ydHMubWluaW1hdGNoKShwLCBwYXR0ZXJuLCBvcHRpb25zKTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5taW5pbWF0Y2guZmlsdGVyID0gZXhwb3J0cy5maWx0ZXI7XG5jb25zdCBleHQgPSAoYSwgYiA9IHt9KSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCBiKTtcbmNvbnN0IGRlZmF1bHRzID0gKGRlZikgPT4ge1xuICAgIGlmICghZGVmIHx8IHR5cGVvZiBkZWYgIT09ICdvYmplY3QnIHx8ICFPYmplY3Qua2V5cyhkZWYpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5taW5pbWF0Y2g7XG4gICAgfVxuICAgIGNvbnN0IG9yaWcgPSBleHBvcnRzLm1pbmltYXRjaDtcbiAgICBjb25zdCBtID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obSwge1xuICAgICAgICBNaW5pbWF0Y2g6IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpYyBkZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLk1pbmltYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQVNUOiBjbGFzcyBBU1QgZXh0ZW5kcyBvcmlnLkFTVCB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIodHlwZSwgcGFyZW50LCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgc3RhdGljIGZyb21HbG9iKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLkFTVC5mcm9tR2xvYihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLnVuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmVzY2FwZShzLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGZpbHRlcjogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBkZWZhdWx0czogKG9wdGlvbnMpID0+IG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYWtlUmU6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgYnJhY2VFeHBhbmQ6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYXRjaDogKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIHNlcDogb3JpZy5zZXAsXG4gICAgICAgIEdMT0JTVEFSOiBleHBvcnRzLkdMT0JTVEFSLFxuICAgIH0pO1xufTtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMubWluaW1hdGNoLmRlZmF1bHRzID0gZXhwb3J0cy5kZWZhdWx0cztcbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xuY29uc3QgYnJhY2VFeHBhbmQgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgKDAsIGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEuYXNzZXJ0VmFsaWRQYXR0ZXJuKShwYXR0ZXJuKTtcbiAgICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAgIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gICAgaWYgKG9wdGlvbnMubm9icmFjZSB8fCAhL1xceyg/Oig/IVxceykuKSpcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGJyYWNlX2V4cGFuc2lvbl8xLmRlZmF1bHQpKHBhdHRlcm4pO1xufTtcbmV4cG9ydHMuYnJhY2VFeHBhbmQgPSBicmFjZUV4cGFuZDtcbmV4cG9ydHMubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gZXhwb3J0cy5icmFjZUV4cGFuZDtcbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuY29uc3QgbWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYWtlUmUoKTtcbmV4cG9ydHMubWFrZVJlID0gbWFrZVJlO1xuZXhwb3J0cy5taW5pbWF0Y2gubWFrZVJlID0gZXhwb3J0cy5tYWtlUmU7XG5jb25zdCBtYXRjaCA9IChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgbGlzdCA9IGxpc3QuZmlsdGVyKGYgPT4gbW0ubWF0Y2goZikpO1xuICAgIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgbGlzdC5wdXNoKHBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG5leHBvcnRzLm1pbmltYXRjaC5tYXRjaCA9IGV4cG9ydHMubWF0Y2g7XG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuY29uc3QgZ2xvYk1hZ2ljID0gL1s/Kl18WytAIV1cXCguKj9cXCl8XFxbfFxcXS87XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuY2xhc3MgTWluaW1hdGNoIHtcbiAgICBvcHRpb25zO1xuICAgIHNldDtcbiAgICBwYXR0ZXJuO1xuICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlO1xuICAgIG5vbmVnYXRlO1xuICAgIG5lZ2F0ZTtcbiAgICBjb21tZW50O1xuICAgIGVtcHR5O1xuICAgIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzO1xuICAgIHBhcnRpYWw7XG4gICAgZ2xvYlNldDtcbiAgICBnbG9iUGFydHM7XG4gICAgbm9jYXNlO1xuICAgIGlzV2luZG93cztcbiAgICBwbGF0Zm9ybTtcbiAgICB3aW5kb3dzTm9NYWdpY1Jvb3Q7XG4gICAgcmVnZXhwO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdGlvbnMucGxhdGZvcm0gfHwgZGVmYXVsdFBsYXRmb3JtO1xuICAgICAgICB0aGlzLmlzV2luZG93cyA9IHRoaXMucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8IG9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlID09PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHRoaXMucGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyA9ICEhb3B0aW9ucy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICAgICAgdGhpcy5yZWdleHAgPSBudWxsO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vbmVnYXRlID0gISFvcHRpb25zLm5vbmVnYXRlO1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWwgPSAhIW9wdGlvbnMucGFydGlhbDtcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSAhIXRoaXMub3B0aW9ucy5ub2Nhc2U7XG4gICAgICAgIHRoaXMud2luZG93c05vTWFnaWNSb290ID1cbiAgICAgICAgICAgIG9wdGlvbnMud2luZG93c05vTWFnaWNSb290ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMud2luZG93c05vTWFnaWNSb290XG4gICAgICAgICAgICAgICAgOiAhISh0aGlzLmlzV2luZG93cyAmJiB0aGlzLm5vY2FzZSk7XG4gICAgICAgIHRoaXMuZ2xvYlNldCA9IFtdO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNldCA9IFtdO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gICAgICAgIHRoaXMubWFrZSgpO1xuICAgIH1cbiAgICBoYXNNYWdpYygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYWdpY2FsQnJhY2VzICYmIHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnNldCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYnVnKC4uLl8pIHsgfVxuICAgIG1ha2UoKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgICAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgICAgICAgdGhpcy5wYXJzZU5lZ2F0ZSgpO1xuICAgICAgICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gWy4uLm5ldyBTZXQodGhpcy5icmFjZUV4cGFuZCgpKV07XG4gICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnID0gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuZ2xvYlNldCk7XG4gICAgICAgIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZlxuICAgICAgICAvLyBwYXRoLXBvcnRpb24gbWF0Y2hpbmcgcGF0dGVybnMuXG4gICAgICAgIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgICAgICAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpcnN0LCB3ZSBwcmVwcm9jZXNzIHRvIG1ha2UgdGhlIGdsb2IgcGF0dGVybiBzZXRzIGEgYml0IHNpbXBsZXJcbiAgICAgICAgLy8gYW5kIGRlZHVwZWQuICBUaGVyZSBhcmUgc29tZSBwZXJmLWtpbGxpbmcgcGF0dGVybnMgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgLy8gcHJvYmxlbXMgd2l0aCBhIGdsb2Igd2FsaywgYnV0IHdlIGNhbiBzaW1wbGlmeSB0aGVtIGRvd24gYSBiaXQuXG4gICAgICAgIGNvbnN0IHJhd0dsb2JQYXJ0cyA9IHRoaXMuZ2xvYlNldC5tYXAocyA9PiB0aGlzLnNsYXNoU3BsaXQocykpO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IHRoaXMucHJlcHJvY2VzcyhyYXdHbG9iUGFydHMpO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iUGFydHMpO1xuICAgICAgICAvLyBnbG9iIC0tPiByZWdleHBzXG4gICAgICAgIGxldCBzZXQgPSB0aGlzLmdsb2JQYXJ0cy5tYXAoKHMsIF8sIF9fKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MgJiYgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIGEgZHJpdmUgb3IgdW5jIHBhdGguXG4gICAgICAgICAgICAgICAgY29uc3QgaXNVTkMgPSBzWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBzWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICAoc1syXSA9PT0gJz8nIHx8ICFnbG9iTWFnaWMudGVzdChzWzJdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWdsb2JNYWdpYy50ZXN0KHNbM10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRHJpdmUgPSAvXlthLXpdOi9pLnRlc3Qoc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVU5DKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucy5zbGljZSgwLCA0KSwgLi4ucy5zbGljZSg0KS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEcml2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NbMF0sIC4uLnMuc2xpY2UoMSkubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHMubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpO1xuICAgICAgICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5zZXQgPSBzZXQuZmlsdGVyKHMgPT4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTEpO1xuICAgICAgICAvLyBkbyBub3QgdHJlYXQgdGhlID8gaW4gVU5DIHBhdGhzIGFzIG1hZ2ljXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnNldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocFswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iUGFydHNbaV1bMl0gPT09ICc/JyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcFszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gJz8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5zZXQpO1xuICAgIH1cbiAgICAvLyB2YXJpb3VzIHRyYW5zZm9ybXMgdG8gZXF1aXZhbGVudCBwYXR0ZXJuIHNldHMgdGhhdCBhcmVcbiAgICAvLyBmYXN0ZXIgdG8gcHJvY2VzcyBpbiBhIGZpbGVzeXN0ZW0gd2Fsay4gIFRoZSBnb2FsIGlzIHRvXG4gICAgLy8gZWxpbWluYXRlIHdoYXQgd2UgY2FuLCBhbmQgcHVzaCBhbGwgKiogcGF0dGVybnMgYXMgZmFyXG4gICAgLy8gdG8gdGhlIHJpZ2h0IGFzIHBvc3NpYmxlLCBldmVuIGlmIGl0IGluY3JlYXNlcyB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGF0dGVybnMgdGhhdCB3ZSBoYXZlIHRvIHByb2Nlc3MuXG4gICAgcHJlcHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgbm90IGluIGdsb2JzdGFyIG1vZGUsIHRoZW4gdHVybiBhbGwgKiogaW50byAqXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdsb2JQYXJ0c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYlBhcnRzW2ldW2pdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbaV1bal0gPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIC8vIGFnZ3Jlc3NpdmUgb3B0aW1pemF0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBmcyB3YWxraW5nXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLnNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDEpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgYmFzaWMgb3B0aW1pemF0aW9ucyB0byByZW1vdmUgc29tZSAuLiBwYXJ0c1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5sZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqdXN0IGNvbGxhcHNlIG11bHRpcGxlICoqIHBvcnRpb25zIGludG8gb25lXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBqdXN0IGdldCByaWQgb2YgYWRqYXNjZW50ICoqIHBvcnRpb25zXG4gICAgYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChncyA9IHBhcnRzLmluZGV4T2YoJyoqJywgZ3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGdzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tpICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzLCBpIC0gZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGdldCByaWQgb2YgYWRqYXNjZW50ICoqIGFuZCByZXNvbHZlIC4uIHBvcnRpb25zXG4gICAgbGV2ZWxPbmVPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgcGFydHMgPSBwYXJ0cy5yZWR1Y2UoKHNldCwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnKionICYmIHByZXYgPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJy4uJyAmJiBwcmV2ICE9PSAnLicgJiYgcHJldiAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldmVsVHdvRmlsZU9wdGltaXplKHBhcnRzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJ0cykpIHtcbiAgICAgICAgICAgIHBhcnRzID0gdGhpcy5zbGFzaFNwbGl0KHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3F1ZWV6ZSBvdXQgVU5DIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gJy4nIHx8IHAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZGQgPSBwYXJ0cy5pbmRleE9mKCcuLicsIGRkICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFNvbWV0aGluZyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBbJyddIDogcGFydHM7XG4gICAgfVxuICAgIC8vIEZpcnN0IHBoYXNlOiBzaW5nbGUtcGF0dGVybiBwcm9jZXNzaW5nXG4gICAgLy8gPHByZT4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHJlc3Q+IGlzIDEgb3IgbW9yZSBwb3J0aW9uc1xuICAgIC8vIDxwPiBpcyBhbnkgcG9ydGlvbiBvdGhlciB0aGFuIC4sIC4uLCAnJywgb3IgKipcbiAgICAvLyA8ZT4gaXMgLiBvciAnJ1xuICAgIC8vXG4gICAgLy8gKiovLi4gaXMgKmJydXRhbCogZm9yIGZpbGVzeXN0ZW0gd2Fsa2luZyBwZXJmb3JtYW5jZSwgYmVjYXVzZVxuICAgIC8vIGl0IGVmZmVjdGl2ZWx5IHJlc2V0cyB0aGUgcmVjdXJzaXZlIHdhbGsgZWFjaCB0aW1lIGl0IG9jY3VycyxcbiAgICAvLyBhbmQgKiogY2Fubm90IGJlIHJlZHVjZWQgb3V0IGJ5IGEgLi4gcGF0dGVybiBwYXJ0IGxpa2UgYSByZWdleHBcbiAgICAvLyBvciBtb3N0IHN0cmluZ3MgKG90aGVyIHRoYW4gLi4sIC4sIGFuZCAnJykgY2FuIGJlLlxuICAgIC8vXG4gICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyAqKi8qKi88cmVzdD4gLT4gKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyAqKi8qLzxyZXN0PiAtPiAqLyoqLzxyZXN0PiA8PT0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lc24ndCBmb2xsb3dcbiAgICAvLyB0aGlzIFdPVUxEIGJlIGFsbG93ZWQgaWYgKiogZGlkIGZvbGxvdyBzeW1saW5rcywgb3IgKiBkaWRuJ3RcbiAgICBmaXJzdFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgbGV0IGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIDxwcmU+LyoqLy4uLzxwPi88cD4vPHJlc3Q+IC0+IHs8cHJlPi8uLi88cD4vPHA+LzxyZXN0Piw8cHJlPi8qKi88cD4vPHA+LzxyZXN0Pn1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcnRzIG9mIGdsb2JQYXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBncyA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3NzID0gZ3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tnc3MgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPHByZT4vKiovKiovPHJlc3Q+IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3NzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWcsIGlmIGdzIGlzIDIgYW5kIGdzcyBpcyA0LCB0aGF0IG1lYW5zIHdlIGhhdmUgMyAqKlxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0cywgYW5kIGNhbiByZW1vdmUgMiBvZiB0aGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3NzID4gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncyArIDEsIGdzcyAtIGdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRzW2dzICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tncyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHBhcnRzW2dzICsgM107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnLi4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhcDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlZGl0IHBhcnRzIGluIHBsYWNlLCBhbmQgcHVzaCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHBhcnRzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBvdGhlcltnc10gPSAnKionO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHMucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGdzLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzFdID09PSAnLicgfHwgcGFydHNbMV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgbGV0IGRkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICYmIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nICYmIHAgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkRG90ID0gZGQgPT09IDEgJiYgcGFydHNbZGQgKyAxXSA9PT0gJyoqJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGluID0gbmVlZERvdCA/IFsnLiddIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyLCAuLi5zcGxpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cztcbiAgICB9XG4gICAgLy8gc2Vjb25kIHBoYXNlOiBtdWx0aS1wYXR0ZXJuIGRlZHVwZXNcbiAgICAvLyB7PHByZT4vKi88cmVzdD4sPHByZT4vPHA+LzxyZXN0Pn0gLT4gPHByZT4vKi88cmVzdD5cbiAgICAvLyB7PHByZT4vPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vXG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi8qKi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAvLyBeLS0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lbnMndCBmb2xsb3cgc3ltbGlua3NcbiAgICBzZWNvbmRQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ2xvYlBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IHRoaXMucGFydHNNYXRjaChnbG9iUGFydHNbaV0sIGdsb2JQYXJ0c1tqXSwgIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbal0gPSBtYXRjaGVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5maWx0ZXIoZ3MgPT4gZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcGFydHNNYXRjaChhLCBiLCBlbXB0eUdTTWF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgYWkgPSAwO1xuICAgICAgICBsZXQgYmkgPSAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCB3aGljaCA9ICcnO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoYVthaV0gPT09IGJbYmldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2hpY2ggPT09ICdiJyA/IGJbYmldIDogYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBhW2FpXSA9PT0gJyoqJyAmJiBiW2JpXSA9PT0gYVthaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eUdTTWF0Y2ggJiYgYltiaV0gPT09ICcqKicgJiYgYVthaV0gPT09IGJbYmkgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYVthaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGJbYmldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWJbYmldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBiW2JpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYSc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJbYmldID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZG90IHx8ICFhW2FpXS5zdGFydHNXaXRoKCcuJykpICYmXG4gICAgICAgICAgICAgICAgYVthaV0gIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09ICdhJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWNoID0gJ2InO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZmFsbCBvdXQgb2YgdGhlIGxvb3AsIGl0IG1lYW5zIHRoZXkgdHdvIGFyZSBpZGVudGljYWxcbiAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGVpciBsZW5ndGhzIG1hdGNoXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZU5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uZWdhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5lZ2F0ZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJzsgaSsrKSB7XG4gICAgICAgICAgICBuZWdhdGUgPSAhbmVnYXRlO1xuICAgICAgICAgICAgbmVnYXRlT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZ2F0ZU9mZnNldClcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc2xpY2UobmVnYXRlT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4gICAgLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuICAgIC8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuICAgIC8vIHRoZSBwYXJ0cyBtYXRjaC5cbiAgICBtYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gVU5DIHBhdGhzIGxpa2UgLy8/L1g6Ly4uLiBjYW4gbWF0Y2ggWDovLi4uIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIC8vIERyaXZlIGxldHRlcnMgaW4gYWJzb2x1dGUgZHJpdmUgb3IgdW5jIHBhdGhzIGFyZSBhbHdheXMgY29tcGFyZWRcbiAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVEcml2ZSA9IHR5cGVvZiBmaWxlWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KGZpbGVbMF0pO1xuICAgICAgICAgICAgY29uc3QgZmlsZVVOQyA9ICFmaWxlRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChmaWxlWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5Ecml2ZSA9IHR5cGVvZiBwYXR0ZXJuWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bMF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVyblVOQyA9ICFwYXR0ZXJuRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhdHRlcm5bM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwYXR0ZXJuWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IGZkaSA9IGZpbGVVTkMgPyAzIDogZmlsZURyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBkaSA9IHBhdHRlcm5VTkMgPyAzIDogcGF0dGVybkRyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmRpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcGRpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmZCwgcGRdID0gW2ZpbGVbZmRpXSwgcGF0dGVybltwZGldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmQudG9Mb3dlckNhc2UoKSA9PT0gcGQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuW3BkaV0gPSBmZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBkaSA+IGZkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UocGRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZGkgPiBwZGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKGZkaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbmQgcmVkdWNlIC4gYW5kIC4uIHBvcnRpb25zIGluIHRoZSBmaWxlIGFzIHdlbGwuXG4gICAgICAgIC8vIGRvbnQnIG5lZWQgdG8gZG8gdGhlIHNlY29uZCBwaGFzZSwgYmVjYXVzZSBpdCdzIG9ubHkgb25lIHN0cmluZ1tdXG4gICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uTGV2ZWwgPSAxIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAyKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5sZXZlbFR3b0ZpbGVPcHRpbWl6ZShmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIHRoaXMsIHsgZmlsZSwgcGF0dGVybiB9KTtcbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBmaSA9IDAsIHBpID0gMCwgZmwgPSBmaWxlLmxlbmd0aCwgcGwgPSBwYXR0ZXJuLmxlbmd0aDsgZmkgPCBmbCAmJiBwaSA8IHBsOyBmaSsrLCBwaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJyk7XG4gICAgICAgICAgICB2YXIgcCA9IHBhdHRlcm5bcGldO1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlW2ZpXTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZik7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmIChwID09PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pO1xuICAgICAgICAgICAgICAgIC8vIFwiKipcIlxuICAgICAgICAgICAgICAgIC8vIGEvKiovYi8qKi9jIHdvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgICAgICAgICAgICAvLyBhL3gveS96L2IvY1xuICAgICAgICAgICAgICAgIC8vIGEvYi94L2IveC9jXG4gICAgICAgICAgICAgICAgLy8gYS9iL2NcbiAgICAgICAgICAgICAgICAvLyBUbyBkbyB0aGlzLCB0YWtlIHRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhlICoqLCBhbmQgc2VlIGlmIGl0IHdvdWxkIG1hdGNoIHRoZSBmaWxlIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm90LCB0aGUgKiogXCJzd2FsbG93c1wiIGEgc2VnbWVudCwgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGF3ZnVsLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYS8qKi9iLyoqL2MgbWF0Y2hpbmcgYS9iL3gveS96L2NcbiAgICAgICAgICAgICAgICAvLyAtIGEgbWF0Y2hlcyBhXG4gICAgICAgICAgICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAgICAgICAgICAgLy8gICAtIG1hdGNoT25lKGIveC95L3ovYywgYi8qKi9jKVxuICAgICAgICAgICAgICAgIC8vICAgICAtIGIgbWF0Y2hlcyBiXG4gICAgICAgICAgICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeC95L3ovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHkvei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoYywgYykgeWVzLCBoaXRcbiAgICAgICAgICAgICAgICB2YXIgZnIgPSBmaTtcbiAgICAgICAgICAgICAgICB2YXIgcHIgPSBwaSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gLiBhbmQgLi4gYXJlICpuZXZlciogbWF0Y2hlZCBieSAqKiwgZm9yIGV4cGxvc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3dhbGxvd2VlID0gZmlsZVtmcl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBmb3VuZCBtYXRjaCEnLCBmciwgZmwsIHN3YWxsb3dlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4ndCBzd2FsbG93IFwiLlwiIG9yIFwiLi5cIiBldmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3dhbGxvd2VlID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICoqIHN3YWxsb3dzIGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyID09PSBmbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgb3RoZXIgdGhhbiAqKlxuICAgICAgICAgICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgICAgICAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgICAgICAgICAgbGV0IGhpdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBoaXQgPSBmID09PSBwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3N0cmluZyBtYXRjaCcsIHAsIGYsIGhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaXQgPSBwLnRlc3QoZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygncGF0dGVybiBtYXRjaCcsIHAsIGYsIGhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhpdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgICAgIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gICAgICAgIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAgICAgICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAgICAgICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgICAgICAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgICAgICAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcbiAgICAgICAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICAgICAgICBpZiAoZmkgPT09IGZsICYmIHBpID09PSBwbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgLy8gYW4gZXhhY3QgaGl0IVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgICAgICAgICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpID09PSBwbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuLCBzdGlsbCBoYXZlIGZpbGUgbGVmdC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAgICAgICAgIC8vIGVtcHR5IHNlZ21lbnQgb2YgYSBmaWxlIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgICAgIC8vIGEvKiBzaG91bGQgbWF0Y2ggYS9iL1xuICAgICAgICAgICAgcmV0dXJuIGZpID09PSBmbCAtIDEgJiYgZmlsZVtmaV0gPT09ICcnO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICBicmFjZUV4cGFuZCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmJyYWNlRXhwYW5kKSh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgKDAsIGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEuYXNzZXJ0VmFsaWRQYXR0ZXJuKShwYXR0ZXJuKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gc2hvcnRjdXRzXG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnKionKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuR0xPQlNUQVI7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gZmFyIGFuZCBhd2F5LCB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJuIHBhcnRzIGFyZVxuICAgICAgICAvLyAqLCAqLiosIGFuZCAqLjxleHQ+ICBBZGQgYSBmYXN0IGNoZWNrIG1ldGhvZCBmb3IgdGhvc2UuXG4gICAgICAgIGxldCBtO1xuICAgICAgICBsZXQgZmFzdFRlc3QgPSBudWxsO1xuICAgICAgICBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhclRlc3REb3QgOiBzdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdEV4dFJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90XG4gICAgICAgICAgICAgICAgICAgIDogc3RhckRvdEV4dFRlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdCkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHFtYXJrc1JFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0Tm9jYXNlXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0KShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhckRvdFN0YXJUZXN0RG90IDogc3RhckRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChkb3RTdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBkb3RTdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZSA9IGFzdF9qc18xLkFTVC5mcm9tR2xvYihwYXR0ZXJuLCB0aGlzLm9wdGlvbnMpLnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIGlmIChmYXN0VGVzdCAmJiB0eXBlb2YgcmUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBBdm9pZHMgb3ZlcnJpZGluZyBpbiBmcm96ZW4gZW52aXJvbm1lbnRzXG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHJlLCAndGVzdCcsIHsgdmFsdWU6IGZhc3RUZXN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZTtcbiAgICB9XG4gICAgbWFrZVJlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgICAgICAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAgICAgICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhclxuICAgICAgICAgICAgPyBzdGFyXG4gICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgPyB0d29TdGFyRG90XG4gICAgICAgICAgICAgICAgOiB0d29TdGFyTm9Eb3Q7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gbmV3IFNldChvcHRpb25zLm5vY2FzZSA/IFsnaSddIDogW10pO1xuICAgICAgICAvLyByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgICAgIC8vIGlmICoqIGlzIG9ubHkgaXRlbSwgdGhlbiB3ZSBqdXN0IGRvIG9uZSB0d29TdGFyXG4gICAgICAgIC8vIGlmICoqIGlzIGZpcnN0LCBhbmQgdGhlcmUgYXJlIG1vcmUsIHByZXBlbmQgKFxcL3x0d29TdGFyXFwvKT8gdG8gbmV4dFxuICAgICAgICAvLyBpZiAqKiBpcyBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgICAgICAvLyBpZiAqKiBpcyBpbiB0aGUgbWlkZGxlLCBhcHBlbmQgKFxcL3xcXC90d29TdGFyXFwvKSB0byBwcmV2aW91c1xuICAgICAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgICAgICBsZXQgcmUgPSBzZXRcbiAgICAgICAgICAgIC5tYXAocGF0dGVybiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHBhdHRlcm4ubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBwLmZsYWdzLnNwbGl0KCcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFkZChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgICAgICAgICAgICAgICA6IHAgPT09IGV4cG9ydHMuR0xPQlNUQVJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5HTE9CU1RBUlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLl9zcmM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBwLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcHBbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBwcFtpIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHAgIT09IGV4cG9ydHMuR0xPQlNUQVIgfHwgcHJldiA9PT0gZXhwb3J0cy5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiBuZXh0ICE9PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpICsgMV0gPSAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnXFxcXC8pPycgKyBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHBbaV0gPSB0d29TdGFyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfCcgKyB0d29TdGFyICsgJyk/JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gZXhwb3J0cy5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXC8pJyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9IGV4cG9ydHMuR0xPQlNUQVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHAuZmlsdGVyKHAgPT4gcCAhPT0gZXhwb3J0cy5HTE9CU1RBUikuam9pbignLycpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICAgICAgLy8gbmVlZCB0byB3cmFwIGluIHBhcmVucyBpZiB3ZSBoYWQgbW9yZSB0aGFuIG9uZSB0aGluZyB3aXRoIHwsXG4gICAgICAgIC8vIG90aGVyd2lzZSBvbmx5IHRoZSBmaXJzdCB3aWxsIGJlIGFuY2hvcmVkIHRvIF4gYW5kIHRoZSBsYXN0IHRvICRcbiAgICAgICAgY29uc3QgW29wZW4sIGNsb3NlXSA9IHNldC5sZW5ndGggPiAxID8gWycoPzonLCAnKSddIDogWycnLCAnJ107XG4gICAgICAgIC8vIG11c3QgbWF0Y2ggZW50aXJlIHBhdHRlcm5cbiAgICAgICAgLy8gZW5kaW5nIGluIGEgKiBvciAqKiB3aWxsIG1ha2UgaXQgbGVzcyBzdHJpY3QuXG4gICAgICAgIHJlID0gJ14nICsgb3BlbiArIHJlICsgY2xvc2UgKyAnJCc7XG4gICAgICAgIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICAgICAgICBpZiAodGhpcy5uZWdhdGUpXG4gICAgICAgICAgICByZSA9ICdeKD8hJyArIHJlICsgJykuKyQnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlLCBbLi4uZmxhZ3NdLmpvaW4oJycpKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGVcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgIH1cbiAgICBzbGFzaFNwbGl0KHApIHtcbiAgICAgICAgLy8gaWYgcCBzdGFydHMgd2l0aCAvLyBvbiB3aW5kb3dzLCB3ZSBwcmVzZXJ2ZSB0aGF0XG4gICAgICAgIC8vIHNvIHRoYXQgVU5DIHBhdGhzIGFyZW4ndCBicm9rZW4uICBPdGhlcndpc2UsIGFueSBudW1iZXIgb2ZcbiAgICAgICAgLy8gLyBjaGFyYWN0ZXJzIGFyZSBjb2FsZXNjZWQgaW50byBvbmUsIHVubGVzc1xuICAgICAgICAvLyBwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgaWYgKHRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KCcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1dpbmRvd3MgJiYgL15cXC9cXC9bXlxcL10rLy50ZXN0KHApKSB7XG4gICAgICAgICAgICAvLyBhZGQgYW4gZXh0cmEgJycgZm9yIHRoZSBvbmUgd2UgbG9zZVxuICAgICAgICAgICAgcmV0dXJuIFsnJywgLi4ucC5zcGxpdCgvXFwvKy8pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KC9cXC8rLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goZiwgcGFydGlhbCA9IHRoaXMucGFydGlhbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybik7XG4gICAgICAgIC8vIHNob3J0LWNpcmN1aXQgaW4gdGhlIGNhc2Ugb2YgYnVzdGVkIHRoaW5ncy5cbiAgICAgICAgLy8gY29tbWVudHMsIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZiA9PT0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgPT09ICcvJyAmJiBwYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBmID0gZi5zcGxpdCgnXFxcXCcpLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgICAgICAgY29uc3QgZmYgPSB0aGlzLnNsYXNoU3BsaXQoZik7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc3BsaXQnLCBmZik7XG4gICAgICAgIC8vIGp1c3QgT05FIG9mIHRoZSBwYXR0ZXJuIHNldHMgaW4gdGhpcy5zZXQgbmVlZHMgdG8gbWF0Y2hcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgICAgICAgLy8gbWF0Y2ggbWVhbnMgdGhhdCB3ZSBoYXZlIGZhaWxlZC5cbiAgICAgICAgLy8gRWl0aGVyIHdheSwgcmV0dXJuIG9uIHRoZSBmaXJzdCBoaXQuXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGZmW2ZmLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZmYubGVuZ3RoIC0gMjsgIWZpbGVuYW1lICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmZltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHNldFtpXTtcbiAgICAgICAgICAgIGxldCBmaWxlID0gZmY7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmaWxlID0gW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbCk7XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBoaXRzLiAgdGhpcyBpcyBzdWNjZXNzIGlmIGl0J3MgYSBuZWdhdGl2ZVxuICAgICAgICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRzKGRlZikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5taW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2g7XG4gICAgfVxufVxuZXhwb3J0cy5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2g7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbnZhciBhc3RfanNfMiA9IHJlcXVpcmUoXCIuL2FzdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFTVFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0X2pzXzIuQVNUOyB9IH0pO1xudmFyIGVzY2FwZV9qc18yID0gcmVxdWlyZShcIi4vZXNjYXBlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlc2NhcGVfanNfMi5lc2NhcGU7IH0gfSk7XG52YXIgdW5lc2NhcGVfanNfMiA9IHJlcXVpcmUoXCIuL3VuZXNjYXBlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5lc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZXNjYXBlX2pzXzIudW5lc2NhcGU7IH0gfSk7XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0cy5taW5pbWF0Y2guQVNUID0gYXN0X2pzXzEuQVNUO1xuZXhwb3J0cy5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoO1xuZXhwb3J0cy5taW5pbWF0Y2guZXNjYXBlID0gZXNjYXBlX2pzXzEuZXNjYXBlO1xuZXhwb3J0cy5taW5pbWF0Y2gudW5lc2NhcGUgPSB1bmVzY2FwZV9qc18xLnVuZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVuZXNjYXBlIiwiZXNjYXBlIiwiQVNUIiwiTWluaW1hdGNoIiwibWF0Y2giLCJtYWtlUmUiLCJicmFjZUV4cGFuZCIsImRlZmF1bHRzIiwiZmlsdGVyIiwiR0xPQlNUQVIiLCJzZXAiLCJtaW5pbWF0Y2giLCJicmFjZV9leHBhbnNpb25fMSIsInJlcXVpcmUiLCJhc3NlcnRfdmFsaWRfcGF0dGVybl9qc18xIiwiYXN0X2pzXzEiLCJlc2NhcGVfanNfMSIsInVuZXNjYXBlX2pzXzEiLCJwIiwicGF0dGVybiIsIm9wdGlvbnMiLCJhc3NlcnRWYWxpZFBhdHRlcm4iLCJub2NvbW1lbnQiLCJjaGFyQXQiLCJzdGFyRG90RXh0UkUiLCJzdGFyRG90RXh0VGVzdCIsImV4dCIsImYiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzdGFyRG90RXh0VGVzdERvdCIsInN0YXJEb3RFeHRUZXN0Tm9jYXNlIiwidG9Mb3dlckNhc2UiLCJzdGFyRG90RXh0VGVzdE5vY2FzZURvdCIsInN0YXJEb3RTdGFyUkUiLCJzdGFyRG90U3RhclRlc3QiLCJpbmNsdWRlcyIsInN0YXJEb3RTdGFyVGVzdERvdCIsImRvdFN0YXJSRSIsImRvdFN0YXJUZXN0Iiwic3RhclJFIiwic3RhclRlc3QiLCJsZW5ndGgiLCJzdGFyVGVzdERvdCIsInFtYXJrc1JFIiwicW1hcmtzVGVzdE5vY2FzZSIsIiQwIiwibm9leHQiLCJxbWFya3NUZXN0Tm9FeHQiLCJxbWFya3NUZXN0Tm9jYXNlRG90IiwicW1hcmtzVGVzdE5vRXh0RG90IiwicW1hcmtzVGVzdERvdCIsInFtYXJrc1Rlc3QiLCJsZW4iLCJkZWZhdWx0UGxhdGZvcm0iLCJwcm9jZXNzIiwiZW52IiwiX19NSU5JTUFUQ0hfVEVTVElOR19QTEFURk9STV9fIiwicGxhdGZvcm0iLCJwYXRoIiwid2luMzIiLCJwb3NpeCIsIlN5bWJvbCIsInFtYXJrIiwic3RhciIsInR3b1N0YXJEb3QiLCJ0d29TdGFyTm9Eb3QiLCJhIiwiYiIsImFzc2lnbiIsImRlZiIsImtleXMiLCJvcmlnIiwibSIsImNvbnN0cnVjdG9yIiwidHlwZSIsInBhcmVudCIsImZyb21HbG9iIiwicyIsImxpc3QiLCJub2JyYWNlIiwidGVzdCIsImRlZmF1bHQiLCJtbSIsIm5vbnVsbCIsInB1c2giLCJnbG9iTWFnaWMiLCJyZWdFeHBFc2NhcGUiLCJyZXBsYWNlIiwiaXNXaW5kb3dzIiwid2luZG93c1BhdGhzTm9Fc2NhcGUiLCJhbGxvd1dpbmRvd3NFc2NhcGUiLCJwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyIsInJlZ2V4cCIsIm5lZ2F0ZSIsIm5vbmVnYXRlIiwiY29tbWVudCIsImVtcHR5IiwicGFydGlhbCIsIm5vY2FzZSIsIndpbmRvd3NOb01hZ2ljUm9vdCIsInVuZGVmaW5lZCIsImdsb2JTZXQiLCJnbG9iUGFydHMiLCJzZXQiLCJtYWtlIiwiaGFzTWFnaWMiLCJtYWdpY2FsQnJhY2VzIiwicGFydCIsImRlYnVnIiwiXyIsInBhcnNlTmVnYXRlIiwiU2V0IiwiYXJncyIsImNvbnNvbGUiLCJlcnJvciIsInJhd0dsb2JQYXJ0cyIsIm1hcCIsInNsYXNoU3BsaXQiLCJwcmVwcm9jZXNzIiwiX18iLCJpc1VOQyIsImlzRHJpdmUiLCJzbGljZSIsInNzIiwicGFyc2UiLCJpbmRleE9mIiwiaSIsIm5vZ2xvYnN0YXIiLCJqIiwib3B0aW1pemF0aW9uTGV2ZWwiLCJmaXJzdFBoYXNlUHJlUHJvY2VzcyIsInNlY29uZFBoYXNlUHJlUHJvY2VzcyIsImxldmVsT25lT3B0aW1pemUiLCJhZGphc2NlbnRHbG9ic3Rhck9wdGltaXplIiwicGFydHMiLCJncyIsInNwbGljZSIsInJlZHVjZSIsInByZXYiLCJwb3AiLCJsZXZlbFR3b0ZpbGVPcHRpbWl6ZSIsIkFycmF5IiwiaXNBcnJheSIsImRpZFNvbWV0aGluZyIsImRkIiwiZ3NzIiwibmV4dCIsInAyIiwib3RoZXIiLCJuZWVkRG90Iiwic3BsaW4iLCJtYXRjaGVkIiwicGFydHNNYXRjaCIsImVtcHR5R1NNYXRjaCIsImFpIiwiYmkiLCJyZXN1bHQiLCJ3aGljaCIsImRvdCIsIm5lZ2F0ZU9mZnNldCIsIm1hdGNoT25lIiwiZmlsZSIsImZpbGVEcml2ZSIsImZpbGVVTkMiLCJwYXR0ZXJuRHJpdmUiLCJwYXR0ZXJuVU5DIiwiZmRpIiwicGRpIiwiZmQiLCJwZCIsImZpIiwicGkiLCJmbCIsInBsIiwiZnIiLCJwciIsInN3YWxsb3dlZSIsImhpdCIsIkVycm9yIiwiZmFzdFRlc3QiLCJyZSIsInRvTU1QYXR0ZXJuIiwiUmVmbGVjdCIsInR3b1N0YXIiLCJmbGFncyIsInBwIiwiUmVnRXhwIiwic3BsaXQiLCJhZGQiLCJfc3JjIiwiZm9yRWFjaCIsImpvaW4iLCJvcGVuIiwiY2xvc2UiLCJleCIsImZmIiwiZmlsZW5hbWUiLCJtYXRjaEJhc2UiLCJmbGlwTmVnYXRlIiwiYXN0X2pzXzIiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZXNjYXBlX2pzXzIiLCJ1bmVzY2FwZV9qc18yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js":
/*!****************************************************************************!*\
  !*** ./node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.unescape = void 0;\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */ const unescape = (s, { windowsPathsNoEscape = false } = {})=>{\n    return windowsPathsNoEscape ? s.replace(/\\[([^\\/\\\\])\\]/g, \"$1\") : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, \"$1$2\").replace(/\\\\([^\\/])/g, \"$1\");\n};\nexports.unescape = unescape; //# sourceMappingURL=unescape.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvdW5lc2NhcGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEI7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELE1BQU1FLFdBQVcsQ0FBQ0MsR0FBRyxFQUFFQyx1QkFBdUIsS0FBSyxFQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZELE9BQU9BLHVCQUNERCxFQUFFRSxPQUFPLENBQUMsa0JBQWtCLFFBQzVCRixFQUFFRSxPQUFPLENBQUMsNkJBQTZCLFFBQVFBLE9BQU8sQ0FBQyxjQUFjO0FBQy9FO0FBQ0FMLGdCQUFnQixHQUFHRSxVQUNuQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL2dsb2Ivbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL3VuZXNjYXBlLmpzP2UyN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuZXNjYXBlID0gdm9pZCAwO1xuLyoqXG4gKiBVbi1lc2NhcGUgYSBzdHJpbmcgdGhhdCBoYXMgYmVlbiBlc2NhcGVkIHdpdGgge0BsaW5rIGVzY2FwZX0uXG4gKlxuICogSWYgdGhlIHtAbGluayB3aW5kb3dzUGF0aHNOb0VzY2FwZX0gb3B0aW9uIGlzIHVzZWQsIHRoZW4gc3F1YXJlLWJyYWNlXG4gKiBlc2NhcGVzIGFyZSByZW1vdmVkLCBidXQgbm90IGJhY2tzbGFzaCBlc2NhcGVzLiAgRm9yIGV4YW1wbGUsIGl0IHdpbGwgdHVyblxuICogdGhlIHN0cmluZyBgJ1sqXSdgIGludG8gYCpgLCBidXQgaXQgd2lsbCBub3QgdHVybiBgJ1xcXFwqJ2AgaW50byBgJyonYCxcbiAqIGJlY3Vhc2UgYFxcYCBpcyBhIHBhdGggc2VwYXJhdG9yIGluIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgbW9kZS5cbiAqXG4gKiBXaGVuIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgaXMgbm90IHNldCwgdGhlbiBib3RoIGJyYWNlIGVzY2FwZXMgYW5kXG4gKiBiYWNrc2xhc2ggZXNjYXBlcyBhcmUgcmVtb3ZlZC5cbiAqXG4gKiBTbGFzaGVzIChhbmQgYmFja3NsYXNoZXMgaW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBtb2RlKSBjYW5ub3QgYmUgZXNjYXBlZFxuICogb3IgdW5lc2NhcGVkLlxuICovXG5jb25zdCB1bmVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvXFxbKFteXFwvXFxcXF0pXFxdL2csICckMScpXG4gICAgICAgIDogcy5yZXBsYWNlKC8oKD8hXFxcXCkufF4pXFxbKFteXFwvXFxcXF0pXFxdL2csICckMSQyJykucmVwbGFjZSgvXFxcXChbXlxcL10pL2csICckMScpO1xufTtcbmV4cG9ydHMudW5lc2NhcGUgPSB1bmVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVuZXNjYXBlIiwicyIsIndpbmRvd3NQYXRoc05vRXNjYXBlIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js\n");

/***/ })

};
;