"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass";
exports.ids = ["vendor-chunks/minipass"];
exports.modules = {

/***/ "(rsc)/./node_modules/minipass/dist/commonjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/minipass/dist/commonjs/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === \"object\" && process ? process : {\n    stdout: null,\n    stderr: null\n};\nconst node_events_1 = __webpack_require__(/*! node:events */ \"node:events\");\nconst node_stream_1 = __importDefault(__webpack_require__(/*! node:stream */ \"node:stream\"));\nconst node_string_decoder_1 = __webpack_require__(/*! node:string_decoder */ \"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */ const isStream = (s)=>!!s && typeof s === \"object\" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */ const isReadable = (s)=>!!s && typeof s === \"object\" && s instanceof node_events_1.EventEmitter && typeof s.pipe === \"function\" && // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */ const isWritable = (s)=>!!s && typeof s === \"object\" && s instanceof node_events_1.EventEmitter && typeof s.write === \"function\" && typeof s.end === \"function\";\nexports.isWritable = isWritable;\nconst EOF = Symbol(\"EOF\");\nconst MAYBE_EMIT_END = Symbol(\"maybeEmitEnd\");\nconst EMITTED_END = Symbol(\"emittedEnd\");\nconst EMITTING_END = Symbol(\"emittingEnd\");\nconst EMITTED_ERROR = Symbol(\"emittedError\");\nconst CLOSED = Symbol(\"closed\");\nconst READ = Symbol(\"read\");\nconst FLUSH = Symbol(\"flush\");\nconst FLUSHCHUNK = Symbol(\"flushChunk\");\nconst ENCODING = Symbol(\"encoding\");\nconst DECODER = Symbol(\"decoder\");\nconst FLOWING = Symbol(\"flowing\");\nconst PAUSED = Symbol(\"paused\");\nconst RESUME = Symbol(\"resume\");\nconst BUFFER = Symbol(\"buffer\");\nconst PIPES = Symbol(\"pipes\");\nconst BUFFERLENGTH = Symbol(\"bufferLength\");\nconst BUFFERPUSH = Symbol(\"bufferPush\");\nconst BUFFERSHIFT = Symbol(\"bufferShift\");\nconst OBJECTMODE = Symbol(\"objectMode\");\n// internal event when stream is destroyed\nconst DESTROYED = Symbol(\"destroyed\");\n// internal event when stream has an error\nconst ERROR = Symbol(\"error\");\nconst EMITDATA = Symbol(\"emitData\");\nconst EMITEND = Symbol(\"emitEnd\");\nconst EMITEND2 = Symbol(\"emitEnd2\");\nconst ASYNC = Symbol(\"async\");\nconst ABORT = Symbol(\"abort\");\nconst ABORTED = Symbol(\"aborted\");\nconst SIGNAL = Symbol(\"signal\");\nconst DATALISTENERS = Symbol(\"dataListeners\");\nconst DISCARDED = Symbol(\"discarded\");\nconst defer = (fn)=>Promise.resolve().then(fn);\nconst nodefer = (fn)=>fn();\nconst isEndish = (ev)=>ev === \"end\" || ev === \"finish\" || ev === \"prefinish\";\nconst isArrayBufferLike = (b)=>b instanceof ArrayBuffer || !!b && typeof b === \"object\" && b.constructor && b.constructor.name === \"ArrayBuffer\" && b.byteLength >= 0;\nconst isArrayBufferView = (b)=>!Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */ class Pipe {\n    constructor(src, dest, opts){\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = ()=>src[RESUME]();\n        this.dest.on(\"drain\", this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener(\"drain\", this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */ proxyErrors(_er) {}\n    /* c8 ignore stop */ end() {\n        this.unpipe();\n        if (this.opts.end) this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */ class PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener(\"error\", this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts){\n        super(src, dest, opts);\n        this.proxyErrors = (er)=>dest.emit(\"error\", er);\n        src.on(\"error\", this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o)=>!!o.objectMode;\nconst isEncodingOptions = (o)=>!o.objectMode && !!o.encoding && o.encoding !== \"buffer\";\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */ class Minipass extends node_events_1.EventEmitter {\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */ constructor(...args){\n        const options = args[0] || {};\n        super();\n        this[FLOWING] = false;\n        this[PAUSED] = false;\n        this[PIPES] = [];\n        this[BUFFER] = [];\n        this[EOF] = false;\n        this[EMITTED_END] = false;\n        this[EMITTING_END] = false;\n        this[CLOSED] = false;\n        this[EMITTED_ERROR] = null;\n        this[BUFFERLENGTH] = 0;\n        this[DESTROYED] = false;\n        this[ABORTED] = false;\n        this[DATALISTENERS] = 0;\n        this[DISCARDED] = false;\n        /**\n     * true if the stream can be written\n     */ this.writable = true;\n        /**\n     * true if the stream can be read\n     */ this.readable = true;\n        if (options.objectMode && typeof options.encoding === \"string\") {\n            throw new TypeError(\"Encoding and objectMode may not be used together\");\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        } else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        } else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, \"buffer\", {\n                get: ()=>this[BUFFER]\n            });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, \"pipes\", {\n                get: ()=>this[PIPES]\n            });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            } else {\n                signal.addEventListener(\"abort\", ()=>this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */ get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */ get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */ set encoding(_enc) {\n        throw new Error(\"Encoding must be set at instantiation time\");\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */ setEncoding(_enc) {\n        throw new Error(\"Encoding must be set at instantiation time\");\n    }\n    /**\n     * True if this is an objectMode stream\n     */ get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */ set objectMode(_om) {\n        throw new Error(\"objectMode must be set at instantiation time\");\n    }\n    /**\n     * true if this is an async stream\n     */ get [\"async\"]() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */ set [\"async\"](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit(\"abort\", this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */ get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */ set aborted(_) {}\n    write(chunk, encoding, cb) {\n        if (this[ABORTED]) return false;\n        if (this[EOF]) throw new Error(\"write after end\");\n        if (this[DESTROYED]) {\n            this.emit(\"error\", Object.assign(new Error(\"Cannot call write after a stream was destroyed\"), {\n                code: \"ERR_STREAM_DESTROYED\"\n            }));\n            return true;\n        }\n        if (typeof encoding === \"function\") {\n            cb = encoding;\n            encoding = \"utf8\";\n        }\n        if (!encoding) encoding = \"utf8\";\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            } else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            } else if (typeof chunk !== \"string\") {\n                throw new Error(\"Non-contiguous data written to non-objectMode stream\");\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */ if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n            /* c8 ignore stop */ if (this[FLOWING]) this.emit(\"data\", chunk);\n            else this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0) this.emit(\"readable\");\n            if (cb) fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0) this.emit(\"readable\");\n            if (cb) fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === \"string\" && // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n        if (this[FLOWING]) this.emit(\"data\", chunk);\n        else this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0) this.emit(\"readable\");\n        if (cb) fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */ read(n) {\n        if (this[DESTROYED]) return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE]) n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                this[ENCODING] ? this[BUFFER].join(\"\") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE]) this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null) this[BUFFERSHIFT]();\n            else if (typeof c === \"string\") {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            } else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit(\"data\", chunk);\n        if (!this[BUFFER].length && !this[EOF]) this.emit(\"drain\");\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === \"function\") {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === \"function\") {\n            cb = encoding;\n            encoding = \"utf8\";\n        }\n        if (chunk !== undefined) this.write(chunk, encoding);\n        if (cb) this.once(\"end\", cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED]) return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit(\"resume\");\n        if (this[BUFFER].length) this[FLUSH]();\n        else if (this[EOF]) this[MAYBE_EMIT_END]();\n        else this.emit(\"drain\");\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */ resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */ pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */ get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */ get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */ get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;\n        else this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;\n        else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do {}while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit(\"drain\");\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit(\"data\", chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */ pipe(dest, opts) {\n        if (this[DESTROYED]) return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;\n        else opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end) dest.end();\n        } else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC]) defer(()=>this[RESUME]());\n            else this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */ unpipe(dest) {\n        const p = this[PIPES].find((p)=>p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            } else this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */ addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */ on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === \"data\") {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        } else if (ev === \"readable\" && this[BUFFERLENGTH] !== 0) {\n            super.emit(\"readable\");\n        } else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        } else if (ev === \"error\" && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC]) defer(()=>h.call(this, this[EMITTED_ERROR]));\n            else h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */ removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */ off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === \"data\") {\n            this[DATALISTENERS] = this.listeners(\"data\").length;\n            if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */ removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === \"data\" || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */ get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit(\"end\");\n            this.emit(\"prefinish\");\n            this.emit(\"finish\");\n            if (this[CLOSED]) this.emit(\"close\");\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */ emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== \"error\" && ev !== \"close\" && ev !== DESTROYED && this[DESTROYED]) {\n            return false;\n        } else if (ev === \"data\") {\n            return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(()=>this[EMITDATA](data)), true) : this[EMITDATA](data);\n        } else if (ev === \"end\") {\n            return this[EMITEND]();\n        } else if (ev === \"close\") {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED]) return false;\n            const ret = super.emit(\"close\");\n            this.removeAllListeners(\"close\");\n            return ret;\n        } else if (ev === \"error\") {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners(\"error\").length ? super.emit(\"error\", data) : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        } else if (ev === \"resume\") {\n            const ret = super.emit(\"resume\");\n            this[MAYBE_EMIT_END]();\n            return ret;\n        } else if (ev === \"finish\" || ev === \"prefinish\") {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]){\n            if (p.dest.write(data) === false) this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit(\"data\", data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END]) return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC] ? (defer(()=>this[EMITEND2]()), true) : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]){\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED]) super.emit(\"data\", data);\n            }\n        }\n        for (const p of this[PIPES]){\n            p.end();\n        }\n        const ret = super.emit(\"end\");\n        this.removeAllListeners(\"end\");\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */ async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0\n        });\n        if (!this[OBJECTMODE]) buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on(\"data\", (c)=>{\n            buf.push(c);\n            if (!this[OBJECTMODE]) buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */ async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error(\"cannot concat in objectMode\");\n        }\n        const buf = await this.collect();\n        return this[ENCODING] ? buf.join(\"\") : Buffer.concat(buf, buf.dataLength);\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */ async promise() {\n        return new Promise((resolve, reject)=>{\n            this.on(DESTROYED, ()=>reject(new Error(\"stream destroyed\")));\n            this.on(\"error\", (er)=>reject(er));\n            this.on(\"end\", ()=>resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */ [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async ()=>{\n            this.pause();\n            stopped = true;\n            return {\n                value: undefined,\n                done: true\n            };\n        };\n        const next = ()=>{\n            if (stopped) return stop();\n            const res = this.read();\n            if (res !== null) return Promise.resolve({\n                done: false,\n                value: res\n            });\n            if (this[EOF]) return stop();\n            let resolve;\n            let reject;\n            const onerr = (er)=>{\n                this.off(\"data\", ondata);\n                this.off(\"end\", onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value)=>{\n                this.off(\"error\", onerr);\n                this.off(\"end\", onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({\n                    value,\n                    done: !!this[EOF]\n                });\n            };\n            const onend = ()=>{\n                this.off(\"error\", onerr);\n                this.off(\"data\", ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({\n                    done: true,\n                    value: undefined\n                });\n            };\n            const ondestroy = ()=>onerr(new Error(\"stream destroyed\"));\n            return new Promise((res, rej)=>{\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once(\"error\", onerr);\n                this.once(\"end\", onend);\n                this.once(\"data\", ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator] () {\n                return this;\n            }\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */ [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = ()=>{\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off(\"end\", stop);\n            stopped = true;\n            return {\n                done: true,\n                value: undefined\n            };\n        };\n        const next = ()=>{\n            if (stopped) return stop();\n            const value = this.read();\n            return value === null ? stop() : {\n                done: false,\n                value\n            };\n        };\n        this.once(\"end\", stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator] () {\n                return this;\n            }\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */ destroy(er) {\n        if (this[DESTROYED]) {\n            if (er) this.emit(\"error\", er);\n            else this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === \"function\" && !this[CLOSED]) wc.close();\n        if (er) this.emit(\"error\", er);\n        else this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */ static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHQSxrQkFBa0IsR0FBR0Esa0JBQWtCLEdBQUdBLGdCQUFnQixHQUFHLEtBQUs7QUFDckYsTUFBTU0sT0FBTyxPQUFPQyxZQUFZLFlBQVlBLFVBQ3RDQSxVQUNBO0lBQ0VDLFFBQVE7SUFDUkMsUUFBUTtBQUNaO0FBQ0osTUFBTUMsZ0JBQWdCQyxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUMzQyxNQUFNQyxnQkFBZ0JqQixnQkFBZ0JnQixtQkFBT0EsQ0FBQyxnQ0FBYTtBQUMzRCxNQUFNRSx3QkFBd0JGLG1CQUFPQSxDQUFDLGdEQUFxQjtBQUMzRDs7O0NBR0MsR0FDRCxNQUFNTixXQUFXLENBQUNTLElBQU0sQ0FBQyxDQUFDQSxLQUN0QixPQUFPQSxNQUFNLFlBQ1pBLENBQUFBLGFBQWFaLFlBQ1ZZLGFBQWFGLGNBQWNHLE9BQU8sSUFDbEMsQ0FBQyxHQUFHZixRQUFRSSxVQUFVLEVBQUVVLE1BQ3hCLENBQUMsR0FBR2QsUUFBUUcsVUFBVSxFQUFFVyxFQUFDO0FBQ2pDZCxnQkFBZ0IsR0FBR0s7QUFDbkI7O0NBRUMsR0FDRCxNQUFNRCxhQUFhLENBQUNVLElBQU0sQ0FBQyxDQUFDQSxLQUN4QixPQUFPQSxNQUFNLFlBQ2JBLGFBQWFKLGNBQWNNLFlBQVksSUFDdkMsT0FBT0YsRUFBRUcsSUFBSSxLQUFLLGNBQ2xCLGlFQUFpRTtJQUNqRUgsRUFBRUcsSUFBSSxLQUFLTCxjQUFjRyxPQUFPLENBQUNHLFFBQVEsQ0FBQ0MsU0FB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LEVBQUU7WUFDakIsSUFBSXdDLElBQ0EsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBU0Q7aUJBRW5CLElBQUksQ0FBQ0MsSUFBSSxDQUFDekM7WUFDZCxPQUFPLElBQUk7UUFDZjtRQUNBLElBQUksQ0FBQ0EsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ1UsVUFBVSxHQUFHO1FBQ2xCLHNEQUFzRDtRQUN0RCxJQUFJLENBQUNoQixPQUFPLENBQUNrRixNQUFNLEdBQUc7UUFDdEIsSUFBSSxDQUFDaEYsYUFBYSxHQUFHO1FBQ3JCLE1BQU1xSSxLQUFLLElBQUk7UUFDZixJQUFJLE9BQU9BLEdBQUdDLEtBQUssS0FBSyxjQUFjLENBQUMsSUFBSSxDQUFDakosT0FBTyxFQUMvQ2dKLEdBQUdDLEtBQUs7UUFDWixJQUFJMUYsSUFDQSxJQUFJLENBQUNDLElBQUksQ0FBQyxTQUFTRDthQUduQixJQUFJLENBQUNDLElBQUksQ0FBQ3pDO1FBQ2QsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7O0tBTUMsR0FDRCxXQUFXdEMsV0FBVztRQUNsQixPQUFPTCxRQUFRSyxRQUFRO0lBQzNCO0FBQ0o7QUFDQUwsZ0JBQWdCLEdBQUdFLFVBQ25CLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcz8xNDk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaW5pcGFzcyA9IGV4cG9ydHMuaXNXcml0YWJsZSA9IGV4cG9ydHMuaXNSZWFkYWJsZSA9IGV4cG9ydHMuaXNTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBwcm9jID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/IHByb2Nlc3NcbiAgICA6IHtcbiAgICAgICAgc3Rkb3V0OiBudWxsLFxuICAgICAgICBzdGRlcnI6IG51bGwsXG4gICAgfTtcbmNvbnN0IG5vZGVfZXZlbnRzXzEgPSByZXF1aXJlKFwibm9kZTpldmVudHNcIik7XG5jb25zdCBub2RlX3N0cmVhbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOnN0cmVhbVwiKSk7XG5jb25zdCBub2RlX3N0cmluZ19kZWNvZGVyXzEgPSByZXF1aXJlKFwibm9kZTpzdHJpbmdfZGVjb2RlclwiKTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgTWluaXBhc3Mgc3RyZWFtLCBOb2RlIHN0cmVhbSwgb3Igc29tZXRoaW5nXG4gKiBlbHNlIHRoYXQgTWluaXBhc3MgY2FuIGludGVyYWN0IHdpdGguXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHMpID0+ICEhcyAmJlxuICAgIHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJlxuICAgIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHxcbiAgICAgICAgcyBpbnN0YW5jZW9mIG5vZGVfc3RyZWFtXzEuZGVmYXVsdCB8fFxuICAgICAgICAoMCwgZXhwb3J0cy5pc1JlYWRhYmxlKShzKSB8fFxuICAgICAgICAoMCwgZXhwb3J0cy5pc1dyaXRhYmxlKShzKSk7XG5leHBvcnRzLmlzU3RyZWFtID0gaXNTdHJlYW07XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIHtAbGluayBNaW5pcGFzcy5SZWFkYWJsZX1cbiAqL1xuY29uc3QgaXNSZWFkYWJsZSA9IChzKSA9PiAhIXMgJiZcbiAgICB0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiZcbiAgICBzIGluc3RhbmNlb2Ygbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIgJiZcbiAgICB0eXBlb2Ygcy5waXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgLy8gbm9kZSBjb3JlIFdyaXRhYmxlIHN0cmVhbXMgaGF2ZSBhIHBpcGUoKSBtZXRob2QsIGJ1dCBpdCB0aHJvd3NcbiAgICBzLnBpcGUgIT09IG5vZGVfc3RyZWFtXzEuZGVmYXVsdC5Xcml0YWJsZS5wcm90b3R5cGUucGlwZTtcbmV4cG9ydHMuaXNSZWFkYWJsZSA9IGlzUmVhZGFibGU7XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIHtAbGluayBNaW5pcGFzcy5Xcml0YWJsZX1cbiAqL1xuY29uc3QgaXNXcml0YWJsZSA9IChzKSA9PiAhIXMgJiZcbiAgICB0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiZcbiAgICBzIGluc3RhbmNlb2Ygbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIgJiZcbiAgICB0eXBlb2Ygcy53cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBzLmVuZCA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydHMuaXNXcml0YWJsZSA9IGlzV3JpdGFibGU7XG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpO1xuY29uc3QgTUFZQkVfRU1JVF9FTkQgPSBTeW1ib2woJ21heWJlRW1pdEVuZCcpO1xuY29uc3QgRU1JVFRFRF9FTkQgPSBTeW1ib2woJ2VtaXR0ZWRFbmQnKTtcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKTtcbmNvbnN0IEVNSVRURURfRVJST1IgPSBTeW1ib2woJ2VtaXR0ZWRFcnJvcicpO1xuY29uc3QgQ0xPU0VEID0gU3ltYm9sKCdjbG9zZWQnKTtcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKTtcbmNvbnN0IEZMVVNIID0gU3ltYm9sKCdmbHVzaCcpO1xuY29uc3QgRkxVU0hDSFVOSyA9IFN5bWJvbCgnZmx1c2hDaHVuaycpO1xuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJyk7XG5jb25zdCBERUNPREVSID0gU3ltYm9sKCdkZWNvZGVyJyk7XG5jb25zdCBGTE9XSU5HID0gU3ltYm9sKCdmbG93aW5nJyk7XG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpO1xuY29uc3QgUkVTVU1FID0gU3ltYm9sKCdyZXN1bWUnKTtcbmNvbnN0IEJVRkZFUiA9IFN5bWJvbCgnYnVmZmVyJyk7XG5jb25zdCBQSVBFUyA9IFN5bWJvbCgncGlwZXMnKTtcbmNvbnN0IEJVRkZFUkxFTkdUSCA9IFN5bWJvbCgnYnVmZmVyTGVuZ3RoJyk7XG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJyk7XG5jb25zdCBCVUZGRVJTSElGVCA9IFN5bWJvbCgnYnVmZmVyU2hpZnQnKTtcbmNvbnN0IE9CSkVDVE1PREUgPSBTeW1ib2woJ29iamVjdE1vZGUnKTtcbi8vIGludGVybmFsIGV2ZW50IHdoZW4gc3RyZWFtIGlzIGRlc3Ryb3llZFxuY29uc3QgREVTVFJPWUVEID0gU3ltYm9sKCdkZXN0cm95ZWQnKTtcbi8vIGludGVybmFsIGV2ZW50IHdoZW4gc3RyZWFtIGhhcyBhbiBlcnJvclxuY29uc3QgRVJST1IgPSBTeW1ib2woJ2Vycm9yJyk7XG5jb25zdCBFTUlUREFUQSA9IFN5bWJvbCgnZW1pdERhdGEnKTtcbmNvbnN0IEVNSVRFTkQgPSBTeW1ib2woJ2VtaXRFbmQnKTtcbmNvbnN0IEVNSVRFTkQyID0gU3ltYm9sKCdlbWl0RW5kMicpO1xuY29uc3QgQVNZTkMgPSBTeW1ib2woJ2FzeW5jJyk7XG5jb25zdCBBQk9SVCA9IFN5bWJvbCgnYWJvcnQnKTtcbmNvbnN0IEFCT1JURUQgPSBTeW1ib2woJ2Fib3J0ZWQnKTtcbmNvbnN0IFNJR05BTCA9IFN5bWJvbCgnc2lnbmFsJyk7XG5jb25zdCBEQVRBTElTVEVORVJTID0gU3ltYm9sKCdkYXRhTGlzdGVuZXJzJyk7XG5jb25zdCBESVNDQVJERUQgPSBTeW1ib2woJ2Rpc2NhcmRlZCcpO1xuY29uc3QgZGVmZXIgPSAoZm4pID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pO1xuY29uc3Qgbm9kZWZlciA9IChmbikgPT4gZm4oKTtcbmNvbnN0IGlzRW5kaXNoID0gKGV2KSA9PiBldiA9PT0gJ2VuZCcgfHwgZXYgPT09ICdmaW5pc2gnIHx8IGV2ID09PSAncHJlZmluaXNoJztcbmNvbnN0IGlzQXJyYXlCdWZmZXJMaWtlID0gKGIpID0+IGIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICghIWIgJiZcbiAgICAgICAgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGIuY29uc3RydWN0b3IgJiZcbiAgICAgICAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgICAgIGIuYnl0ZUxlbmd0aCA+PSAwKTtcbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gKGIpID0+ICFCdWZmZXIuaXNCdWZmZXIoYikgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpO1xuLyoqXG4gKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBwaXBlIHRvIGEgZGVzdGluYXRpb24gc3RyZWFtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQaXBlIHtcbiAgICBzcmM7XG4gICAgZGVzdDtcbiAgICBvcHRzO1xuICAgIG9uZHJhaW47XG4gICAgY29uc3RydWN0b3Ioc3JjLCBkZXN0LCBvcHRzKSB7XG4gICAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgICB0aGlzLmRlc3QgPSBkZXN0O1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLm9uZHJhaW4gPSAoKSA9PiBzcmNbUkVTVU1FXSgpO1xuICAgICAgICB0aGlzLmRlc3Qub24oJ2RyYWluJywgdGhpcy5vbmRyYWluKTtcbiAgICB9XG4gICAgdW5waXBlKCkge1xuICAgICAgICB0aGlzLmRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgdGhpcy5vbmRyYWluKTtcbiAgICB9XG4gICAgLy8gb25seSBoZXJlIGZvciB0aGUgcHJvdG90eXBlXG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgcHJveHlFcnJvcnMoX2VyKSB7IH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy51bnBpcGUoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lbmQpXG4gICAgICAgICAgICB0aGlzLmRlc3QuZW5kKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBwaXBlIHRvIGEgZGVzdGluYXRpb24gc3RyZWFtIHdoZXJlXG4gKiBlcnJvcnMgYXJlIHByb3hpZWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFBpcGVQcm94eUVycm9ycyBleHRlbmRzIFBpcGUge1xuICAgIHVucGlwZSgpIHtcbiAgICAgICAgdGhpcy5zcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycyk7XG4gICAgICAgIHN1cGVyLnVucGlwZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoc3JjLCBkZXN0LCBvcHRzKTtcbiAgICAgICAgdGhpcy5wcm94eUVycm9ycyA9IGVyID0+IGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgIHNyYy5vbignZXJyb3InLCB0aGlzLnByb3h5RXJyb3JzKTtcbiAgICB9XG59XG5jb25zdCBpc09iamVjdE1vZGVPcHRpb25zID0gKG8pID0+ICEhby5vYmplY3RNb2RlO1xuY29uc3QgaXNFbmNvZGluZ09wdGlvbnMgPSAobykgPT4gIW8ub2JqZWN0TW9kZSAmJiAhIW8uZW5jb2RpbmcgJiYgby5lbmNvZGluZyAhPT0gJ2J1ZmZlcic7XG4vKipcbiAqIE1haW4gZXhwb3J0LCB0aGUgTWluaXBhc3MgY2xhc3NcbiAqXG4gKiBgUlR5cGVgIGlzIHRoZSB0eXBlIG9mIGRhdGEgZW1pdHRlZCwgZGVmYXVsdHMgdG8gQnVmZmVyXG4gKlxuICogYFdUeXBlYCBpcyB0aGUgdHlwZSBvZiBkYXRhIHRvIGJlIHdyaXR0ZW4sIGlmIFJUeXBlIGlzIGJ1ZmZlciBvciBzdHJpbmcsXG4gKiB0aGVuIGFueSB7QGxpbmsgTWluaXBhc3MuQ29udGlndW91c0RhdGF9IGlzIGFsbG93ZWQuXG4gKlxuICogYEV2ZW50c2AgaXMgdGhlIHNldCBvZiBldmVudCBoYW5kbGVyIHNpZ25hdHVyZXMgdGhhdCB0aGlzIG9iamVjdFxuICogd2lsbCBlbWl0LCBzZWUge0BsaW5rIE1pbmlwYXNzLkV2ZW50c31cbiAqL1xuY2xhc3MgTWluaXBhc3MgZXh0ZW5kcyBub2RlX2V2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgW1BBVVNFRF0gPSBmYWxzZTtcbiAgICBbUElQRVNdID0gW107XG4gICAgW0JVRkZFUl0gPSBbXTtcbiAgICBbT0JKRUNUTU9ERV07XG4gICAgW0VOQ09ESU5HXTtcbiAgICBbQVNZTkNdO1xuICAgIFtERUNPREVSXTtcbiAgICBbRU9GXSA9IGZhbHNlO1xuICAgIFtFTUlUVEVEX0VORF0gPSBmYWxzZTtcbiAgICBbRU1JVFRJTkdfRU5EXSA9IGZhbHNlO1xuICAgIFtDTE9TRURdID0gZmFsc2U7XG4gICAgW0VNSVRURURfRVJST1JdID0gbnVsbDtcbiAgICBbQlVGRkVSTEVOR1RIXSA9IDA7XG4gICAgW0RFU1RST1lFRF0gPSBmYWxzZTtcbiAgICBbU0lHTkFMXTtcbiAgICBbQUJPUlRFRF0gPSBmYWxzZTtcbiAgICBbREFUQUxJU1RFTkVSU10gPSAwO1xuICAgIFtESVNDQVJERURdID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGNhbiBiZSB3cml0dGVuXG4gICAgICovXG4gICAgd3JpdGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBjYW4gYmUgcmVhZFxuICAgICAqL1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBJZiBgUlR5cGVgIGlzIEJ1ZmZlciwgdGhlbiBvcHRpb25zIGRvIG5vdCBuZWVkIHRvIGJlIHByb3ZpZGVkLlxuICAgICAqIE90aGVyd2lzZSwgYW4gb3B0aW9ucyBvYmplY3QgbXVzdCBiZSBwcm92aWRlZCB0byBzcGVjaWZ5IGVpdGhlclxuICAgICAqIHtAbGluayBNaW5pcGFzcy5TaGFyZWRPcHRpb25zLm9iamVjdE1vZGV9IG9yXG4gICAgICoge0BsaW5rIE1pbmlwYXNzLlNoYXJlZE9wdGlvbnMuZW5jb2Rpbmd9LCBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSAoYXJnc1swXSB8fFxuICAgICAgICAgICAge30pO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAob3B0aW9ucy5vYmplY3RNb2RlICYmIHR5cGVvZiBvcHRpb25zLmVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RpbmcgYW5kIG9iamVjdE1vZGUgbWF5IG5vdCBiZSB1c2VkIHRvZ2V0aGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0TW9kZU9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRW5jb2RpbmdPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzW0VOQ09ESU5HXSA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgICAgICAgICB0aGlzW09CSkVDVE1PREVdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW09CSkVDVE1PREVdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tBU1lOQ10gPSAhIW9wdGlvbnMuYXN5bmM7XG4gICAgICAgIHRoaXNbREVDT0RFUl0gPSB0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgPyBuZXcgbm9kZV9zdHJpbmdfZGVjb2Rlcl8xLlN0cmluZ0RlY29kZXIodGhpc1tFTkNPRElOR10pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIC8vQHRzLWlnbm9yZSAtIHByaXZhdGUgb3B0aW9uIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0V4cG9zZUJ1ZmZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7IGdldDogKCkgPT4gdGhpc1tCVUZGRVJdIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vQHRzLWlnbm9yZSAtIHByaXZhdGUgb3B0aW9uIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0V4cG9zZVBpcGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BpcGVzJywgeyBnZXQ6ICgpID0+IHRoaXNbUElQRVNdIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICB0aGlzW1NJR05BTF0gPSBzaWduYWw7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0FCT1JUXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpc1tBQk9SVF0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBkYXRhIHN0b3JlZCBpbiB0aGUgYnVmZmVyIHdhaXRpbmcgdG8gYmUgcmVhZC5cbiAgICAgKlxuICAgICAqIEZvciBCdWZmZXIgc3RyaW5ncywgdGhpcyB3aWxsIGJlIHRoZSB0b3RhbCBieXRlIGxlbmd0aC5cbiAgICAgKiBGb3Igc3RyaW5nIGVuY29kaW5nIHN0cmVhbXMsIHRoaXMgd2lsbCBiZSB0aGUgc3RyaW5nIGNoYXJhY3RlciBsZW5ndGgsXG4gICAgICogYWNjb3JkaW5nIHRvIEphdmFTY3JpcHQncyBgc3RyaW5nLmxlbmd0aGAgbG9naWMuXG4gICAgICogRm9yIG9iamVjdE1vZGUgc3RyZWFtcywgdGhpcyBpcyBhIGNvdW50IG9mIHRoZSBpdGVtcyB3YWl0aW5nIHRvIGJlXG4gICAgICogZW1pdHRlZC5cbiAgICAgKi9cbiAgICBnZXQgYnVmZmVyTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tCVUZGRVJMRU5HVEhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYEJ1ZmZlckVuY29kaW5nYCBjdXJyZW50bHkgaW4gdXNlLCBvciBgbnVsbGBcbiAgICAgKi9cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0VOQ09ESU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBUaGlzIGlzIGEgcmVhZCBvbmx5IHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0IGVuY29kaW5nKF9lbmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBtdXN0IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBFbmNvZGluZyBtYXkgb25seSBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lXG4gICAgICovXG4gICAgc2V0RW5jb2RpbmcoX2VuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG11c3QgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgaXMgYW4gb2JqZWN0TW9kZSBzdHJlYW1cbiAgICAgKi9cbiAgICBnZXQgb2JqZWN0TW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbT0JKRUNUTU9ERV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gVGhpcyBpcyBhIHJlYWQtb25seSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldCBvYmplY3RNb2RlKF9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29iamVjdE1vZGUgbXVzdCBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhpcyBpcyBhbiBhc3luYyBzdHJlYW1cbiAgICAgKi9cbiAgICBnZXQgWydhc3luYyddKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tBU1lOQ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIG1ha2UgdGhpcyBzdHJlYW0gYXN5bmMuXG4gICAgICpcbiAgICAgKiBPbmNlIHNldCwgaXQgY2Fubm90IGJlIHVuc2V0LCBhcyB0aGlzIHdvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGluY29ycmVjdFxuICAgICAqIGJlaGF2aW9yLiAgSWUsIGEgc3luYyBzdHJlYW0gY2FuIGJlIG1hZGUgYXN5bmMsIGJ1dCBhbiBhc3luYyBzdHJlYW1cbiAgICAgKiBjYW5ub3QgYmUgc2FmZWx5IG1hZGUgc3luYy5cbiAgICAgKi9cbiAgICBzZXQgWydhc3luYyddKGEpIHtcbiAgICAgICAgdGhpc1tBU1lOQ10gPSB0aGlzW0FTWU5DXSB8fCAhIWE7XG4gICAgfVxuICAgIC8vIGRyb3AgZXZlcnl0aGluZyBhbmQgZ2V0IG91dCBvZiB0aGUgZmxvdyBjb21wbGV0ZWx5XG4gICAgW0FCT1JUXSgpIHtcbiAgICAgICAgdGhpc1tBQk9SVEVEXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnYWJvcnQnLCB0aGlzW1NJR05BTF0/LnJlYXNvbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSh0aGlzW1NJR05BTF0/LnJlYXNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHN0cmVhbSBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAqL1xuICAgIGdldCBhYm9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tBQk9SVEVEXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm8tb3Agc2V0dGVyLiBTdHJlYW0gYWJvcnRlZCBzdGF0dXMgaXMgc2V0IHZpYSB0aGUgQWJvcnRTaWduYWwgcHJvdmlkZWRcbiAgICAgKiBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXQgYWJvcnRlZChfKSB7IH1cbiAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGlmICh0aGlzW0FCT1JURURdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmNvZGluZylcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICBjb25zdCBmbiA9IHRoaXNbQVNZTkNdID8gZGVmZXIgOiBub2RlZmVyO1xuICAgICAgICAvLyBjb252ZXJ0IGFycmF5IGJ1ZmZlcnMgYW5kIHR5cGVkIGFycmF5IHZpZXdzIGludG8gYnVmZmVyc1xuICAgICAgICAvLyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsIHdlIG1heSB3YW50IHRvIGRvIHRoZSBvcHBvc2l0ZSFcbiAgICAgICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgICAgICAvLyBhbnl0aGluZyBpcyBvbmx5IGFsbG93ZWQgaWYgaW4gb2JqZWN0IG1vZGUsIHNvIHRocm93XG4gICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJMaWtlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWNvbnRpZ3VvdXMgZGF0YSB3cml0dGVuIHRvIG5vbi1vYmplY3RNb2RlIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBvYmplY3QgbW9kZSB1cCBmcm9udCwgc2luY2UgaXQncyBzaW1wbGVyXG4gICAgICAgIC8vIHRoaXMgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZSwgZmV3ZXIgY2hlY2tzIGxhdGVyLlxuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgLy8gbWF5YmUgaW1wb3NzaWJsZT9cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXNbRkxVU0hdKHRydWUpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKTtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgICAgIGZuKGNiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgICAgICAvLyBkb24ndCBidWZmZXIgaXQgdXAgb3Igc2VuZCBpdCB0byB0aGUgZGVjb2RlclxuICAgICAgICBpZiAoIWNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFzdC1wYXRoIHdyaXRpbmcgc3RyaW5ncyBvZiBzYW1lIGVuY29kaW5nIHRvIGEgc3RyZWFtIHdpdGhcbiAgICAgICAgLy8gYW4gZW1wdHkgYnVmZmVyLCBza2lwcGluZyB0aGUgYnVmZmVyL2RlY29kZXIgZGFuY2VcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIHN0cmluZyBhbHJlYWR5IHJlYWR5IGZvciB1cyB0byB1c2VcbiAgICAgICAgICAgICEoZW5jb2RpbmcgPT09IHRoaXNbRU5DT0RJTkddICYmICF0aGlzW0RFQ09ERVJdPy5sYXN0TmVlZCkpIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2VcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0aGlzW0VOQ09ESU5HXSkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5nZVxuICAgICAgICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBmbHVzaGluZyBDQU4gcG90ZW50aWFsbHkgc3dpdGNoIHVzIGludG8gbm90LWZsb3dpbmcgbW9kZVxuICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICB0aGlzW0ZMVVNIXSh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10pXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICBmbihjYik7XG4gICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgZXhwbGljaXQgcmVhZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBJbiBvYmplY3RNb2RlLCB0aGUgYXJndW1lbnQgaXMgaWdub3JlZCwgYW5kIG9uZSBpdGVtIGlzIHJldHVybmVkIGlmXG4gICAgICogYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogYG5gIGlzIHRoZSBudW1iZXIgb2YgYnl0ZXMgKG9yIGluIHRoZSBjYXNlIG9mIGVuY29kaW5nIHN0cmVhbXMsXG4gICAgICogY2hhcmFjdGVycykgdG8gY29uc3VtZS4gSWYgYG5gIGlzIG5vdCBwcm92aWRlZCwgdGhlbiB0aGUgZW50aXJlIGJ1ZmZlclxuICAgICAqIGlzIHJldHVybmVkLCBvciBgbnVsbGAgaXMgcmV0dXJuZWQgaWYgbm8gZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBJZiBgbmAgaXMgZ3JlYXRlciB0aGF0IHRoZSBhbW91bnQgb2YgZGF0YSBpbiB0aGUgaW50ZXJuYWwgYnVmZmVyLFxuICAgICAqIHRoZW4gYG51bGxgIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHJlYWQobikge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdID09PSAwIHx8XG4gICAgICAgICAgICBuID09PSAwIHx8XG4gICAgICAgICAgICAobiAmJiBuID4gdGhpc1tCVUZGRVJMRU5HVEhdKSkge1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUl0ubGVuZ3RoID4gMSAmJiAhdGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgLy8gbm90IG9iamVjdCBtb2RlLCBzbyBpZiB3ZSBoYXZlIGFuIGVuY29kaW5nLCB0aGVuIFJUeXBlIGlzIHN0cmluZ1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBtdXN0IGJlIEJ1ZmZlclxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gW1xuICAgICAgICAgICAgICAgICh0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXNbQlVGRkVSXS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQodGhpc1tCVUZGRVJdLCB0aGlzW0JVRkZFUkxFTkdUSF0pKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tSRUFEXShuIHx8IG51bGwsIHRoaXNbQlVGRkVSXVswXSk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtSRUFEXShuLCBjaHVuaykge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSU0hJRlRdKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYyA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKG4gPT09IGMubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJTSElGVF0oKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXVswXSA9IGMuc2xpY2Uobik7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjLnNsaWNlKDAsIG4pO1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdWzBdID0gYy5zdWJhcnJheShuKTtcbiAgICAgICAgICAgICAgICBjaHVuayA9IGMuc3ViYXJyYXkoMCwgbik7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBpZiAoIXRoaXNbQlVGRkVSXS5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBlbmQoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGNodW5rO1xuICAgICAgICAgICAgY2h1bmsgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIGNiKTtcbiAgICAgICAgdGhpc1tFT0ZdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgICAgIC8vIGV2ZW4gaWYgd2UncmUgbm90IHJlYWRpbmcuXG4gICAgICAgIC8vIHdlJ2xsIHJlLWVtaXQgaWYgYSBuZXcgJ2VuZCcgbGlzdGVuZXIgaXMgYWRkZWQgYW55d2F5LlxuICAgICAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgICAgIGlmICh0aGlzW0ZMT1dJTkddIHx8ICF0aGlzW1BBVVNFRF0pXG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZG9uJ3QgbGV0IHRoZSBpbnRlcm5hbCByZXN1bWUgYmUgb3ZlcndyaXR0ZW5cbiAgICBbUkVTVU1FXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzW0RBVEFMSVNURU5FUlNdICYmICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tQQVVTRURdID0gZmFsc2U7XG4gICAgICAgIHRoaXNbRkxPV0lOR10gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJdLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXNbRkxVU0hdKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lIHRoZSBzdHJlYW0gaWYgaXQgaXMgY3VycmVudGx5IGluIGEgcGF1c2VkIHN0YXRlXG4gICAgICpcbiAgICAgKiBJZiBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgbm8gcGlwZSBkZXN0aW5hdGlvbnMgb3IgYGRhdGFgIGV2ZW50IGxpc3RlbmVycyxcbiAgICAgKiB0aGlzIHdpbGwgcGxhY2UgdGhlIHN0cmVhbSBpbiBhIFwiZGlzY2FyZGVkXCIgc3RhdGUsIHdoZXJlIGFsbCBkYXRhIHdpbGxcbiAgICAgKiBiZSB0aHJvd24gYXdheS4gVGhlIGRpc2NhcmRlZCBzdGF0ZSBpcyByZW1vdmVkIGlmIGEgcGlwZSBkZXN0aW5hdGlvbiBvclxuICAgICAqIGRhdGEgaGFuZGxlciBpcyBhZGRlZCwgaWYgcGF1c2UoKSBpcyBjYWxsZWQsIG9yIGlmIGFueSBzeW5jaHJvbm91cyBvclxuICAgICAqIGFzeW5jaHJvbm91cyBpdGVyYXRpb24gaXMgc3RhcnRlZC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1JFU1VNRV0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgIHRoaXNbUEFVU0VEXSA9IHRydWU7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gaGFzIGJlZW4gZm9yY2libHkgZGVzdHJveWVkXG4gICAgICovXG4gICAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBpbiBhIGZsb3dpbmcgc3RhdGUsIG1lYW5pbmcgdGhhdFxuICAgICAqIGFueSB3cml0ZXMgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkLlxuICAgICAqL1xuICAgIGdldCBmbG93aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBpbiBhIHBhdXNlZCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1BBVVNFRF07XG4gICAgfVxuICAgIFtCVUZGRVJQVVNIXShjaHVuaykge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzW0JVRkZFUl0ucHVzaChjaHVuayk7XG4gICAgfVxuICAgIFtCVUZGRVJTSElGVF0oKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzW0JVRkZFUl1bMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpc1tCVUZGRVJdLnNoaWZ0KCk7XG4gICAgfVxuICAgIFtGTFVTSF0obm9EcmFpbiA9IGZhbHNlKSB7XG4gICAgICAgIGRvIHsgfSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSAmJlxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCk7XG4gICAgICAgIGlmICghbm9EcmFpbiAmJiAhdGhpc1tCVUZGRVJdLmxlbmd0aCAmJiAhdGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgIH1cbiAgICBbRkxVU0hDSFVOS10oY2h1bmspIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGlwZSBhbGwgZGF0YSBlbWl0dGVkIGJ5IHRoaXMgc3RyZWFtIGludG8gdGhlIGRlc3RpbmF0aW9uIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgdGhlIGZsb3cgb2YgZGF0YS5cbiAgICAgKi9cbiAgICBwaXBlKGRlc3QsIG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VNSVRURURfRU5EXTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGlmIChkZXN0ID09PSBwcm9jLnN0ZG91dCB8fCBkZXN0ID09PSBwcm9jLnN0ZGVycilcbiAgICAgICAgICAgIG9wdHMuZW5kID0gZmFsc2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9wdHMuZW5kID0gb3B0cy5lbmQgIT09IGZhbHNlO1xuICAgICAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzO1xuICAgICAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5lbmQpXG4gICAgICAgICAgICAgICAgZGVzdC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFwiYXNcIiBoZXJlIGp1c3QgaWdub3JlcyB0aGUgV1R5cGUsIHdoaWNoIHBpcGVzIGRvbid0IGNhcmUgYWJvdXQsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5J3JlIG9ubHkgY29uc3VtaW5nIGZyb20gdXMsIGFuZCB3cml0aW5nIHRvIHRoZSBkZXN0XG4gICAgICAgICAgICB0aGlzW1BJUEVTXS5wdXNoKCFvcHRzLnByb3h5RXJyb3JzXG4gICAgICAgICAgICAgICAgPyBuZXcgUGlwZSh0aGlzLCBkZXN0LCBvcHRzKVxuICAgICAgICAgICAgICAgIDogbmV3IFBpcGVQcm94eUVycm9ycyh0aGlzLCBkZXN0LCBvcHRzKSk7XG4gICAgICAgICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgICAgICAgICAgZGVmZXIoKCkgPT4gdGhpc1tSRVNVTUVdKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbUkVTVU1FXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdWxseSB1bmhvb2sgYSBwaXBlZCBkZXN0aW5hdGlvbiBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZGVzdGluYXRpb24gc3RyZWFtIHdhcyB0aGUgb25seSBjb25zdW1lciBvZiB0aGlzIHN0cmVhbSAoaWUsXG4gICAgICogdGhlcmUgYXJlIG5vIG90aGVyIHBpcGVkIGRlc3RpbmF0aW9ucyBvciBgJ2RhdGEnYCBldmVudCBsaXN0ZW5lcnMpXG4gICAgICogdGhlbiB0aGUgZmxvdyBvZiBkYXRhIHdpbGwgc3RvcCB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yXG4gICAgICoge0BsaW5rIE1pbmlwYXNzI3Jlc3VtZX0gaXMgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICovXG4gICAgdW5waXBlKGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXNbUElQRVNdLmZpbmQocCA9PiBwLmRlc3QgPT09IGRlc3QpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbUElQRVNdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddICYmIHRoaXNbREFUQUxJU1RFTkVSU10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW1BJUEVTXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbUElQRVNdLnNwbGljZSh0aGlzW1BJUEVTXS5pbmRleE9mKHApLCAxKTtcbiAgICAgICAgICAgIHAudW5waXBlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBNaW5pcGFzcyNvbn1cbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihldiwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5vbmAsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRvIHByZXZlbnQgZGF0YSBsb3NzIGFuZCB1bm5lY2Vzc2FyeSBoYW5nczpcbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGEgJ2RhdGEnIGV2ZW50IGhhbmRsZXIgd2lsbCB0cmlnZ2VyIHRoZSBmbG93IG9mIGRhdGFcbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGEgJ3JlYWRhYmxlJyBldmVudCBoYW5kbGVyIHdoZW4gdGhlcmUgaXMgZGF0YSB3YWl0aW5nIHRvIGJlIHJlYWRcbiAgICAgKiAgIHdpbGwgY2F1c2UgJ3JlYWRhYmxlJyB0byBiZSBlbWl0dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYW4gJ2VuZGlzaCcgZXZlbnQgaGFuZGxlciAoJ2VuZCcsICdmaW5pc2gnLCBldGMuKSB3aGljaCBoYXNcbiAgICAgKiAgIGFscmVhZHkgcGFzc2VkIHdpbGwgY2F1c2UgdGhlIGV2ZW50IHRvIGJlIGVtaXR0ZWQgaW1tZWRpYXRlbHkgYW5kIGFsbFxuICAgICAqICAgaGFuZGxlcnMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGFuICdlcnJvcicgZXZlbnQgaGFuZGxlciBhZnRlciBhbiBlcnJvciBoYXMgYmVlbiBlbWl0dGVkIHdpbGxcbiAgICAgKiAgIGNhdXNlIHRoZSBldmVudCB0byBiZSByZS1lbWl0dGVkIGltbWVkaWF0ZWx5IHdpdGggdGhlIGVycm9yIHByZXZpb3VzbHlcbiAgICAgKiAgIHJhaXNlZC5cbiAgICAgKi9cbiAgICBvbihldiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgaGFuZGxlcik7XG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10rKztcbiAgICAgICAgICAgIGlmICghdGhpc1tQSVBFU10ubGVuZ3RoICYmICF0aGlzW0ZMT1dJTkddKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tSRVNVTUVdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKSB7XG4gICAgICAgICAgICBzdXBlci5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRW5kaXNoKGV2KSAmJiB0aGlzW0VNSVRURURfRU5EXSkge1xuICAgICAgICAgICAgc3VwZXIuZW1pdChldik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdlcnJvcicgJiYgdGhpc1tFTUlUVEVEX0VSUk9SXSkge1xuICAgICAgICAgICAgY29uc3QgaCA9IGhhbmRsZXI7XG4gICAgICAgICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgICAgICAgICAgZGVmZXIoKCkgPT4gaC5jYWxsKHRoaXMsIHRoaXNbRU1JVFRFRF9FUlJPUl0pKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoLmNhbGwodGhpcywgdGhpc1tFTUlUVEVEX0VSUk9SXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBNaW5pcGFzcyNvZmZ9XG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLm9mZmBcbiAgICAgKlxuICAgICAqIElmIGEgJ2RhdGEnIGV2ZW50IGhhbmRsZXIgaXMgcmVtb3ZlZCwgYW5kIGl0IHdhcyB0aGUgbGFzdCBjb25zdW1lclxuICAgICAqIChpZSwgdGhlcmUgYXJlIG5vIHBpcGUgZGVzdGluYXRpb25zIG9yIG90aGVyICdkYXRhJyBldmVudCBsaXN0ZW5lcnMpLFxuICAgICAqIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3AgdW50aWwgdGhlcmUgaXMgYW5vdGhlciBjb25zdW1lciBvclxuICAgICAqIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqL1xuICAgIG9mZihldiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5vZmYoZXYsIGhhbmRsZXIpO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBsaXN0ZW5lcnMsIGFuZCBub3cgd2UgZG9uJ3QsIGFuZCB3ZSBkb24ndFxuICAgICAgICAvLyBoYXZlIGFueSBwaXBlcywgdGhlbiBzdG9wIHRoZSBmbG93LCB1bmxlc3MgaXQncyBiZWVuIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gcHV0IGluIGEgZGlzY2FyZGVkIGZsb3dpbmcgc3RhdGUgdmlhIHN0cmVhbS5yZXN1bWUoKS5cbiAgICAgICAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10gPSB0aGlzLmxpc3RlbmVycygnZGF0YScpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzW0RBVEFMSVNURU5FUlNdID09PSAwICYmXG4gICAgICAgICAgICAgICAgIXRoaXNbRElTQ0FSREVEXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVyc2BcbiAgICAgKlxuICAgICAqIElmIGFsbCAnZGF0YScgZXZlbnQgaGFuZGxlcnMgYXJlIHJlbW92ZWQsIGFuZCB0aGV5IHdlcmUgdGhlIGxhc3QgY29uc3VtZXJcbiAgICAgKiAoaWUsIHRoZXJlIGFyZSBubyBwaXBlIGRlc3RpbmF0aW9ucyksIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3BcbiAgICAgKiB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHlcbiAgICAgKiBjYWxsZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10gPSAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzW0RJU0NBUkRFRF0gJiYgIXRoaXNbUElQRVNdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSAnZW5kJyBldmVudCBoYXMgYmVlbiBlbWl0dGVkXG4gICAgICovXG4gICAgZ2V0IGVtaXR0ZWRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0VNSVRURURfRU5EXTtcbiAgICB9XG4gICAgW01BWUJFX0VNSVRfRU5EXSgpIHtcbiAgICAgICAgaWYgKCF0aGlzW0VNSVRUSU5HX0VORF0gJiZcbiAgICAgICAgICAgICF0aGlzW0VNSVRURURfRU5EXSAmJlxuICAgICAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgaWYgKHRoaXNbQ0xPU0VEXSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIuZW1pdGAsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRvIHByZXZlbnQgZGF0YSBsb3NzIGFuZCB1bm5lY2Vzc2FyeSBoYW5nczpcbiAgICAgKlxuICAgICAqIElmIHRoZSBzdHJlYW0gaGFzIGJlZW4gZGVzdHJveWVkLCBhbmQgdGhlIGV2ZW50IGlzIHNvbWV0aGluZyBvdGhlclxuICAgICAqIHRoYW4gJ2Nsb3NlJyBvciAnZXJyb3InLCB0aGVuIGBmYWxzZWAgaXMgcmV0dXJuZWQgYW5kIG5vIGhhbmRsZXJzXG4gICAgICogYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnZW5kJywgYW5kIGhhcyBhbHJlYWR5IGJlZW4gZW1pdHRlZCwgdGhlbiB0aGUgZXZlbnRcbiAgICAgKiBpcyBpZ25vcmVkLiBJZiB0aGUgc3RyZWFtIGlzIGluIGEgcGF1c2VkIG9yIG5vbi1mbG93aW5nIHN0YXRlLCB0aGVuXG4gICAgICogdGhlIGV2ZW50IHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgZGF0YSBmbG93IHJlc3VtZXMuIElmIHRoZSBzdHJlYW0gaXNcbiAgICAgKiBhc3luYywgdGhlbiBoYW5kbGVycyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgbmV4dCB0aWNrIHJhdGhlciB0aGFuXG4gICAgICogaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2Nsb3NlJywgYW5kICdlbmQnIGhhcyBub3QgeWV0IGJlZW4gZW1pdHRlZCwgdGhlblxuICAgICAqIHRoZSBldmVudCB3aWxsIGJlIGRlZmVycmVkIHVudGlsIGFmdGVyICdlbmQnIGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2Vycm9yJywgYW5kIGFuIEFib3J0U2lnbmFsIHdhcyBwcm92aWRlZCBmb3IgdGhlIHN0cmVhbSxcbiAgICAgKiBhbmQgdGhlcmUgYXJlIG5vIGxpc3RlbmVycywgdGhlbiB0aGUgZXZlbnQgaXMgaWdub3JlZCwgbWF0Y2hpbmcgdGhlXG4gICAgICogYmVoYXZpb3Igb2Ygbm9kZSBjb3JlIHN0cmVhbXMgaW4gdGhlIHByZXNlbnNlIG9mIGFuIEFib3J0U2lnbmFsLlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdmaW5pc2gnIG9yICdwcmVmaW5pc2gnLCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50LCB0byBwcmV2ZW50IGRvdWJsZS1maXJpbmcuXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXJnc1swXTtcbiAgICAgICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgICAgIGlmIChldiAhPT0gJ2Vycm9yJyAmJlxuICAgICAgICAgICAgZXYgIT09ICdjbG9zZScgJiZcbiAgICAgICAgICAgIGV2ICE9PSBERVNUUk9ZRUQgJiZcbiAgICAgICAgICAgIHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpc1tPQkpFQ1RNT0RFXSAmJiAhZGF0YVxuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXNbQVNZTkNdXG4gICAgICAgICAgICAgICAgICAgID8gKGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzW0VNSVREQVRBXShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgIHRoaXNbQ0xPU0VEXSA9IHRydWU7XG4gICAgICAgICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgICAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRURURfRVJST1JdID0gZGF0YTtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gIXRoaXNbU0lHTkFMXSB8fCB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IHN1cGVyLmVtaXQoJ2Vycm9yJywgZGF0YSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdyZXN1bWUnKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdyZXN1bWUnKTtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZmluaXNoJyB8fCBldiA9PT0gJ3ByZWZpbmlzaCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoZXYpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIG90aGVyIHVua25vd24gZXZlbnRcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtFTUlUREFUQV0oZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgICAgICAgIGlmIChwLmRlc3Qud3JpdGUoZGF0YSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW0RJU0NBUkRFRF0gPyBmYWxzZSA6IHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW0VNSVRFTkRdKCkge1xuICAgICAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpc1tBU1lOQ11cbiAgICAgICAgICAgID8gKGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpLCB0cnVlKVxuICAgICAgICAgICAgOiB0aGlzW0VNSVRFTkQyXSgpO1xuICAgIH1cbiAgICBbRU1JVEVORDJdKCkge1xuICAgICAgICBpZiAodGhpc1tERUNPREVSXSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXNbREVDT0RFUl0uZW5kKCk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgICAgICAgICAgICBwLmRlc3Qud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpc1tESVNDQVJERURdKVxuICAgICAgICAgICAgICAgICAgICBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgICBwLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBhbGwgZW1pdHRlZCBkYXRhIG9uY2VcbiAgICAgKiB0aGUgc3RyZWFtIGVuZHMuXG4gICAgICovXG4gICAgYXN5bmMgY29sbGVjdCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gT2JqZWN0LmFzc2lnbihbXSwge1xuICAgICAgICAgICAgZGF0YUxlbmd0aDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgLy8gc2V0IHRoZSBwcm9taXNlIGZpcnN0LCBpbiBjYXNlIGFuIGVycm9yIGlzIHJhaXNlZFxuICAgICAgICAvLyBieSB0cmlnZ2VyaW5nIHRoZSBmbG93IGhlcmUuXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnByb21pc2UoKTtcbiAgICAgICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgICAgICAgYnVmLnB1c2goYyk7XG4gICAgICAgICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGVtaXR0ZWQgZGF0YVxuICAgICAqIG9uY2UgdGhlIHN0cmVhbSBlbmRzLlxuICAgICAqXG4gICAgICogTm90IGFsbG93ZWQgb24gb2JqZWN0TW9kZSBzdHJlYW1zLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmNhdCgpIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgdGhpcy5jb2xsZWN0KCk7XG4gICAgICAgIHJldHVybiAodGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgID8gYnVmLmpvaW4oJycpXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2b2lkIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbihERVNUUk9ZRUQsICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSkpO1xuICAgICAgICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXMgYGZvciBhd2FpdCBvZmAgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNvbnRpbnVlIGVtaXR0aW5nIGFsbCBjaHVua3MgdW50aWwgdGhlIHN0cmVhbSB0ZXJtaW5hdGVzLlxuICAgICAqL1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIC8vIHNldCB0aGlzIHVwIGZyb250LCBpbiBjYXNlIHRoZSBjb25zdW1lciBkb2Vzbid0IGNhbGwgbmV4dCgpXG4gICAgICAgIC8vIHJpZ2h0IGF3YXkuXG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHJlcyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIGNvbnN0IG9uZXJyID0gKGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uZGF0YSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlLCBkb25lOiAhIXRoaXNbRU9GXSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZXJyb3InLCBvbmVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgdGhyb3c6IHN0b3AsXG4gICAgICAgICAgICByZXR1cm46IHN0b3AsXG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXMgYGZvciBvZmAgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdGlvbiB3aWxsIHRlcm1pbmF0ZSB3aGVuIHRoZSBpbnRlcm5hbCBidWZmZXIgcnVucyBvdXQsIGV2ZW5cbiAgICAgKiBpZiB0aGUgc3RyZWFtIGhhcyBub3QgeWV0IHRlcm1pbmF0ZWQuXG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIC8vIHNldCB0aGlzIHVwIGZyb250LCBpbiBjYXNlIHRoZSBjb25zdW1lciBkb2Vzbid0IGNhbGwgbmV4dCgpXG4gICAgICAgIC8vIHJpZ2h0IGF3YXkuXG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5vZmYoRVJST1IsIHN0b3ApO1xuICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBzdG9wKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBzdG9wKTtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBzdG9wKCkgOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIHN0b3ApO1xuICAgICAgICB0aGlzLm9uY2UoRVJST1IsIHN0b3ApO1xuICAgICAgICB0aGlzLm9uY2UoREVTVFJPWUVELCBzdG9wKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICB0aHJvdzogc3RvcCxcbiAgICAgICAgICAgIHJldHVybjogc3RvcCxcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhIHN0cmVhbSwgcHJldmVudGluZyBpdCBmcm9tIGJlaW5nIHVzZWQgZm9yIGFueSBmdXJ0aGVyIHB1cnBvc2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3RyZWFtIGhhcyBhIGBjbG9zZSgpYCBtZXRob2QsIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgb25cbiAgICAgKiBkZXN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIEFmdGVyIGRlc3RydWN0aW9uLCBhbnkgYXR0ZW1wdCB0byB3cml0ZSBkYXRhLCByZWFkIGRhdGEsIG9yIGVtaXQgbW9zdFxuICAgICAqIGV2ZW50cyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBlcnJvciBhcmd1bWVudCBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGVtaXR0ZWQgaW4gYW5cbiAgICAgKiAnZXJyb3InIGV2ZW50LlxuICAgICAqL1xuICAgIGRlc3Ryb3koZXIpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0RFU1RST1lFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSB0cnVlO1xuICAgICAgICAvLyB0aHJvdyBhd2F5IGFsbCBidWZmZXJlZCBkYXRhLCBpdCdzIG5ldmVyIGNvbWluZyBvdXRcbiAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDA7XG4gICAgICAgIGNvbnN0IHdjID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB3Yy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgICAgICAgd2MuY2xvc2UoKTtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgLy8gaWYgbm8gZXJyb3IgdG8gZW1pdCwgc3RpbGwgcmVqZWN0IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIGlzU3RyZWFtfVxuICAgICAqXG4gICAgICogRm9ybWVyIGV4cG9ydCBsb2NhdGlvbiwgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgaXNTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmlzU3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuTWluaXBhc3MgPSBNaW5pcGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNaW5pcGFzcyIsImlzV3JpdGFibGUiLCJpc1JlYWRhYmxlIiwiaXNTdHJlYW0iLCJwcm9jIiwicHJvY2VzcyIsInN0ZG91dCIsInN0ZGVyciIsIm5vZGVfZXZlbnRzXzEiLCJyZXF1aXJlIiwibm9kZV9zdHJlYW1fMSIsIm5vZGVfc3RyaW5nX2RlY29kZXJfMSIsInMiLCJkZWZhdWx0IiwiRXZlbnRFbWl0dGVyIiwicGlwZSIsIldyaXRhYmxlIiwicHJvdG90eXBlIiwid3JpdGUiLCJlbmQiLCJFT0YiLCJTeW1ib2wiLCJNQVlCRV9FTUlUX0VORCIsIkVNSVRURURfRU5EIiwiRU1JVFRJTkdfRU5EIiwiRU1JVFRFRF9FUlJPUiIsIkNMT1NFRCIsIlJFQUQiLCJGTFVTSCIsIkZMVVNIQ0hVTksiLCJFTkNPRElORyIsIkRFQ09ERVIiLCJGTE9XSU5HIiwiUEFVU0VEIiwiUkVTVU1FIiwiQlVGRkVSIiwiUElQRVMiLCJCVUZGRVJMRU5HVEgiLCJCVUZGRVJQVVNIIiwiQlVGRkVSU0hJRlQiLCJPQkpFQ1RNT0RFIiwiREVTVFJPWUVEIiwiRVJST1IiLCJFTUlUREFUQSIsIkVNSVRFTkQiLCJFTUlURU5EMiIsIkFTWU5DIiwiQUJPUlQiLCJBQk9SVEVEIiwiU0lHTkFMIiwiREFUQUxJU1RFTkVSUyIsIkRJU0NBUkRFRCIsImRlZmVyIiwiZm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJub2RlZmVyIiwiaXNFbmRpc2giLCJldiIsImlzQXJyYXlCdWZmZXJMaWtlIiwiYiIsIkFycmF5QnVmZmVyIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYnl0ZUxlbmd0aCIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJpc1ZpZXciLCJQaXBlIiwic3JjIiwiZGVzdCIsIm9wdHMiLCJvbmRyYWluIiwib24iLCJ1bnBpcGUiLCJyZW1vdmVMaXN0ZW5lciIsInByb3h5RXJyb3JzIiwiX2VyIiwiUGlwZVByb3h5RXJyb3JzIiwiZXIiLCJlbWl0IiwiaXNPYmplY3RNb2RlT3B0aW9ucyIsIm8iLCJvYmplY3RNb2RlIiwiaXNFbmNvZGluZ09wdGlvbnMiLCJlbmNvZGluZyIsImFyZ3MiLCJvcHRpb25zIiwid3JpdGFibGUiLCJyZWFkYWJsZSIsIlR5cGVFcnJvciIsImFzeW5jIiwiU3RyaW5nRGVjb2RlciIsImRlYnVnRXhwb3NlQnVmZmVyIiwiZ2V0IiwiZGVidWdFeHBvc2VQaXBlcyIsInNpZ25hbCIsImFib3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiYnVmZmVyTGVuZ3RoIiwiX2VuYyIsIkVycm9yIiwic2V0RW5jb2RpbmciLCJfb20iLCJhIiwicmVhc29uIiwiZGVzdHJveSIsIl8iLCJjaHVuayIsImNiIiwiYXNzaWduIiwiY29kZSIsImZyb20iLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwibGVuZ3RoIiwibGFzdE5lZWQiLCJyZWFkIiwibiIsImpvaW4iLCJjb25jYXQiLCJyZXQiLCJjIiwic2xpY2UiLCJzdWJhcnJheSIsInVuZGVmaW5lZCIsIm9uY2UiLCJyZXN1bWUiLCJwYXVzZSIsImRlc3Ryb3llZCIsImZsb3dpbmciLCJwYXVzZWQiLCJwdXNoIiwic2hpZnQiLCJub0RyYWluIiwiZW5kZWQiLCJwIiwiZmluZCIsInNwbGljZSIsImluZGV4T2YiLCJhZGRMaXN0ZW5lciIsImhhbmRsZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJoIiwiY2FsbCIsIm9mZiIsImxpc3RlbmVycyIsImVtaXR0ZWRFbmQiLCJkYXRhIiwiY29sbGVjdCIsImJ1ZiIsImRhdGFMZW5ndGgiLCJwcm9taXNlIiwicmVqZWN0IiwiYXN5bmNJdGVyYXRvciIsInN0b3BwZWQiLCJzdG9wIiwiZG9uZSIsIm5leHQiLCJyZXMiLCJvbmVyciIsIm9uZGF0YSIsIm9uZW5kIiwib25kZXN0cm95IiwicmVqIiwidGhyb3ciLCJyZXR1cm4iLCJpdGVyYXRvciIsIndjIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minipass/dist/commonjs/index.js\n");

/***/ })

};
;