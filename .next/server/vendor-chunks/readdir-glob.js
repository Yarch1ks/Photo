/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readdir-glob";
exports.ids = ["vendor-chunks/readdir-glob"];
exports.modules = {

/***/ "(rsc)/./node_modules/readdir-glob/index.js":
/*!********************************************!*\
  !*** ./node_modules/readdir-glob/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = readdirGlob;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\");\nconst { Minimatch } = __webpack_require__(/*! minimatch */ \"(rsc)/./node_modules/readdir-glob/node_modules/minimatch/minimatch.js\");\nconst { resolve } = __webpack_require__(/*! path */ \"path\");\nfunction readdir(dir, strict) {\n    return new Promise((resolve, reject)=>{\n        fs.readdir(dir, {\n            withFileTypes: true\n        }, (err, files)=>{\n            if (err) {\n                switch(err.code){\n                    case \"ENOTDIR\":\n                        if (strict) {\n                            reject(err);\n                        } else {\n                            resolve([]);\n                        }\n                        break;\n                    case \"ENOTSUP\":\n                    case \"ENOENT\":\n                    case \"ENAMETOOLONG\":\n                    case \"UNKNOWN\":\n                        resolve([]);\n                        break;\n                    case \"ELOOP\":\n                    default:\n                        reject(err);\n                        break;\n                }\n            } else {\n                resolve(files);\n            }\n        });\n    });\n}\nfunction stat(file, followSymlinks) {\n    return new Promise((resolve, reject)=>{\n        const statFunc = followSymlinks ? fs.stat : fs.lstat;\n        statFunc(file, (err, stats)=>{\n            if (err) {\n                switch(err.code){\n                    case \"ENOENT\":\n                        if (followSymlinks) {\n                            // Fallback to lstat to handle broken links as files\n                            resolve(stat(file, false));\n                        } else {\n                            resolve(null);\n                        }\n                        break;\n                    default:\n                        resolve(null);\n                        break;\n                }\n            } else {\n                resolve(stats);\n            }\n        });\n    });\n}\nasync function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {\n    let files = await readdir(path + dir, strict);\n    for (const file of files){\n        let name = file.name;\n        if (name === undefined) {\n            // undefined file.name means the `withFileTypes` options is not supported by node\n            // we have to call the stat function to know if file is directory or not.\n            name = file;\n            useStat = true;\n        }\n        const filename = dir + \"/\" + name;\n        const relative = filename.slice(1); // Remove the leading /\n        const absolute = path + \"/\" + relative;\n        let stats = null;\n        if (useStat || followSymlinks) {\n            stats = await stat(absolute, followSymlinks);\n        }\n        if (!stats && file.name !== undefined) {\n            stats = file;\n        }\n        if (stats === null) {\n            stats = {\n                isDirectory: ()=>false\n            };\n        }\n        if (stats.isDirectory()) {\n            if (!shouldSkip(relative)) {\n                yield {\n                    relative,\n                    absolute,\n                    stats\n                };\n                yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);\n            }\n        } else {\n            yield {\n                relative,\n                absolute,\n                stats\n            };\n        }\n    }\n}\nasync function* explore(path, followSymlinks, useStat, shouldSkip) {\n    yield* exploreWalkAsync(\"\", path, followSymlinks, useStat, shouldSkip, true);\n}\nfunction readOptions(options) {\n    return {\n        pattern: options.pattern,\n        dot: !!options.dot,\n        noglobstar: !!options.noglobstar,\n        matchBase: !!options.matchBase,\n        nocase: !!options.nocase,\n        ignore: options.ignore,\n        skip: options.skip,\n        follow: !!options.follow,\n        stat: !!options.stat,\n        nodir: !!options.nodir,\n        mark: !!options.mark,\n        silent: !!options.silent,\n        absolute: !!options.absolute\n    };\n}\nclass ReaddirGlob extends EventEmitter {\n    constructor(cwd, options, cb){\n        super();\n        if (typeof options === \"function\") {\n            cb = options;\n            options = null;\n        }\n        this.options = readOptions(options || {});\n        this.matchers = [];\n        if (this.options.pattern) {\n            const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [\n                this.options.pattern\n            ];\n            this.matchers = matchers.map((m)=>new Minimatch(m, {\n                    dot: this.options.dot,\n                    noglobstar: this.options.noglobstar,\n                    matchBase: this.options.matchBase,\n                    nocase: this.options.nocase\n                }));\n        }\n        this.ignoreMatchers = [];\n        if (this.options.ignore) {\n            const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [\n                this.options.ignore\n            ];\n            this.ignoreMatchers = ignorePatterns.map((ignore)=>new Minimatch(ignore, {\n                    dot: true\n                }));\n        }\n        this.skipMatchers = [];\n        if (this.options.skip) {\n            const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [\n                this.options.skip\n            ];\n            this.skipMatchers = skipPatterns.map((skip)=>new Minimatch(skip, {\n                    dot: true\n                }));\n        }\n        this.iterator = explore(resolve(cwd || \".\"), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));\n        this.paused = false;\n        this.inactive = false;\n        this.aborted = false;\n        if (cb) {\n            this._matches = [];\n            this.on(\"match\", (match)=>this._matches.push(this.options.absolute ? match.absolute : match.relative));\n            this.on(\"error\", (err)=>cb(err));\n            this.on(\"end\", ()=>cb(null, this._matches));\n        }\n        setTimeout(()=>this._next(), 0);\n    }\n    _shouldSkipDirectory(relative) {\n        //console.log(relative, this.skipMatchers.some(m => m.match(relative)));\n        return this.skipMatchers.some((m)=>m.match(relative));\n    }\n    _fileMatches(relative, isDirectory) {\n        const file = relative + (isDirectory ? \"/\" : \"\");\n        return (this.matchers.length === 0 || this.matchers.some((m)=>m.match(file))) && !this.ignoreMatchers.some((m)=>m.match(file)) && (!this.options.nodir || !isDirectory);\n    }\n    _next() {\n        if (!this.paused && !this.aborted) {\n            this.iterator.next().then((obj)=>{\n                if (!obj.done) {\n                    const isDirectory = obj.value.stats.isDirectory();\n                    if (this._fileMatches(obj.value.relative, isDirectory)) {\n                        let relative = obj.value.relative;\n                        let absolute = obj.value.absolute;\n                        if (this.options.mark && isDirectory) {\n                            relative += \"/\";\n                            absolute += \"/\";\n                        }\n                        if (this.options.stat) {\n                            this.emit(\"match\", {\n                                relative,\n                                absolute,\n                                stat: obj.value.stats\n                            });\n                        } else {\n                            this.emit(\"match\", {\n                                relative,\n                                absolute\n                            });\n                        }\n                    }\n                    this._next(this.iterator);\n                } else {\n                    this.emit(\"end\");\n                }\n            }).catch((err)=>{\n                this.abort();\n                this.emit(\"error\", err);\n                if (!err.code && !this.options.silent) {\n                    console.error(err);\n                }\n            });\n        } else {\n            this.inactive = true;\n        }\n    }\n    abort() {\n        this.aborted = true;\n    }\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        this.paused = false;\n        if (this.inactive) {\n            this.inactive = false;\n            this._next();\n        }\n    }\n}\nfunction readdirGlob(pattern, options, cb) {\n    return new ReaddirGlob(pattern, options, cb);\n}\nreaddirGlob.ReaddirGlob = ReaddirGlob;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLE1BQU1DLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUdELG1CQUFPQSxDQUFDO0FBQ2pDLE1BQU0sRUFBRUUsU0FBUyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU0sRUFBRUcsT0FBTyxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBRTVCLFNBQVNJLFFBQVFDLEdBQUcsRUFBRUMsTUFBTTtJQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0osU0FBU0s7UUFDM0JULEdBQUdLLE9BQU8sQ0FBQ0MsS0FBSztZQUFDSSxlQUFlO1FBQUksR0FBRyxDQUFDQyxLQUFLQztZQUMzQyxJQUFHRCxLQUFLO2dCQUNOLE9BQVFBLElBQUlFLElBQUk7b0JBQ2QsS0FBSzt3QkFDSCxJQUFHTixRQUFROzRCQUNURSxPQUFPRTt3QkFDVCxPQUFPOzRCQUNMUCxRQUFRLEVBQUU7d0JBQ1o7d0JBQ0E7b0JBQ0YsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSEEsUUFBUSxFQUFFO3dCQUNWO29CQUNGLEtBQUs7b0JBQ0w7d0JBQ0VLLE9BQU9FO3dCQUNQO2dCQUNKO1lBQ0YsT0FBTztnQkFDTFAsUUFBUVE7WUFDVjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLFNBQVNFLEtBQUtDLElBQUksRUFBRUMsY0FBYztJQUNoQyxPQUFPLElBQUlSLFFBQVEsQ0FBQ0osU0FBU0s7UUFDM0IsTUFBTVEsV0FBV0QsaUJBQWlCaEIsR0FBR2MsSUFBSSxHQUFHZCxHQUFHa0IsS0FBSztRQUNwREQsU0FBU0YsTUFBTSxDQUFDSixLQUFLUTtZQUNuQixJQUFHUixLQUFLO2dCQUNOLE9BQVFBLElBQUlFLElBQUk7b0JBQ2QsS0FBSzt3QkFDSCxJQUFHRyxnQkFBZ0I7NEJBQ2pCLG9E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Q0FBQ3dDLEtBQUssQ0FBQyxJQUFJLENBQUNYLFFBQVE7Z0JBQzFCLE9BQU87b0JBQ0wsSUFBSSxDQUFDb0IsSUFBSSxDQUFDO2dCQUNaO1lBQ0YsR0FDQ0MsS0FBSyxDQUFDLENBQUNwRTtnQkFDTixJQUFJLENBQUNxRSxLQUFLO2dCQUNWLElBQUksQ0FBQ0YsSUFBSSxDQUFDLFNBQVNuRTtnQkFDbkIsSUFBRyxDQUFDQSxJQUFJRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUNvQixPQUFPLENBQUNXLE1BQU0sRUFBRTtvQkFDcENxQyxRQUFRQyxLQUFLLENBQUN2RTtnQkFDaEI7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNtRCxRQUFRLEdBQUc7UUFDbEI7SUFDRjtJQUVBa0IsUUFBUTtRQUNOLElBQUksQ0FBQ2pCLE9BQU8sR0FBRztJQUNqQjtJQUVBb0IsUUFBUTtRQUNOLElBQUksQ0FBQ3RCLE1BQU0sR0FBRztJQUNoQjtJQUVBdUIsU0FBUztRQUNQLElBQUksQ0FBQ3ZCLE1BQU0sR0FBRztRQUNkLElBQUcsSUFBSSxDQUFDQyxRQUFRLEVBQUU7WUFDaEIsSUFBSSxDQUFDQSxRQUFRLEdBQUc7WUFDaEIsSUFBSSxDQUFDTyxLQUFLO1FBQ1o7SUFDRjtBQUNGO0FBR0EsU0FBU3RFLFlBQVltQyxPQUFPLEVBQUVELE9BQU8sRUFBRWUsRUFBRTtJQUN2QyxPQUFPLElBQUlILFlBQVlYLFNBQVNELFNBQVNlO0FBQzNDO0FBQ0FqRCxZQUFZOEMsV0FBVyxHQUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvLXNrdS1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL2luZGV4LmpzP2Y1NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZWFkZGlyR2xvYjtcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgeyBNaW5pbWF0Y2ggfSA9IHJlcXVpcmUoJ21pbmltYXRjaCcpO1xuY29uc3QgeyByZXNvbHZlIH0gPSByZXF1aXJlKCdwYXRoJyk7XG5cbmZ1bmN0aW9uIHJlYWRkaXIoZGlyLCBzdHJpY3QpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkZGlyKGRpciwge3dpdGhGaWxlVHlwZXM6IHRydWV9ICwoZXJyLCBmaWxlcykgPT4ge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICBjYXNlICdFTk9URElSJzogICAgICAvLyBOb3QgYSBkaXJlY3RvcnlcbiAgICAgICAgICAgIGlmKHN0cmljdCkge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5PVFNVUCc6ICAgICAgLy8gT3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICBjYXNlICdFTk9FTlQnOiAgICAgICAvLyBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XG4gICAgICAgICAgY2FzZSAnRU5BTUVUT09MT05HJzogLy8gRmlsZW5hbWUgdG9vIGxvbmdcbiAgICAgICAgICBjYXNlICdVTktOT1dOJzpcbiAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRUxPT1AnOiAgICAgICAgLy8gVG9vIG1hbnkgbGV2ZWxzIG9mIHN5bWJvbGljIGxpbmtzXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoZmlsZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHN0YXQoZmlsZSwgZm9sbG93U3ltbGlua3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzdGF0RnVuYyA9IGZvbGxvd1N5bWxpbmtzID8gZnMuc3RhdCA6IGZzLmxzdGF0O1xuICAgIHN0YXRGdW5jKGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgICAgICBpZihmb2xsb3dTeW1saW5rcykge1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBsc3RhdCB0byBoYW5kbGUgYnJva2VuIGxpbmtzIGFzIGZpbGVzXG4gICAgICAgICAgICAgIHJlc29sdmUoc3RhdChmaWxlLCBmYWxzZSkpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBleHBsb3JlV2Fsa0FzeW5jKGRpciwgcGF0aCwgZm9sbG93U3ltbGlua3MsIHVzZVN0YXQsIHNob3VsZFNraXAsIHN0cmljdCkge1xuICBsZXQgZmlsZXMgPSBhd2FpdCByZWFkZGlyKHBhdGggKyBkaXIsIHN0cmljdCk7XG4gIGZvcihjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgbGV0IG5hbWUgPSBmaWxlLm5hbWU7XG4gICAgaWYobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB1bmRlZmluZWQgZmlsZS5uYW1lIG1lYW5zIHRoZSBgd2l0aEZpbGVUeXBlc2Agb3B0aW9ucyBpcyBub3Qgc3VwcG9ydGVkIGJ5IG5vZGVcbiAgICAgIC8vIHdlIGhhdmUgdG8gY2FsbCB0aGUgc3RhdCBmdW5jdGlvbiB0byBrbm93IGlmIGZpbGUgaXMgZGlyZWN0b3J5IG9yIG5vdC5cbiAgICAgIG5hbWUgPSBmaWxlO1xuICAgICAgdXNlU3RhdCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVuYW1lID0gZGlyICsgJy8nICsgbmFtZTtcbiAgICBjb25zdCByZWxhdGl2ZSA9IGZpbGVuYW1lLnNsaWNlKDEpOyAvLyBSZW1vdmUgdGhlIGxlYWRpbmcgL1xuICAgIGNvbnN0IGFic29sdXRlID0gcGF0aCArICcvJyArIHJlbGF0aXZlO1xuICAgIGxldCBzdGF0cyA9IG51bGw7XG4gICAgaWYodXNlU3RhdCB8fCBmb2xsb3dTeW1saW5rcykge1xuICAgICAgc3RhdHMgPSBhd2FpdCBzdGF0KGFic29sdXRlLCBmb2xsb3dTeW1saW5rcyk7XG4gICAgfVxuICAgIGlmKCFzdGF0cyAmJiBmaWxlLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdHMgPSBmaWxlO1xuICAgIH1cbiAgICBpZihzdGF0cyA9PT0gbnVsbCkge1xuICAgICAgc3RhdHMgPSB7IGlzRGlyZWN0b3J5OiAoKSA9PiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGlmKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGlmKCFzaG91bGRTa2lwKHJlbGF0aXZlKSkge1xuICAgICAgICB5aWVsZCB7cmVsYXRpdmUsIGFic29sdXRlLCBzdGF0c307XG4gICAgICAgIHlpZWxkKiBleHBsb3JlV2Fsa0FzeW5jKGZpbGVuYW1lLCBwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCB7cmVsYXRpdmUsIGFic29sdXRlLCBzdGF0c307XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiogZXhwbG9yZShwYXRoLCBmb2xsb3dTeW1saW5rcywgdXNlU3RhdCwgc2hvdWxkU2tpcCkge1xuICB5aWVsZCogZXhwbG9yZVdhbGtBc3luYygnJywgcGF0aCwgZm9sbG93U3ltbGlua3MsIHVzZVN0YXQsIHNob3VsZFNraXAsIHRydWUpO1xufVxuXG5cbmZ1bmN0aW9uIHJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwYXR0ZXJuOiBvcHRpb25zLnBhdHRlcm4sXG4gICAgZG90OiAhIW9wdGlvbnMuZG90LFxuICAgIG5vZ2xvYnN0YXI6ICEhb3B0aW9ucy5ub2dsb2JzdGFyLFxuICAgIG1hdGNoQmFzZTogISFvcHRpb25zLm1hdGNoQmFzZSxcbiAgICBub2Nhc2U6ICEhb3B0aW9ucy5ub2Nhc2UsXG4gICAgaWdub3JlOiBvcHRpb25zLmlnbm9yZSxcbiAgICBza2lwOiBvcHRpb25zLnNraXAsXG5cbiAgICBmb2xsb3c6ICEhb3B0aW9ucy5mb2xsb3csXG4gICAgc3RhdDogISFvcHRpb25zLnN0YXQsXG4gICAgbm9kaXI6ICEhb3B0aW9ucy5ub2RpcixcbiAgICBtYXJrOiAhIW9wdGlvbnMubWFyayxcbiAgICBzaWxlbnQ6ICEhb3B0aW9ucy5zaWxlbnQsXG4gICAgYWJzb2x1dGU6ICEhb3B0aW9ucy5hYnNvbHV0ZVxuICB9O1xufVxuXG5jbGFzcyBSZWFkZGlyR2xvYiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGN3ZCwgb3B0aW9ucywgY2IpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSByZWFkT3B0aW9ucyhvcHRpb25zIHx8wqB7fSk7XG4gIFxuICAgIHRoaXMubWF0Y2hlcnMgPSBbXTtcbiAgICBpZih0aGlzLm9wdGlvbnMucGF0dGVybikge1xuICAgICAgY29uc3QgbWF0Y2hlcnMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5wYXR0ZXJuKSA/IHRoaXMub3B0aW9ucy5wYXR0ZXJuIDogW3RoaXMub3B0aW9ucy5wYXR0ZXJuXTtcbiAgICAgIHRoaXMubWF0Y2hlcnMgPSBtYXRjaGVycy5tYXAoIG0gPT5cbiAgICAgICAgbmV3IE1pbmltYXRjaChtLCB7XG4gICAgICAgICAgZG90OiB0aGlzLm9wdGlvbnMuZG90LFxuICAgICAgICAgIG5vZ2xvYnN0YXI6dGhpcy5vcHRpb25zLm5vZ2xvYnN0YXIsXG4gICAgICAgICAgbWF0Y2hCYXNlOnRoaXMub3B0aW9ucy5tYXRjaEJhc2UsXG4gICAgICAgICAgbm9jYXNlOnRoaXMub3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICBcbiAgICB0aGlzLmlnbm9yZU1hdGNoZXJzID0gW107XG4gICAgaWYodGhpcy5vcHRpb25zLmlnbm9yZSkge1xuICAgICAgY29uc3QgaWdub3JlUGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5pZ25vcmUpID8gdGhpcy5vcHRpb25zLmlnbm9yZSA6IFt0aGlzLm9wdGlvbnMuaWdub3JlXTtcbiAgICAgIHRoaXMuaWdub3JlTWF0Y2hlcnMgPSBpZ25vcmVQYXR0ZXJucy5tYXAoIGlnbm9yZSA9PlxuICAgICAgICBuZXcgTWluaW1hdGNoKGlnbm9yZSwge2RvdDogdHJ1ZX0pXG4gICAgICApO1xuICAgIH1cbiAgXG4gICAgdGhpcy5za2lwTWF0Y2hlcnMgPSBbXTtcbiAgICBpZih0aGlzLm9wdGlvbnMuc2tpcCkge1xuICAgICAgY29uc3Qgc2tpcFBhdHRlcm5zID0gQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuc2tpcCkgPyB0aGlzLm9wdGlvbnMuc2tpcCA6IFt0aGlzLm9wdGlvbnMuc2tpcF07XG4gICAgICB0aGlzLnNraXBNYXRjaGVycyA9IHNraXBQYXR0ZXJucy5tYXAoIHNraXAgPT5cbiAgICAgICAgbmV3IE1pbmltYXRjaChza2lwLCB7ZG90OiB0cnVlfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVyYXRvciA9IGV4cGxvcmUocmVzb2x2ZShjd2QgfHwgJy4nKSwgdGhpcy5vcHRpb25zLmZvbGxvdywgdGhpcy5vcHRpb25zLnN0YXQsIHRoaXMuX3Nob3VsZFNraXBEaXJlY3RvcnkuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gIFxuICAgIGlmKGNiKSB7XG4gICAgICB0aGlzLl9tYXRjaGVzID0gW107IFxuICAgICAgdGhpcy5vbignbWF0Y2gnLCBtYXRjaCA9PiB0aGlzLl9tYXRjaGVzLnB1c2godGhpcy5vcHRpb25zLmFic29sdXRlID8gbWF0Y2guYWJzb2x1dGUgOiBtYXRjaC5yZWxhdGl2ZSkpO1xuICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4gY2IoZXJyKSk7XG4gICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiBjYihudWxsLCB0aGlzLl9tYXRjaGVzKSk7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dCggKCkgPT4gdGhpcy5fbmV4dCgpLCAwKTtcbiAgfVxuXG4gIF9zaG91bGRTa2lwRGlyZWN0b3J5KHJlbGF0aXZlKSB7XG4gICAgLy9jb25zb2xlLmxvZyhyZWxhdGl2ZSwgdGhpcy5za2lwTWF0Y2hlcnMuc29tZShtID0+IG0ubWF0Y2gocmVsYXRpdmUpKSk7XG4gICAgcmV0dXJuIHRoaXMuc2tpcE1hdGNoZXJzLnNvbWUobSA9PiBtLm1hdGNoKHJlbGF0aXZlKSk7XG4gIH1cblxuICBfZmlsZU1hdGNoZXMocmVsYXRpdmUsIGlzRGlyZWN0b3J5KSB7XG4gICAgY29uc3QgZmlsZSA9IHJlbGF0aXZlICsgKGlzRGlyZWN0b3J5ID8gJy8nIDogJycpO1xuICAgIHJldHVybiAodGhpcy5tYXRjaGVycy5sZW5ndGggPT09IDAgfHwgdGhpcy5tYXRjaGVycy5zb21lKG0gPT4gbS5tYXRjaChmaWxlKSkpXG4gICAgICAmJiAhdGhpcy5pZ25vcmVNYXRjaGVycy5zb21lKG0gPT4gbS5tYXRjaChmaWxlKSlcbiAgICAgICYmICghdGhpcy5vcHRpb25zLm5vZGlyIHx8ICFpc0RpcmVjdG9yeSk7XG4gIH1cblxuICBfbmV4dCgpIHtcbiAgICBpZighdGhpcy5wYXVzZWQgJiYgIXRoaXMuYWJvcnRlZCkge1xuICAgICAgdGhpcy5pdGVyYXRvci5uZXh0KClcbiAgICAgIC50aGVuKChvYmopPT4ge1xuICAgICAgICBpZighb2JqLmRvbmUpIHtcbiAgICAgICAgICBjb25zdCBpc0RpcmVjdG9yeSA9IG9iai52YWx1ZS5zdGF0cy5pc0RpcmVjdG9yeSgpO1xuICAgICAgICAgIGlmKHRoaXMuX2ZpbGVNYXRjaGVzKG9iai52YWx1ZS5yZWxhdGl2ZSwgaXNEaXJlY3RvcnkgKSkge1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlID0gb2JqLnZhbHVlLnJlbGF0aXZlO1xuICAgICAgICAgICAgbGV0IGFic29sdXRlID0gb2JqLnZhbHVlLmFic29sdXRlO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLm1hcmsgJiYgaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgcmVsYXRpdmUgKz0gJy8nO1xuICAgICAgICAgICAgICBhYnNvbHV0ZSArPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc3RhdCkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21hdGNoJywge3JlbGF0aXZlLCBhYnNvbHV0ZSwgc3RhdDpvYmoudmFsdWUuc3RhdHN9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWF0Y2gnLCB7cmVsYXRpdmUsIGFic29sdXRlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX25leHQodGhpcy5pdGVyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIGlmKCFlcnIuY29kZSAmJiAhdGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5hY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGFib3J0KCkge1xuICAgIHRoaXMuYWJvcnRlZCA9IHRydWU7XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gIH1cblxuICByZXN1bWUoKSB7XG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICBpZih0aGlzLmluYWN0aXZlKSB7XG4gICAgICB0aGlzLmluYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9uZXh0KCk7XG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZGRpckdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgcmV0dXJuIG5ldyBSZWFkZGlyR2xvYihwYXR0ZXJuLCBvcHRpb25zLCBjYik7XG59XG5yZWFkZGlyR2xvYi5SZWFkZGlyR2xvYiA9IFJlYWRkaXJHbG9iOyJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVhZGRpckdsb2IiLCJmcyIsInJlcXVpcmUiLCJFdmVudEVtaXR0ZXIiLCJNaW5pbWF0Y2giLCJyZXNvbHZlIiwicmVhZGRpciIsImRpciIsInN0cmljdCIsIlByb21pc2UiLCJyZWplY3QiLCJ3aXRoRmlsZVR5cGVzIiwiZXJyIiwiZmlsZXMiLCJjb2RlIiwic3RhdCIsImZpbGUiLCJmb2xsb3dTeW1saW5rcyIsInN0YXRGdW5jIiwibHN0YXQiLCJzdGF0cyIsImV4cGxvcmVXYWxrQXN5bmMiLCJwYXRoIiwidXNlU3RhdCIsInNob3VsZFNraXAiLCJuYW1lIiwidW5kZWZpbmVkIiwiZmlsZW5hbWUiLCJyZWxhdGl2ZSIsInNsaWNlIiwiYWJzb2x1dGUiLCJpc0RpcmVjdG9yeSIsImV4cGxvcmUiLCJyZWFkT3B0aW9ucyIsIm9wdGlvbnMiLCJwYXR0ZXJuIiwiZG90Iiwibm9nbG9ic3RhciIsIm1hdGNoQmFzZSIsIm5vY2FzZSIsImlnbm9yZSIsInNraXAiLCJmb2xsb3ciLCJub2RpciIsIm1hcmsiLCJzaWxlbnQiLCJSZWFkZGlyR2xvYiIsImNvbnN0cnVjdG9yIiwiY3dkIiwiY2IiLCJtYXRjaGVycyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm0iLCJpZ25vcmVNYXRjaGVycyIsImlnbm9yZVBhdHRlcm5zIiwic2tpcE1hdGNoZXJzIiwic2tpcFBhdHRlcm5zIiwiaXRlcmF0b3IiLCJfc2hvdWxkU2tpcERpcmVjdG9yeSIsImJpbmQiLCJwYXVzZWQiLCJpbmFjdGl2ZSIsImFib3J0ZWQiLCJfbWF0Y2hlcyIsIm9uIiwibWF0Y2giLCJwdXNoIiwic2V0VGltZW91dCIsIl9uZXh0Iiwic29tZSIsIl9maWxlTWF0Y2hlcyIsImxlbmd0aCIsIm5leHQiLCJ0aGVuIiwib2JqIiwiZG9uZSIsInZhbHVlIiwiZW1pdCIsImNhdGNoIiwiYWJvcnQiLCJjb25zb2xlIiwiZXJyb3IiLCJwYXVzZSIsInJlc3VtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readdir-glob/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readdir-glob/node_modules/brace-expansion/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readdir-glob/node_modules/brace-expansion/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var balanced = __webpack_require__(/*! balanced-match */ \"(rsc)/./node_modules/balanced-match/index.js\");\nmodule.exports = expandTop;\nvar escSlash = \"\\x00SLASH\" + Math.random() + \"\\x00\";\nvar escOpen = \"\\x00OPEN\" + Math.random() + \"\\x00\";\nvar escClose = \"\\x00CLOSE\" + Math.random() + \"\\x00\";\nvar escComma = \"\\x00COMMA\" + Math.random() + \"\\x00\";\nvar escPeriod = \"\\x00PERIOD\" + Math.random() + \"\\x00\";\nfunction numeric(str) {\n    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str.split(\"\\\\\\\\\").join(escSlash).split(\"\\\\{\").join(escOpen).split(\"\\\\}\").join(escClose).split(\"\\\\,\").join(escComma).split(\"\\\\.\").join(escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str.split(escSlash).join(\"\\\\\").split(escOpen).join(\"{\").split(escClose).join(\"}\").split(escComma).join(\",\").split(escPeriod).join(\".\");\n}\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n    if (!str) return [\n        \"\"\n    ];\n    var parts = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return str.split(\",\");\n    var pre = m.pre;\n    var body = m.body;\n    var post = m.post;\n    var p = pre.split(\",\");\n    p[p.length - 1] += \"{\" + body + \"}\";\n    var postParts = parseCommaParts(post);\n    if (post.length) {\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nfunction expandTop(str) {\n    if (!str) return [];\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.substr(0, 2) === \"{}\") {\n        str = \"\\\\{\\\\}\" + str.substr(2);\n    }\n    return expand(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return \"{\" + str + \"}\";\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand(str, isTop) {\n    var expansions = [];\n    var m = balanced(\"{\", \"}\", str);\n    if (!m) return [\n        str\n    ];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    var pre = m.pre;\n    var post = m.post.length ? expand(m.post, false) : [\n        \"\"\n    ];\n    if (/\\$$/.test(m.pre)) {\n        for(var k = 0; k < post.length; k++){\n            var expansion = pre + \"{\" + m.body + \"}\" + post[k];\n            expansions.push(expansion);\n        }\n    } else {\n        var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        var isSequence = isNumericSequence || isAlphaSequence;\n        var isOptions = m.body.indexOf(\",\") >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + \"{\" + m.body + escClose + m.post;\n                return expand(str);\n            }\n            return [\n                str\n            ];\n        }\n        var n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        } else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand(n[0], false).map(embrace);\n                if (n.length === 1) {\n                    return post.map(function(p) {\n                        return m.pre + n[0] + p;\n                    });\n                }\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        var N;\n        if (isSequence) {\n            var x = numeric(n[0]);\n            var y = numeric(n[1]);\n            var width = Math.max(n[0].length, n[1].length);\n            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n            var test = lte;\n            var reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            var pad = n.some(isPadded);\n            N = [];\n            for(var i = x; test(i, y); i += incr){\n                var c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === \"\\\\\") c = \"\";\n                } else {\n                    c = String(i);\n                    if (pad) {\n                        var need = width - c.length;\n                        if (need > 0) {\n                            var z = new Array(need + 1).join(\"0\");\n                            if (i < 0) c = \"-\" + z + c.slice(1);\n                            else c = z + c;\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        } else {\n            N = [];\n            for(var j = 0; j < n.length; j++){\n                N.push.apply(N, expand(n[j], false));\n            }\n        }\n        for(var j = 0; j < N.length; j++){\n            for(var k = 0; k < post.length; k++){\n                var expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) expansions.push(expansion);\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL25vZGVfbW9kdWxlcy9icmFjZS1leHBhbnNpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsV0FBV0MsbUJBQU9BLENBQUM7QUFFdkJDLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsV0FBVyxjQUFVQyxLQUFLQyxNQUFNLEtBQUc7QUFDdkMsSUFBSUMsVUFBVSxhQUFTRixLQUFLQyxNQUFNLEtBQUc7QUFDckMsSUFBSUUsV0FBVyxjQUFVSCxLQUFLQyxNQUFNLEtBQUc7QUFDdkMsSUFBSUcsV0FBVyxjQUFVSixLQUFLQyxNQUFNLEtBQUc7QUFDdkMsSUFBSUksWUFBWSxlQUFXTCxLQUFLQyxNQUFNLEtBQUc7QUFFekMsU0FBU0ssUUFBUUMsR0FBRztJQUNsQixPQUFPQyxTQUFTRCxLQUFLLE9BQU9BLE1BQ3hCQyxTQUFTRCxLQUFLLE1BQ2RBLElBQUlFLFVBQVUsQ0FBQztBQUNyQjtBQUVBLFNBQVNDLGFBQWFILEdBQUc7SUFDdkIsT0FBT0EsSUFBSUksS0FBSyxDQUFDLFFBQVFDLElBQUksQ0FBQ2IsVUFDbkJZLEtBQUssQ0FBQyxPQUFPQyxJQUFJLENBQUNWLFNBQ2xCUyxLQUFLLENBQUMsT0FBT0MsSUFBSSxDQUFDVCxVQUNsQlEsS0FBSyxDQUFDLE9BQU9DLElBQUksQ0FBQ1IsVUFDbEJPLEtBQUssQ0FBQyxPQUFPQyxJQUFJLENBQUNQO0FBQy9CO0FBRUEsU0FBU1EsZUFBZU4sR0FBRztJQUN6QixPQUFPQSxJQUFJSSxLQUFLLENBQUNaLFVBQVVhLElBQUksQ0FBQyxNQUNyQkQsS0FBSyxDQUFDVCxTQUFTVSxJQUFJLENBQUMsS0FDcEJELEtBQUssQ0FBQ1IsVUFBVVMsSUFBSSxDQUFDLEtBQ3JCRCxLQUFLLENBQUNQLFVBQVVRLElBQUksQ0FBQyxLQUNyQkQsS0FBSyxDQUFDTixXQUFXTyxJQUFJLENBQUM7QUFDbkM7QUFHQSxvREFBb0Q7QUFDcEQsd0RBQXdEO0FBQ3hE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Q0FBQ2dCO1lBQ3BCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9GO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL3JlYWRkaXItZ2xvYi9ub2RlX21vZHVsZXMvYnJhY2UtZXhwYW5zaW9uL2luZGV4LmpzPzFmYzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhbGFuY2VkID0gcmVxdWlyZSgnYmFsYW5jZWQtbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBhbmRUb3A7XG5cbnZhciBlc2NTbGFzaCA9ICdcXDBTTEFTSCcrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NPcGVuID0gJ1xcME9QRU4nK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ2xvc2UgPSAnXFwwQ0xPU0UnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ29tbWEgPSAnXFwwQ09NTUEnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjUGVyaW9kID0gJ1xcMFBFUklPRCcrTWF0aC5yYW5kb20oKSsnXFwwJztcblxuZnVuY3Rpb24gbnVtZXJpYyhzdHIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApID09IHN0clxuICAgID8gcGFyc2VJbnQoc3RyLCAxMClcbiAgICA6IHN0ci5jaGFyQ29kZUF0KDApO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcXFxcXFxcJykuam9pbihlc2NTbGFzaClcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXHsnKS5qb2luKGVzY09wZW4pXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx9Jykuam9pbihlc2NDbG9zZSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXCwnKS5qb2luKGVzY0NvbW1hKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLicpLmpvaW4oZXNjUGVyaW9kKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoZXNjU2xhc2gpLmpvaW4oJ1xcXFwnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY09wZW4pLmpvaW4oJ3snKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0Nsb3NlKS5qb2luKCd9JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDb21tYSkuam9pbignLCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjUGVyaW9kKS5qb2luKCcuJyk7XG59XG5cblxuLy8gQmFzaWNhbGx5IGp1c3Qgc3RyLnNwbGl0KFwiLFwiKSwgYnV0IGhhbmRsaW5nIGNhc2VzXG4vLyB3aGVyZSB3ZSBoYXZlIG5lc3RlZCBicmFjZWQgc2VjdGlvbnMsIHdoaWNoIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBhcyBpbmRpdmlkdWFsIG1lbWJlcnMsIGxpa2Uge2Ese2IsY30sZH1cbmZ1bmN0aW9uIHBhcnNlQ29tbWFQYXJ0cyhzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFsnJ107XG5cbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG5cbiAgaWYgKCFtKVxuICAgIHJldHVybiBzdHIuc3BsaXQoJywnKTtcblxuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBib2R5ID0gbS5ib2R5O1xuICB2YXIgcG9zdCA9IG0ucG9zdDtcbiAgdmFyIHAgPSBwcmUuc3BsaXQoJywnKTtcblxuICBwW3AubGVuZ3RoLTFdICs9ICd7JyArIGJvZHkgKyAnfSc7XG4gIHZhciBwb3N0UGFydHMgPSBwYXJzZUNvbW1hUGFydHMocG9zdCk7XG4gIGlmIChwb3N0Lmxlbmd0aCkge1xuICAgIHBbcC5sZW5ndGgtMV0gKz0gcG9zdFBhcnRzLnNoaWZ0KCk7XG4gICAgcC5wdXNoLmFwcGx5KHAsIHBvc3RQYXJ0cyk7XG4gIH1cblxuICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwKTtcblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvcChzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIC8vIEkgZG9uJ3Qga25vdyB3aHkgQmFzaCA0LjMgZG9lcyB0aGlzLCBidXQgaXQgZG9lcy5cbiAgLy8gQW55dGhpbmcgc3RhcnRpbmcgd2l0aCB7fSB3aWxsIGhhdmUgdGhlIGZpcnN0IHR3byBieXRlcyBwcmVzZXJ2ZWRcbiAgLy8gYnV0ICpvbmx5KiBhdCB0aGUgdG9wIGxldmVsLCBzbyB7fSxhfWIgd2lsbCBub3QgZXhwYW5kIHRvIGFueXRoaW5nLFxuICAvLyBidXQgYXt9LGJ9YyB3aWxsIGJlIGV4cGFuZGVkIHRvIFthfWMsYWJjXS5cbiAgLy8gT25lIGNvdWxkIGFyZ3VlIHRoYXQgdGhpcyBpcyBhIGJ1ZyBpbiBCYXNoLCBidXQgc2luY2UgdGhlIGdvYWwgb2ZcbiAgLy8gdGhpcyBtb2R1bGUgaXMgdG8gbWF0Y2ggQmFzaCdzIHJ1bGVzLCB3ZSBlc2NhcGUgYSBsZWFkaW5nIHt9XG4gIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAne30nKSB7XG4gICAgc3RyID0gJ1xcXFx7XFxcXH0nICsgc3RyLnN1YnN0cigyKTtcbiAgfVxuXG4gIHJldHVybiBleHBhbmQoZXNjYXBlQnJhY2VzKHN0ciksIHRydWUpLm1hcCh1bmVzY2FwZUJyYWNlcyk7XG59XG5cbmZ1bmN0aW9uIGVtYnJhY2Uoc3RyKSB7XG4gIHJldHVybiAneycgKyBzdHIgKyAnfSc7XG59XG5mdW5jdGlvbiBpc1BhZGRlZChlbCkge1xuICByZXR1cm4gL14tPzBcXGQvLnRlc3QoZWwpO1xufVxuXG5mdW5jdGlvbiBsdGUoaSwgeSkge1xuICByZXR1cm4gaSA8PSB5O1xufVxuZnVuY3Rpb24gZ3RlKGksIHkpIHtcbiAgcmV0dXJuIGkgPj0geTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHN0ciwgaXNUb3ApIHtcbiAgdmFyIGV4cGFuc2lvbnMgPSBbXTtcblxuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuICBpZiAoIW0pIHJldHVybiBbc3RyXTtcblxuICAvLyBubyBuZWVkIHRvIGV4cGFuZCBwcmUsIHNpbmNlIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgZnJlZSBvZiBicmFjZS1zZXRzXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIHBvc3QgPSBtLnBvc3QubGVuZ3RoXG4gICAgPyBleHBhbmQobS5wb3N0LCBmYWxzZSlcbiAgICA6IFsnJ107XG5cbiAgaWYgKC9cXCQkLy50ZXN0KG0ucHJlKSkgeyAgICBcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBleHBhbnNpb24gPSBwcmUrICd7JyArIG0uYm9keSArICd9JyArIHBvc3Rba107XG4gICAgICBleHBhbnNpb25zLnB1c2goZXhwYW5zaW9uKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlzTnVtZXJpY1NlcXVlbmNlID0gL14tP1xcZCtcXC5cXC4tP1xcZCsoPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgICB2YXIgaXNBbHBoYVNlcXVlbmNlID0gL15bYS16QS1aXVxcLlxcLlthLXpBLVpdKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gICAgdmFyIGlzU2VxdWVuY2UgPSBpc051bWVyaWNTZXF1ZW5jZSB8fCBpc0FscGhhU2VxdWVuY2U7XG4gICAgdmFyIGlzT3B0aW9ucyA9IG0uYm9keS5pbmRleE9mKCcsJykgPj0gMDtcbiAgICBpZiAoIWlzU2VxdWVuY2UgJiYgIWlzT3B0aW9ucykge1xuICAgICAgLy8ge2F9LGJ9XG4gICAgICBpZiAobS5wb3N0Lm1hdGNoKC8sKD8hLCkuKlxcfS8pKSB7XG4gICAgICAgIHN0ciA9IG0ucHJlICsgJ3snICsgbS5ib2R5ICsgZXNjQ2xvc2UgKyBtLnBvc3Q7XG4gICAgICAgIHJldHVybiBleHBhbmQoc3RyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbc3RyXTtcbiAgICB9XG5cbiAgICB2YXIgbjtcbiAgICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgICAgbiA9IG0uYm9keS5zcGxpdCgvXFwuXFwuLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyB4e3thLGJ9fXkgPT0+IHh7YX15IHh7Yn15XG4gICAgICAgIG4gPSBleHBhbmQoblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHBvc3QubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBtLnByZSArIG5bMF0gKyBwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgbiBpcyB0aGUgcGFydHMsIGFuZCB3ZSBrbm93IGl0J3Mgbm90IGEgY29tbWEgc2V0XG4gICAgLy8gd2l0aCBhIHNpbmdsZSBlbnRyeS5cbiAgICB2YXIgTjtcblxuICAgIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgICB2YXIgeCA9IG51bWVyaWMoblswXSk7XG4gICAgICB2YXIgeSA9IG51bWVyaWMoblsxXSk7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLm1heChuWzBdLmxlbmd0aCwgblsxXS5sZW5ndGgpXG4gICAgICB2YXIgaW5jciA9IG4ubGVuZ3RoID09IDNcbiAgICAgICAgPyBNYXRoLmFicyhudW1lcmljKG5bMl0pKVxuICAgICAgICA6IDE7XG4gICAgICB2YXIgdGVzdCA9IGx0ZTtcbiAgICAgIHZhciByZXZlcnNlID0geSA8IHg7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICBpbmNyICo9IC0xO1xuICAgICAgICB0ZXN0ID0gZ3RlO1xuICAgICAgfVxuICAgICAgdmFyIHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG5cbiAgICAgIE4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IHg7IHRlc3QoaSwgeSk7IGkgKz0gaW5jcikge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgaWYgKGlzQWxwaGFTZXF1ZW5jZSkge1xuICAgICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpXG4gICAgICAgICAgICBjID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYyA9IFN0cmluZyhpKTtcbiAgICAgICAgICBpZiAocGFkKSB7XG4gICAgICAgICAgICB2YXIgbmVlZCA9IHdpZHRoIC0gYy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobmVlZCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHogPSBuZXcgQXJyYXkobmVlZCArIDEpLmpvaW4oJzAnKTtcbiAgICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICAgIGMgPSAnLScgKyB6ICsgYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGMgPSB6ICsgYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTi5wdXNoKGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBOID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbi5sZW5ndGg7IGorKykge1xuICAgICAgICBOLnB1c2guYXBwbHkoTiwgZXhwYW5kKG5bal0sIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBOLmxlbmd0aDsgaisrKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSArIE5bal0gKyBwb3N0W2tdO1xuICAgICAgICBpZiAoIWlzVG9wIHx8IGlzU2VxdWVuY2UgfHwgZXhwYW5zaW9uKVxuICAgICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBhbnNpb25zO1xufVxuXG4iXSwibmFtZXMiOlsiYmFsYW5jZWQiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImV4cGFuZFRvcCIsImVzY1NsYXNoIiwiTWF0aCIsInJhbmRvbSIsImVzY09wZW4iLCJlc2NDbG9zZSIsImVzY0NvbW1hIiwiZXNjUGVyaW9kIiwibnVtZXJpYyIsInN0ciIsInBhcnNlSW50IiwiY2hhckNvZGVBdCIsImVzY2FwZUJyYWNlcyIsInNwbGl0Iiwiam9pbiIsInVuZXNjYXBlQnJhY2VzIiwicGFyc2VDb21tYVBhcnRzIiwicGFydHMiLCJtIiwicHJlIiwiYm9keSIsInBvc3QiLCJwIiwibGVuZ3RoIiwicG9zdFBhcnRzIiwic2hpZnQiLCJwdXNoIiwiYXBwbHkiLCJzdWJzdHIiLCJleHBhbmQiLCJtYXAiLCJlbWJyYWNlIiwiaXNQYWRkZWQiLCJlbCIsInRlc3QiLCJsdGUiLCJpIiwieSIsImd0ZSIsImlzVG9wIiwiZXhwYW5zaW9ucyIsImsiLCJleHBhbnNpb24iLCJpc051bWVyaWNTZXF1ZW5jZSIsImlzQWxwaGFTZXF1ZW5jZSIsImlzU2VxdWVuY2UiLCJpc09wdGlvbnMiLCJpbmRleE9mIiwibWF0Y2giLCJuIiwiTiIsIngiLCJ3aWR0aCIsIm1heCIsImluY3IiLCJhYnMiLCJyZXZlcnNlIiwicGFkIiwic29tZSIsImMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJuZWVkIiwieiIsIkFycmF5Iiwic2xpY2UiLCJqIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readdir-glob/node_modules/brace-expansion/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readdir-glob/node_modules/minimatch/lib/path.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readdir-glob/node_modules/minimatch/lib/path.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("const isWindows = typeof process === \"object\" && process && process.platform === \"win32\";\nmodule.exports = isWindows ? {\n    sep: \"\\\\\"\n} : {\n    sep: \"/\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL3JlYWRkaXItZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2xpYi9wYXRoLmpzP2Y0ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNXaW5kb3dzID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHByb2Nlc3MgJiZcbiAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xubW9kdWxlLmV4cG9ydHMgPSBpc1dpbmRvd3MgPyB7IHNlcDogJ1xcXFwnIH0gOiB7IHNlcDogJy8nIH1cbiJdLCJuYW1lcyI6WyJpc1dpbmRvd3MiLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJtb2R1bGUiLCJleHBvcnRzIiwic2VwIl0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxZQUFZLE9BQU9DLFlBQVksWUFDbkNBLFdBQ0FBLFFBQVFDLFFBQVEsS0FBSztBQUN2QkMsT0FBT0MsT0FBTyxHQUFHSixZQUFZO0lBQUVLLEtBQUs7QUFBSyxJQUFJO0lBQUVBLEtBQUs7QUFBSSIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9yZWFkZGlyLWdsb2Ivbm9kZV9tb2R1bGVzL21pbmltYXRjaC9saWIvcGF0aC5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readdir-glob/node_modules/minimatch/lib/path.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readdir-glob/node_modules/minimatch/minimatch.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readdir-glob/node_modules/minimatch/minimatch.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const minimatch = module.exports = (p, pattern, options = {})=>{\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nmodule.exports = minimatch;\nconst path = __webpack_require__(/*! ./lib/path.js */ \"(rsc)/./node_modules/readdir-glob/node_modules/minimatch/lib/path.js\");\nminimatch.sep = path.sep;\nconst GLOBSTAR = Symbol(\"globstar **\");\nminimatch.GLOBSTAR = GLOBSTAR;\nconst expand = __webpack_require__(/*! brace-expansion */ \"(rsc)/./node_modules/readdir-glob/node_modules/brace-expansion/index.js\");\nconst plTypes = {\n    \"!\": {\n        open: \"(?:(?!(?:\",\n        close: \"))[^/]*?)\"\n    },\n    \"?\": {\n        open: \"(?:\",\n        close: \")?\"\n    },\n    \"+\": {\n        open: \"(?:\",\n        close: \")+\"\n    },\n    \"*\": {\n        open: \"(?:\",\n        close: \")*\"\n    },\n    \"@\": {\n        open: \"(?:\",\n        close: \")\"\n    }\n};\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = \"[^/]\";\n// * => any number of characters\nconst star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = (s)=>s.split(\"\").reduce((set, c)=>{\n        set[c] = true;\n        return set;\n    }, {});\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet(\"[.(\");\n// normalizes slashes.\nconst slashSplit = /\\/+/;\nminimatch.filter = (pattern, options = {})=>(p, i, list)=>minimatch(p, pattern, options);\nconst ext = (a, b = {})=>{\n    const t = {};\n    Object.keys(a).forEach((k)=>t[k] = a[k]);\n    Object.keys(b).forEach((k)=>t[k] = b[k]);\n    return t;\n};\nminimatch.defaults = (def)=>{\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options)=>orig(p, pattern, ext(def, options));\n    m.Minimatch = class Minimatch extends orig.Minimatch {\n        constructor(pattern, options){\n            super(pattern, ext(def, options));\n        }\n    };\n    m.Minimatch.defaults = (options)=>orig.defaults(ext(def, options)).Minimatch;\n    m.filter = (pattern, options)=>orig.filter(pattern, ext(def, options));\n    m.defaults = (options)=>orig.defaults(ext(def, options));\n    m.makeRe = (pattern, options)=>orig.makeRe(pattern, ext(def, options));\n    m.braceExpand = (pattern, options)=>orig.braceExpand(pattern, ext(def, options));\n    m.match = (list, pattern, options)=>orig.match(list, pattern, ext(def, options));\n    return m;\n};\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = (pattern, options)=>braceExpand(pattern, options);\nconst braceExpand = (pattern, options = {})=>{\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return expand(pattern);\n};\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern)=>{\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n};\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst SUBPARSE = Symbol(\"subparse\");\nminimatch.makeRe = (pattern, options)=>new Minimatch(pattern, options || {}).makeRe();\nminimatch.match = (list, pattern, options = {})=>{\n    const mm = new Minimatch(pattern, options);\n    list = list.filter((f)=>mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\n// replace stuff like \\* with *\nconst globUnescape = (s)=>s.replace(/\\\\(.)/g, \"$1\");\nconst charUnescape = (s)=>s.replace(/\\\\([^-\\]])/g, \"$1\");\nconst regExpEscape = (s)=>s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\nconst braExpEscape = (s)=>s.replace(/[[\\]\\\\]/g, \"\\\\$&\");\nclass Minimatch {\n    constructor(pattern, options){\n        assertValidPattern(pattern);\n        if (!options) options = {};\n        this.options = options;\n        this.set = [];\n        this.pattern = pattern;\n        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, \"/\");\n        }\n        this.regexp = null;\n        this.negate = false;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        // make the set of regexps etc.\n        this.make();\n    }\n    debug() {}\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === \"#\") {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        let set = this.globSet = this.braceExpand();\n        if (options.debug) this.debug = (...args)=>console.error(...args);\n        this.debug(this.pattern, set);\n        // step 3: now we have a set, so turn each one into a series of path-portion\n        // matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        set = this.globParts = set.map((s)=>s.split(slashSplit));\n        this.debug(this.pattern, set);\n        // glob --> regexps\n        set = set.map((s, si, set)=>s.map(this.parse, this));\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        set = set.filter((s)=>s.indexOf(false) === -1);\n        this.debug(this.pattern, set);\n        this.set = set;\n    }\n    parseNegate() {\n        if (this.options.nonegate) return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for(let i = 0; i < pattern.length && pattern.charAt(i) === \"!\"; i++){\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset) this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial) {\n        var options = this.options;\n        this.debug(\"matchOne\", {\n            \"this\": this,\n            file: file,\n            pattern: pattern\n        });\n        this.debug(\"matchOne\", file.length, pattern.length);\n        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n            this.debug(\"matchOne loop\");\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* istanbul ignore if */ if (p === false) return false;\n            if (p === GLOBSTAR) {\n                this.debug(\"GLOBSTAR\", [\n                    pattern,\n                    p,\n                    f\n                ]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug(\"** at the end\");\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for(; fi < fl; fi++){\n                        if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while(fr < fl){\n                    var swallowee = file[fr];\n                    this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug(\"globstar found match!\", fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    } else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                            this.debug(\"dot detected!\", file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug(\"globstar swallow a segment, and continue\");\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                // If there's more *pattern* left, then\n                /* istanbul ignore if */ if (partial) {\n                    // ran out of file\n                    this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                    if (fr === fl) return true;\n                }\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            var hit;\n            if (typeof p === \"string\") {\n                hit = f === p;\n                this.debug(\"string match\", p, f, hit);\n            } else {\n                hit = f.match(p);\n                this.debug(\"pattern match\", p, f, hit);\n            }\n            if (!hit) return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        } else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        } else /* istanbul ignore else */ if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === \"\";\n        }\n        // should be unreachable.\n        /* istanbul ignore next */ throw new Error(\"wtf?\");\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern, isSub) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === \"**\") {\n            if (!options.noglobstar) return GLOBSTAR;\n            else pattern = \"*\";\n        }\n        if (pattern === \"\") return \"\";\n        let re = \"\";\n        let hasMagic = false;\n        let escaping = false;\n        // ? => one single character\n        const patternListStack = [];\n        const negativeLists = [];\n        let stateChar;\n        let inClass = false;\n        let reClassStart = -1;\n        let classStart = -1;\n        let cs;\n        let pl;\n        let sp;\n        // . and .. never match anything that doesn't start with .,\n        // even when options.dot is set.  However, if the pattern\n        // starts with ., then traversal patterns can match.\n        let dotTravAllowed = pattern.charAt(0) === \".\";\n        let dotFileAllowed = options.dot || dotTravAllowed;\n        const patternStart = ()=>dotTravAllowed ? \"\" : dotFileAllowed ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n        const subPatternStart = (p)=>p.charAt(0) === \".\" ? \"\" : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n        const clearStateChar = ()=>{\n            if (stateChar) {\n                // we had some state-tracking character\n                // that wasn't consumed by this pass.\n                switch(stateChar){\n                    case \"*\":\n                        re += star;\n                        hasMagic = true;\n                        break;\n                    case \"?\":\n                        re += qmark;\n                        hasMagic = true;\n                        break;\n                    default:\n                        re += \"\\\\\" + stateChar;\n                        break;\n                }\n                this.debug(\"clearStateChar %j %j\", stateChar, re);\n                stateChar = false;\n            }\n        };\n        for(let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++){\n            this.debug(\"%s\t%s %s %j\", pattern, i, re, c);\n            // skip over any that are escaped.\n            if (escaping) {\n                /* istanbul ignore next - completely not allowed, even escaped. */ if (c === \"/\") {\n                    return false;\n                }\n                if (reSpecials[c]) {\n                    re += \"\\\\\";\n                }\n                re += c;\n                escaping = false;\n                continue;\n            }\n            switch(c){\n                /* istanbul ignore next */ case \"/\":\n                    {\n                        // Should already be path-split by now.\n                        return false;\n                    }\n                case \"\\\\\":\n                    if (inClass && pattern.charAt(i + 1) === \"-\") {\n                        re += c;\n                        continue;\n                    }\n                    clearStateChar();\n                    escaping = true;\n                    continue;\n                // the various stateChar values\n                // for the \"extglob\" stuff.\n                case \"?\":\n                case \"*\":\n                case \"+\":\n                case \"@\":\n                case \"!\":\n                    this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);\n                    // all of those are literals inside a class, except that\n                    // the glob [!a] means [^a] in regexp\n                    if (inClass) {\n                        this.debug(\"  in class\");\n                        if (c === \"!\" && i === classStart + 1) c = \"^\";\n                        re += c;\n                        continue;\n                    }\n                    // if we already have a stateChar, then it means\n                    // that there was something like ** or +? in there.\n                    // Handle the stateChar, then proceed with this one.\n                    this.debug(\"call clearStateChar %j\", stateChar);\n                    clearStateChar();\n                    stateChar = c;\n                    // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                    // just clear the statechar *now*, rather than even diving into\n                    // the patternList stuff.\n                    if (options.noext) clearStateChar();\n                    continue;\n                case \"(\":\n                    {\n                        if (inClass) {\n                            re += \"(\";\n                            continue;\n                        }\n                        if (!stateChar) {\n                            re += \"\\\\(\";\n                            continue;\n                        }\n                        const plEntry = {\n                            type: stateChar,\n                            start: i - 1,\n                            reStart: re.length,\n                            open: plTypes[stateChar].open,\n                            close: plTypes[stateChar].close\n                        };\n                        this.debug(this.pattern, \"\t\", plEntry);\n                        patternListStack.push(plEntry);\n                        // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n                        re += plEntry.open;\n                        // next entry starts with a dot maybe?\n                        if (plEntry.start === 0 && plEntry.type !== \"!\") {\n                            dotTravAllowed = true;\n                            re += subPatternStart(pattern.slice(i + 1));\n                        }\n                        this.debug(\"plType %j %j\", stateChar, re);\n                        stateChar = false;\n                        continue;\n                    }\n                case \")\":\n                    {\n                        const plEntry = patternListStack[patternListStack.length - 1];\n                        if (inClass || !plEntry) {\n                            re += \"\\\\)\";\n                            continue;\n                        }\n                        patternListStack.pop();\n                        // closing an extglob\n                        clearStateChar();\n                        hasMagic = true;\n                        pl = plEntry;\n                        // negation is (?:(?!js)[^/]*)\n                        // The others are (?:<pattern>)<type>\n                        re += pl.close;\n                        if (pl.type === \"!\") {\n                            negativeLists.push(Object.assign(pl, {\n                                reEnd: re.length\n                            }));\n                        }\n                        continue;\n                    }\n                case \"|\":\n                    {\n                        const plEntry = patternListStack[patternListStack.length - 1];\n                        if (inClass || !plEntry) {\n                            re += \"\\\\|\";\n                            continue;\n                        }\n                        clearStateChar();\n                        re += \"|\";\n                        // next subpattern can start with a dot?\n                        if (plEntry.start === 0 && plEntry.type !== \"!\") {\n                            dotTravAllowed = true;\n                            re += subPatternStart(pattern.slice(i + 1));\n                        }\n                        continue;\n                    }\n                // these are mostly the same in regexp and glob\n                case \"[\":\n                    // swallow any state-tracking char before the [\n                    clearStateChar();\n                    if (inClass) {\n                        re += \"\\\\\" + c;\n                        continue;\n                    }\n                    inClass = true;\n                    classStart = i;\n                    reClassStart = re.length;\n                    re += c;\n                    continue;\n                case \"]\":\n                    //  a right bracket shall lose its special\n                    //  meaning and represent itself in\n                    //  a bracket expression if it occurs\n                    //  first in the list.  -- POSIX.2 2.8.3.2\n                    if (i === classStart + 1 || !inClass) {\n                        re += \"\\\\\" + c;\n                        continue;\n                    }\n                    // split where the last [ was, make sure we don't have\n                    // an invalid re. if so, re-walk the contents of the\n                    // would-be class to re-translate any characters that\n                    // were passed through as-is\n                    // TODO: It would probably be faster to determine this\n                    // without a try/catch and a new RegExp, but it's tricky\n                    // to do safely.  For now, this is safe and works.\n                    cs = pattern.substring(classStart + 1, i);\n                    try {\n                        RegExp(\"[\" + braExpEscape(charUnescape(cs)) + \"]\");\n                        // looks good, finish up the class.\n                        re += c;\n                    } catch (er) {\n                        // out of order ranges in JS are errors, but in glob syntax,\n                        // they're just a range that matches nothing.\n                        re = re.substring(0, reClassStart) + \"(?:$.)\" // match nothing ever\n                        ;\n                    }\n                    hasMagic = true;\n                    inClass = false;\n                    continue;\n                default:\n                    // swallow any state char that wasn't consumed\n                    clearStateChar();\n                    if (reSpecials[c] && !(c === \"^\" && inClass)) {\n                        re += \"\\\\\";\n                    }\n                    re += c;\n                    break;\n            } // switch\n        } // for\n        // handle the case where we left a class open.\n        // \"[abc\" is valid, equivalent to \"\\[abc\"\n        if (inClass) {\n            // split where the last [ was, and escape it\n            // this is a huge pita.  We now have to re-walk\n            // the contents of the would-be class to re-translate\n            // any characters that were passed through as-is\n            cs = pattern.slice(classStart + 1);\n            sp = this.parse(cs, SUBPARSE);\n            re = re.substring(0, reClassStart) + \"\\\\[\" + sp[0];\n            hasMagic = hasMagic || sp[1];\n        }\n        // handle the case where we had a +( thing at the *end*\n        // of the pattern.\n        // each pattern list stack adds 3 chars, and we need to go through\n        // and escape any | chars that were passed through as-is for the regexp.\n        // Go through and escape them, taking care not to double-escape any\n        // | chars that were already escaped.\n        for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){\n            let tail;\n            tail = re.slice(pl.reStart + pl.open.length);\n            this.debug(\"setting tail\", re, pl);\n            // maybe some even number of \\, then maybe 1 \\, followed by a |\n            tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2)=>{\n                /* istanbul ignore else - should already be done */ if (!$2) {\n                    // the | isn't already escaped, so escape it.\n                    $2 = \"\\\\\";\n                }\n                // need to escape all those slashes *again*, without escaping the\n                // one that we need for escaping the | character.  As it works out,\n                // escaping an even number of slashes can be done by simply repeating\n                // it exactly after itself.  That's why this trick works.\n                //\n                // I am sorry that you have to see this.\n                return $1 + $1 + $2 + \"|\";\n            });\n            this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);\n            const t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n            hasMagic = true;\n            re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n        }\n        // handle trailing things that only matter at the very end.\n        clearStateChar();\n        if (escaping) {\n            // trailing \\\\\n            re += \"\\\\\\\\\";\n        }\n        // only need to apply the nodot start if the re starts with\n        // something that could conceivably capture a dot\n        const addPatternStart = addPatternStartSet[re.charAt(0)];\n        // Hack to work around lack of negative lookbehind in JS\n        // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n        // like 'a.xyz.yz' doesn't match.  So, the first negative\n        // lookahead, has to look ALL the way ahead, to the end of\n        // the pattern.\n        for(let n = negativeLists.length - 1; n > -1; n--){\n            const nl = negativeLists[n];\n            const nlBefore = re.slice(0, nl.reStart);\n            const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n            let nlAfter = re.slice(nl.reEnd);\n            const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;\n            // Handle nested stuff like *(*.js|!(*.json)), where open parens\n            // mean that we should *not* include the ) in the bit that is considered\n            // \"after\" the negated section.\n            const closeParensBefore = nlBefore.split(\")\").length;\n            const openParensBefore = nlBefore.split(\"(\").length - closeParensBefore;\n            let cleanAfter = nlAfter;\n            for(let i = 0; i < openParensBefore; i++){\n                cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");\n            }\n            nlAfter = cleanAfter;\n            const dollar = nlAfter === \"\" && isSub !== SUBPARSE ? \"(?:$|\\\\/)\" : \"\";\n            re = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n        }\n        // if the re is not \"\" at this point, then we need to make sure\n        // it doesn't match against an empty path part.\n        // Otherwise a/* will match a/, which it should not.\n        if (re !== \"\" && hasMagic) {\n            re = \"(?=.)\" + re;\n        }\n        if (addPatternStart) {\n            re = patternStart() + re;\n        }\n        // parsing just a piece of a larger pattern.\n        if (isSub === SUBPARSE) {\n            return [\n                re,\n                hasMagic\n            ];\n        }\n        // if it's nocase, and the lcase/uppercase don't match, it's magic\n        if (options.nocase && !hasMagic) {\n            hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();\n        }\n        // skip the regexp for non-magical patterns\n        // unescape anything in it, though, so that it'll be\n        // an exact match against a file etc.\n        if (!hasMagic) {\n            return globUnescape(pattern);\n        }\n        const flags = options.nocase ? \"i\" : \"\";\n        try {\n            return Object.assign(new RegExp(\"^\" + re + \"$\", flags), {\n                _glob: pattern,\n                _src: re\n            });\n        } catch (er) /* istanbul ignore next - should be impossible */ {\n            // If it was an invalid regular expression, then it can't match\n            // anything.  This trick looks for a character after the end of\n            // the string, which is of course impossible, except in multi-line\n            // mode, but it's not a /m regex.\n            return new RegExp(\"$.\");\n        }\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false) return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n        const flags = options.nocase ? \"i\" : \"\";\n        // coalesce globstars and regexpify non-globstar patterns\n        // if it's the only item, then we just do one twoStar\n        // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if it's the last, append (\\/twoStar|) to previous\n        // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set.map((pattern)=>{\n            pattern = pattern.map((p)=>typeof p === \"string\" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p)=>{\n                if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n                    set.push(p);\n                }\n                return set;\n            }, []);\n            pattern.forEach((p, i)=>{\n                if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {\n                    return;\n                }\n                if (i === 0) {\n                    if (pattern.length > 1) {\n                        pattern[i + 1] = \"(?:\\\\/|\" + twoStar + \"\\\\/)?\" + pattern[i + 1];\n                    } else {\n                        pattern[i] = twoStar;\n                    }\n                } else if (i === pattern.length - 1) {\n                    pattern[i - 1] += \"(?:\\\\/|\" + twoStar + \")?\";\n                } else {\n                    pattern[i - 1] += \"(?:\\\\/|\\\\/\" + twoStar + \"\\\\/)\" + pattern[i + 1];\n                    pattern[i + 1] = GLOBSTAR;\n                }\n            });\n            return pattern.filter((p)=>p !== GLOBSTAR).join(\"/\");\n        }).join(\"|\");\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = \"^(?:\" + re + \")$\";\n        // can match anything, as long as it's not this.\n        if (this.negate) re = \"^(?!\" + re + \").*$\";\n        try {\n            this.regexp = new RegExp(re, flags);\n        } catch (ex) /* istanbul ignore next - should be impossible */ {\n            this.regexp = false;\n        }\n        return this.regexp;\n    }\n    match(f, partial = this.partial) {\n        this.debug(\"match\", f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) return false;\n        if (this.empty) return f === \"\";\n        if (f === \"/\" && partial) return true;\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (path.sep !== \"/\") {\n            f = f.split(path.sep).join(\"/\");\n        }\n        // treat the test path as a set of pathparts.\n        f = f.split(slashSplit);\n        this.debug(this.pattern, \"split\", f);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, \"set\", set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename;\n        for(let i = f.length - 1; i >= 0; i--){\n            filename = f[i];\n            if (filename) break;\n        }\n        for(let i = 0; i < set.length; i++){\n            const pattern = set[i];\n            let file = f;\n            if (options.matchBase && pattern.length === 1) {\n                file = [\n                    filename\n                ];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) return true;\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) return false;\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\nminimatch.Minimatch = Minimatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGRpci1nbG9iL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbWluaW1hdGNoLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU1BLFlBQVlDLE9BQU9DLE9BQU8sR0FBRyxDQUFDQyxHQUFHQyxTQUFTQyxVQUFVLENBQUMsQ0FBQztJQUMxREMsbUJBQW1CRjtJQUVuQixvQ0FBb0M7SUFDcEMsSUFBSSxDQUFDQyxRQUFRRSxTQUFTLElBQUlILFFBQVFJLE1BQU0sQ0FBQyxPQUFPLEtBQUs7UUFDbkQsT0FBTztJQUNUO0lBRUEsT0FBTyxJQUFJQyxVQUFVTCxTQUFTQyxTQUFTSyxLQUFLLENBQUNQO0FBQy9DO0FBRUFGLE9BQU9DLE9BQU8sR0FBR0Y7QUFFakIsTUFBTVcsT0FBT0MsbUJBQU9BLENBQUM7QUFDckJaLFVBQVVhLEdBQUcsR0FBR0YsS0FBS0UsR0FBRztBQUV4QixNQUFNQyxXQUFXQyxPQUFPO0FBQ3hCZixVQUFVYyxRQUFRLEdBQUdBO0FBQ3JCLE1BQU1FLFNBQVNKLG1CQUFPQSxDQUFDO0FBRXZCLE1BQU1LLFVBQVU7SUFDZCxLQUFLO1FBQUVDLE1BQU07UUFBYUMsT0FBTztJQUFXO0lBQzVDLEtBQUs7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQUs7SUFDaEMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSztJQUNoQyxLQUFLO1FBQUVELE1BQU07UUFBT0MsT0FBTztJQUFLO0lBQ2hDLEtBQUs7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQUk7QUFDakM7QUFFQSxnQ0FBZ0M7QUFDaEMsaURBQWlEO0FBQ2pELE1BQU1DLFFBQVE7QUFFZCxnQ0FBZ0M7QUFDaEMsTUFBTUMsT0FBT0QsUUFBUTtBQUVyQiw0REFBNEQ7QUFDNUQsK0RBQStEO0FBQy9ELDZDQUE2QztBQUM3QyxNQUFNRSxhQUFhO0FBRW5CLGtDQUFrQztBQUNsQyw2Q0FBNkM7QUFDN0MsTUFBTUMsZUFBZTtBQUVyQixzQ0FBc0M7QUFDdEMsTUFB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QUFLLEdBQUc7Z0JBQzdDMkMsT0FBTztvQkFBQ2dFO2lCQUFTO1lBQ25CO1lBQ0EsTUFBTXZELE1BQU0sSUFBSSxDQUFDVixRQUFRLENBQUNDLE1BQU1yRixTQUFTb0U7WUFDekMsSUFBSTBCLEtBQUs7Z0JBQ1AsSUFBSTdGLFFBQVFzSixVQUFVLEVBQUUsT0FBTztnQkFDL0IsT0FBTyxDQUFDLElBQUksQ0FBQ3RGLE1BQU07WUFDckI7UUFDRjtRQUVBLDJEQUEyRDtRQUMzRCw4QkFBOEI7UUFDOUIsSUFBSWhFLFFBQVFzSixVQUFVLEVBQUUsT0FBTztRQUMvQixPQUFPLElBQUksQ0FBQ3RGLE1BQU07SUFDcEI7SUFFQSxPQUFPekIsU0FBVUMsR0FBRyxFQUFFO1FBQ3BCLE9BQU83QyxVQUFVNEMsUUFBUSxDQUFDQyxLQUFLcEMsU0FBUztJQUMxQztBQUNGO0FBRUFULFVBQVVTLFNBQVMsR0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waG90by1za3UtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL3JlYWRkaXItZ2xvYi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcz9iMDYxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG1pbmltYXRjaCA9IG1vZHVsZS5leHBvcnRzID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbmltYXRjaFxuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgnLi9saWIvcGF0aC5qcycpXG5taW5pbWF0Y2guc2VwID0gcGF0aC5zZXBcblxuY29uc3QgR0xPQlNUQVIgPSBTeW1ib2woJ2dsb2JzdGFyICoqJylcbm1pbmltYXRjaC5HTE9CU1RBUiA9IEdMT0JTVEFSXG5jb25zdCBleHBhbmQgPSByZXF1aXJlKCdicmFjZS1leHBhbnNpb24nKVxuXG5jb25zdCBwbFR5cGVzID0ge1xuICAnISc6IHsgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiAnKSlbXi9dKj8pJ30sXG4gICc/JzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgJysnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAnKic6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICdAJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG59XG5cbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG5jb25zdCBxbWFyayA9ICdbXi9dJ1xuXG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/J1xuXG4vLyAqKiB3aGVuIGRvdHMgYXJlIGFsbG93ZWQuICBBbnl0aGluZyBnb2VzLCBleGNlcHQgLi4gYW5kIC5cbi8vIG5vdCAoXiBvciAvIGZvbGxvd2VkIGJ5IG9uZSBvciB0d28gZG90cyBmb2xsb3dlZCBieSAkIG9yIC8pLFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFxcXC8pKS4pKj8nXG5cbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XilcXFxcLikuKSo/J1xuXG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5jb25zdCBjaGFyU2V0ID0gcyA9PiBzLnNwbGl0KCcnKS5yZWR1Y2UoKHNldCwgYykgPT4ge1xuICBzZXRbY10gPSB0cnVlXG4gIHJldHVybiBzZXRcbn0sIHt9KVxuXG4vLyBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGluIFJlZ0V4cC5cbmNvbnN0IHJlU3BlY2lhbHMgPSBjaGFyU2V0KCcoKS4qe30rP1tdXiRcXFxcIScpXG5cbi8vIGNoYXJhY3RlcnMgdGhhdCBpbmRpY2F0ZSB3ZSBoYXZlIHRvIGFkZCB0aGUgcGF0dGVybiBzdGFydFxuY29uc3QgYWRkUGF0dGVyblN0YXJ0U2V0ID0gY2hhclNldCgnWy4oJylcblxuLy8gbm9ybWFsaXplcyBzbGFzaGVzLlxuY29uc3Qgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT5cbiAgKHAsIGksIGxpc3QpID0+IG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuXG5jb25zdCBleHQgPSAoYSwgYiA9IHt9KSA9PiB7XG4gIGNvbnN0IHQgPSB7fVxuICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGsgPT4gdFtrXSA9IGFba10pXG4gIE9iamVjdC5rZXlzKGIpLmZvckVhY2goayA9PiB0W2tdID0gYltrXSlcbiAgcmV0dXJuIHRcbn1cblxubWluaW1hdGNoLmRlZmF1bHRzID0gZGVmID0+IHtcbiAgaWYgKCFkZWYgfHwgdHlwZW9mIGRlZiAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaFxuICB9XG5cbiAgY29uc3Qgb3JpZyA9IG1pbmltYXRjaFxuXG4gIGNvbnN0IG0gPSAocCwgcGF0dGVybiwgb3B0aW9ucykgPT4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgbS5NaW5pbWF0Y2ggPSBjbGFzcyBNaW5pbWF0Y2ggZXh0ZW5kcyBvcmlnLk1pbmltYXRjaCB7XG4gICAgY29uc3RydWN0b3IgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICAgIHN1cGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICAgIH1cbiAgfVxuICBtLk1pbmltYXRjaC5kZWZhdWx0cyA9IG9wdGlvbnMgPT4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSkuTWluaW1hdGNoXG4gIG0uZmlsdGVyID0gKHBhdHRlcm4sIG9wdGlvbnMpID0+IG9yaWcuZmlsdGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICBtLmRlZmF1bHRzID0gb3B0aW9ucyA9PiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKVxuICBtLm1ha2VSZSA9IChwYXR0ZXJuLCBvcHRpb25zKSA9PiBvcmlnLm1ha2VSZShwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgbS5icmFjZUV4cGFuZCA9IChwYXR0ZXJuLCBvcHRpb25zKSA9PiBvcmlnLmJyYWNlRXhwYW5kKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICBtLm1hdGNoID0gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMpID0+IG9yaWcubWF0Y2gobGlzdCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG5cbiAgcmV0dXJuIG1cbn1cblxuXG5cblxuXG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IChwYXR0ZXJuLCBvcHRpb25zKSA9PiBicmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxuXG5jb25zdCBicmFjZUV4cGFuZCA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgLy8gVGhhbmtzIHRvIFlldGluZyBMaSA8aHR0cHM6Ly9naXRodWIuY29tL3lldGluZ2xpPiBmb3JcbiAgLy8gaW1wcm92aW5nIHRoaXMgcmVnZXhwIHRvIGF2b2lkIGEgUmVET1MgdnVsbmVyYWJpbGl0eS5cbiAgaWYgKG9wdGlvbnMubm9icmFjZSB8fCAhL1xceyg/Oig/IVxceykuKSpcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAvLyBzaG9ydGN1dC4gbm8gbmVlZCB0byBleHBhbmQuXG4gICAgcmV0dXJuIFtwYXR0ZXJuXVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChwYXR0ZXJuKVxufVxuXG5jb25zdCBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjRcbmNvbnN0IGFzc2VydFZhbGlkUGF0dGVybiA9IHBhdHRlcm4gPT4ge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJylcbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKVxuICB9XG59XG5cbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuY29uc3QgU1VCUEFSU0UgPSBTeW1ib2woJ3N1YnBhcnNlJylcblxubWluaW1hdGNoLm1ha2VSZSA9IChwYXR0ZXJuLCBvcHRpb25zKSA9PlxuICBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMgfHwge30pLm1ha2VSZSgpXG5cbm1pbmltYXRjaC5tYXRjaCA9IChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIGxpc3QgPSBsaXN0LmZpbHRlcihmID0+IG1tLm1hdGNoKGYpKVxuICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgbGlzdC5wdXNoKHBhdHRlcm4pXG4gIH1cbiAgcmV0dXJuIGxpc3Rcbn1cblxuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmNvbnN0IGdsb2JVbmVzY2FwZSA9IHMgPT4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG5jb25zdCBjaGFyVW5lc2NhcGUgPSBzID0+IHMucmVwbGFjZSgvXFxcXChbXi1cXF1dKS9nLCAnJDEnKVxuY29uc3QgcmVnRXhwRXNjYXBlID0gcyA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylcbmNvbnN0IGJyYUV4cEVzY2FwZSA9IHMgPT4gcy5yZXBsYWNlKC9bW1xcXVxcXFxdL2csICdcXFxcJCYnKVxuXG5jbGFzcyBNaW5pbWF0Y2gge1xuICBjb25zdHJ1Y3RvciAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLnNldCA9IFtdXG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPSAhIW9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGUgfHxcbiAgICAgIG9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlID09PSBmYWxzZVxuICAgIGlmICh0aGlzLndpbmRvd3NQYXRoc05vRXNjYXBlKSB7XG4gICAgICB0aGlzLnBhdHRlcm4gPSB0aGlzLnBhdHRlcm4ucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgfVxuICAgIHRoaXMucmVnZXhwID0gbnVsbFxuICAgIHRoaXMubmVnYXRlID0gZmFsc2VcbiAgICB0aGlzLmNvbW1lbnQgPSBmYWxzZVxuICAgIHRoaXMuZW1wdHkgPSBmYWxzZVxuICAgIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsXG5cbiAgICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gICAgdGhpcy5tYWtlKClcbiAgfVxuXG4gIGRlYnVnICgpIHt9XG5cbiAgbWFrZSAoKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAgIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgdGhpcy5jb21tZW50ID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcGF0dGVybikge1xuICAgICAgdGhpcy5lbXB0eSA9IHRydWVcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICAgIHRoaXMucGFyc2VOZWdhdGUoKVxuXG4gICAgLy8gc3RlcCAyOiBleHBhbmQgYnJhY2VzXG4gICAgbGV0IHNldCA9IHRoaXMuZ2xvYlNldCA9IHRoaXMuYnJhY2VFeHBhbmQoKVxuXG4gICAgaWYgKG9wdGlvbnMuZGVidWcpIHRoaXMuZGVidWcgPSAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvciguLi5hcmdzKVxuXG4gICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAgIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZiBwYXRoLXBvcnRpb25cbiAgICAvLyBtYXRjaGluZyBwYXR0ZXJucy5cbiAgICAvLyBUaGVzZSB3aWxsIGJlIHJlZ2V4cHMsIGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBcIioqXCIsIHdoaWNoIGlzXG4gICAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAgIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgICBzZXQgPSB0aGlzLmdsb2JQYXJ0cyA9IHNldC5tYXAocyA9PiBzLnNwbGl0KHNsYXNoU3BsaXQpKVxuXG4gICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAgIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgICBzZXQgPSBzZXQubWFwKChzLCBzaSwgc2V0KSA9PiBzLm1hcCh0aGlzLnBhcnNlLCB0aGlzKSlcblxuICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgICBzZXQgPSBzZXQuZmlsdGVyKHMgPT4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTEpXG5cbiAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gICAgdGhpcy5zZXQgPSBzZXRcbiAgfVxuXG4gIHBhcnNlTmVnYXRlICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vbmVnYXRlKSByZXR1cm5cblxuICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgICBsZXQgbmVnYXRlID0gZmFsc2VcbiAgICBsZXQgbmVnYXRlT2Zmc2V0ID0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnOyBpKyspIHtcbiAgICAgIG5lZ2F0ZSA9ICFuZWdhdGVcbiAgICAgIG5lZ2F0ZU9mZnNldCsrXG4gICAgfVxuXG4gICAgaWYgKG5lZ2F0ZU9mZnNldCkgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zbGljZShuZWdhdGVPZmZzZXQpXG4gICAgdGhpcy5uZWdhdGUgPSBuZWdhdGVcbiAgfVxuXG4gIC8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4gIC8vIFwiL2EvYlwiIG1hdGNoZXMgdGhlIHN0YXJ0IG9mIFwiLyovYi8qL2RcIlxuICAvLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4gIC8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuICAvLyB0aGUgcGFydHMgbWF0Y2guXG4gIG1hdGNoT25lIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJyxcbiAgICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIGZpbGUubGVuZ3RoLCBwYXR0ZXJuLmxlbmd0aClcblxuICAgIGZvciAodmFyIGZpID0gMCxcbiAgICAgICAgcGkgPSAwLFxuICAgICAgICBmbCA9IGZpbGUubGVuZ3RoLFxuICAgICAgICBwbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgICA7IGZpKyssIHBpKyspIHtcbiAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKVxuICAgICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgICAgdmFyIGYgPSBmaWxlW2ZpXVxuXG4gICAgICB0aGlzLmRlYnVnKHBhdHRlcm4sIHAsIGYpXG5cbiAgICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgICAgLy8gc29tZSBpbnZhbGlkIHJlZ2V4cCBzdHVmZiBpbiB0aGUgc2V0LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgICBpZiAocCA9PT0gR0xPQlNUQVIpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pXG5cbiAgICAgICAgLy8gXCIqKlwiXG4gICAgICAgIC8vIGEvKiovYi8qKi9jIHdvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAgIC8vIGEvYi94L2IveC9jXG4gICAgICAgIC8vIGEvYi9jXG4gICAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgICAgLy8gdGhlICoqLCBhbmQgc2VlIGlmIGl0IHdvdWxkIG1hdGNoIHRoZSBmaWxlIHJlbWFpbmRlci5cbiAgICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGF3ZnVsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgICAvLyAtIGEgbWF0Y2hlcyBhXG4gICAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAgIC8vICAgICAtIGIgbWF0Y2hlcyBiXG4gICAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHkvei9jLCBjKSAtPiBub1xuICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgICB2YXIgZnIgPSBmaVxuICAgICAgICB2YXIgcHIgPSBwaSArIDFcbiAgICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICAgIHRoaXMuZGVidWcoJyoqIGF0IHRoZSBlbmQnKVxuICAgICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgLy8gaG93ZXZlciwgaXQgd2lsbCBub3Qgc3dhbGxvdyAvLngsIHVubGVzc1xuICAgICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgICAvLyBleHBvbmVudGlhbCByZWFzb25zLlxuICAgICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIGZpbGVbZmldLmNoYXJBdCgwKSA9PT0gJy4nKSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgICB2YXIgc3dhbGxvd2VlID0gZmlsZVtmcl1cblxuICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpXG5cbiAgICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoT25lKGZpbGUuc2xpY2UoZnIpLCBwYXR0ZXJuLnNsaWNlKHByKSwgcGFydGlhbCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKVxuICAgICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgICAvLyBjYW4gb25seSBzd2FsbG93IFwiLmZvb1wiIHdoZW4gZXhwbGljaXRseSBhc2tlZC5cbiAgICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fCBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2RvdCBkZXRlY3RlZCEnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICoqIHN3YWxsb3dzIGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpXG4gICAgICAgICAgICBmcisrXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgICAvLyBIb3dldmVyLCBpbiBwYXJ0aWFsIG1vZGUsIHdlIGNhbid0IHNheSB0aGlzIGlzIG5lY2Vzc2FyaWx5IG92ZXIuXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSAqcGF0dGVybiogbGVmdCwgdGhlblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgIGlmIChmciA9PT0gZmwpIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAgIC8vIHBhdHRlcm5zIHdpdGggbWFnaWMgaGF2ZSBiZWVuIHR1cm5lZCBpbnRvIHJlZ2V4cHMuXG4gICAgICB2YXIgaGl0XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhpdCA9IGYgPT09IHBcbiAgICAgICAgdGhpcy5kZWJ1Zygnc3RyaW5nIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGl0ID0gZi5tYXRjaChwKVxuICAgICAgICB0aGlzLmRlYnVnKCdwYXR0ZXJuIG1hdGNoJywgcCwgZiwgaGl0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhpdCkgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybi4gIFRoaXMgY2FuIG9ubHkgbWF0Y2ggYVxuICAgIC8vIGNvcnJlc3BvbmRpbmcgXCJcIiBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlLlxuICAgIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gICAgLy8gYSBwYXR0ZXJuIHRoYXQgZW5kcyBpbiAvLCB1bmxlc3MgdGhlIHBhdHRlcm4ganVzdFxuICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBmb3IgaXQuIEJ1dCwgYS9iLyBzaG91bGQgKm5vdCpcbiAgICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAgIC8vIFteL10qPyBwYXR0ZXJuLCBleGNlcHQgaW4gcGFydGlhbCBtb2RlLCB3aGVyZSBpdCBtaWdodFxuICAgIC8vIHNpbXBseSBub3QgYmUgcmVhY2hlZCB5ZXQuXG4gICAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAgIC8vIG5vdyBlaXRoZXIgd2UgZmVsbCBvZmYgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiwgb3Igd2UncmUgZG9uZS5cbiAgICBpZiAoZmkgPT09IGZsICYmIHBpID09PSBwbCkge1xuICAgICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgLy8gYW4gZXhhY3QgaGl0IVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgICAgLy8gcmFuIG91dCBvZiBmaWxlLCBidXQgc3RpbGwgaGFkIHBhdHRlcm4gbGVmdC5cbiAgICAgIC8vIHRoaXMgaXMgb2sgaWYgd2UncmUgZG9pbmcgdGhlIG1hdGNoIGFzIHBhcnQgb2ZcbiAgICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgICByZXR1cm4gcGFydGlhbFxuICAgIH0gZWxzZSAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqLyBpZiAocGkgPT09IHBsKSB7XG4gICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgICAgLy8gdGhpcyBpcyBvbmx5IGFjY2VwdGFibGUgaWYgd2UncmUgb24gdGhlIHZlcnkgbGFzdFxuICAgICAgLy8gZW1wdHkgc2VnbWVudCBvZiBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgICByZXR1cm4gKGZpID09PSBmbCAtIDEpICYmIChmaWxlW2ZpXSA9PT0gJycpXG4gICAgfVxuXG4gICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3dGY/JylcbiAgfVxuXG4gIGJyYWNlRXhwYW5kICgpIHtcbiAgICByZXR1cm4gYnJhY2VFeHBhbmQodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBwYXJzZSAocGF0dGVybiwgaXNTdWIpIHtcbiAgICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAgIC8vIHNob3J0Y3V0c1xuICAgIGlmIChwYXR0ZXJuID09PSAnKionKSB7XG4gICAgICBpZiAoIW9wdGlvbnMubm9nbG9ic3RhcilcbiAgICAgICAgcmV0dXJuIEdMT0JTVEFSXG4gICAgICBlbHNlXG4gICAgICAgIHBhdHRlcm4gPSAnKidcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4gPT09ICcnKSByZXR1cm4gJydcblxuICAgIGxldCByZSA9ICcnXG4gICAgbGV0IGhhc01hZ2ljID0gZmFsc2VcbiAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZVxuICAgIC8vID8gPT4gb25lIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICBjb25zdCBwYXR0ZXJuTGlzdFN0YWNrID0gW11cbiAgICBjb25zdCBuZWdhdGl2ZUxpc3RzID0gW11cbiAgICBsZXQgc3RhdGVDaGFyXG4gICAgbGV0IGluQ2xhc3MgPSBmYWxzZVxuICAgIGxldCByZUNsYXNzU3RhcnQgPSAtMVxuICAgIGxldCBjbGFzc1N0YXJ0ID0gLTFcbiAgICBsZXQgY3NcbiAgICBsZXQgcGxcbiAgICBsZXQgc3BcbiAgICAvLyAuIGFuZCAuLiBuZXZlciBtYXRjaCBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc3RhcnQgd2l0aCAuLFxuICAgIC8vIGV2ZW4gd2hlbiBvcHRpb25zLmRvdCBpcyBzZXQuICBIb3dldmVyLCBpZiB0aGUgcGF0dGVyblxuICAgIC8vIHN0YXJ0cyB3aXRoIC4sIHRoZW4gdHJhdmVyc2FsIHBhdHRlcm5zIGNhbiBtYXRjaC5cbiAgICBsZXQgZG90VHJhdkFsbG93ZWQgPSBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy4nXG4gICAgbGV0IGRvdEZpbGVBbGxvd2VkID0gb3B0aW9ucy5kb3QgfHwgZG90VHJhdkFsbG93ZWRcbiAgICBjb25zdCBwYXR0ZXJuU3RhcnQgPSAoKSA9PlxuICAgICAgZG90VHJhdkFsbG93ZWRcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IGRvdEZpbGVBbGxvd2VkXG4gICAgICAgID8gJyg/ISg/Ol58XFxcXC8pXFxcXC57MSwyfSg/OiR8XFxcXC8pKSdcbiAgICAgICAgOiAnKD8hXFxcXC4pJ1xuICAgIGNvbnN0IHN1YlBhdHRlcm5TdGFydCA9IChwKSA9PlxuICAgICAgcC5jaGFyQXQoMCkgPT09ICcuJ1xuICAgICAgICA/ICcnXG4gICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgPyAnKD8hKD86XnxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcLykpJ1xuICAgICAgICA6ICcoPyFcXFxcLiknXG5cblxuICAgIGNvbnN0IGNsZWFyU3RhdGVDaGFyID0gKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlQ2hhcikge1xuICAgICAgICAvLyB3ZSBoYWQgc29tZSBzdGF0ZS10cmFja2luZyBjaGFyYWN0ZXJcbiAgICAgICAgLy8gdGhhdCB3YXNuJ3QgY29uc3VtZWQgYnkgdGhpcyBwYXNzLlxuICAgICAgICBzd2l0Y2ggKHN0YXRlQ2hhcikge1xuICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgcmUgKz0gc3RhclxuICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgIHJlICs9IHFtYXJrXG4gICAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZSArPSAnXFxcXCcgKyBzdGF0ZUNoYXJcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoJ2NsZWFyU3RhdGVDaGFyICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgYzsgKGkgPCBwYXR0ZXJuLmxlbmd0aCkgJiYgKGMgPSBwYXR0ZXJuLmNoYXJBdChpKSk7IGkrKykge1xuICAgICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAvLyBza2lwIG92ZXIgYW55IHRoYXQgYXJlIGVzY2FwZWQuXG4gICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBjb21wbGV0ZWx5IG5vdCBhbGxvd2VkLCBldmVuIGVzY2FwZWQuICovXG4gICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZVNwZWNpYWxzW2NdKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnXG4gICAgICAgIH1cbiAgICAgICAgcmUgKz0gY1xuICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBjYXNlICcvJzoge1xuICAgICAgICAgIC8vIFNob3VsZCBhbHJlYWR5IGJlIHBhdGgtc3BsaXQgYnkgbm93LlxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgaWYgKGluQ2xhc3MgJiYgcGF0dGVybi5jaGFyQXQoaSArIDEpID09PSAnLScpIHtcbiAgICAgICAgICAgIHJlICs9IGNcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIC8vIHRoZSB2YXJpb3VzIHN0YXRlQ2hhciB2YWx1ZXNcbiAgICAgICAgLy8gZm9yIHRoZSBcImV4dGdsb2JcIiBzdHVmZi5cbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWogPC0tIHN0YXRlQ2hhcicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAgICAgLy8gYWxsIG9mIHRob3NlIGFyZSBsaXRlcmFscyBpbnNpZGUgYSBjbGFzcywgZXhjZXB0IHRoYXRcbiAgICAgICAgICAvLyB0aGUgZ2xvYiBbIWFdIG1lYW5zIFteYV0gaW4gcmVnZXhwXG4gICAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJyAgaW4gY2xhc3MnKVxuICAgICAgICAgICAgaWYgKGMgPT09ICchJyAmJiBpID09PSBjbGFzc1N0YXJ0ICsgMSkgYyA9ICdeJ1xuICAgICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0ZUNoYXIsIHRoZW4gaXQgbWVhbnNcbiAgICAgICAgICAvLyB0aGF0IHRoZXJlIHdhcyBzb21ldGhpbmcgbGlrZSAqKiBvciArPyBpbiB0aGVyZS5cbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIHN0YXRlQ2hhciwgdGhlbiBwcm9jZWVkIHdpdGggdGhpcyBvbmUuXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnY2FsbCBjbGVhclN0YXRlQ2hhciAlaicsIHN0YXRlQ2hhcilcbiAgICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgICAgc3RhdGVDaGFyID0gY1xuICAgICAgICAgIC8vIGlmIGV4dGdsb2IgaXMgZGlzYWJsZWQsIHRoZW4gKyhhc2RmfGZvbykgaXNuJ3QgYSB0aGluZy5cbiAgICAgICAgICAvLyBqdXN0IGNsZWFyIHRoZSBzdGF0ZWNoYXIgKm5vdyosIHJhdGhlciB0aGFuIGV2ZW4gZGl2aW5nIGludG9cbiAgICAgICAgICAvLyB0aGUgcGF0dGVybkxpc3Qgc3R1ZmYuXG4gICAgICAgICAgaWYgKG9wdGlvbnMubm9leHQpIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlICcoJzoge1xuICAgICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgICByZSArPSAnKCdcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzdGF0ZUNoYXIpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcKCdcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcGxFbnRyeSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHN0YXRlQ2hhcixcbiAgICAgICAgICAgIHN0YXJ0OiBpIC0gMSxcbiAgICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICAgIG9wZW46IHBsVHlwZXNbc3RhdGVDaGFyXS5vcGVuLFxuICAgICAgICAgICAgY2xvc2U6IHBsVHlwZXNbc3RhdGVDaGFyXS5jbG9zZSxcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdcXHQnLCBwbEVudHJ5KVxuICAgICAgICAgIHBhdHRlcm5MaXN0U3RhY2sucHVzaChwbEVudHJ5KVxuICAgICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/ISg/OmpzKSg/OjxyZXN0PikpW14vXSopXG4gICAgICAgICAgcmUgKz0gcGxFbnRyeS5vcGVuXG4gICAgICAgICAgLy8gbmV4dCBlbnRyeSBzdGFydHMgd2l0aCBhIGRvdCBtYXliZT9cbiAgICAgICAgICBpZiAocGxFbnRyeS5zdGFydCA9PT0gMCAmJiBwbEVudHJ5LnR5cGUgIT09ICchJykge1xuICAgICAgICAgICAgZG90VHJhdkFsbG93ZWQgPSB0cnVlXG4gICAgICAgICAgICByZSArPSBzdWJQYXR0ZXJuU3RhcnQocGF0dGVybi5zbGljZShpICsgMSkpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGVidWcoJ3BsVHlwZSAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnKSc6IHtcbiAgICAgICAgICBjb25zdCBwbEVudHJ5ID0gcGF0dGVybkxpc3RTdGFja1twYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCAtIDFdXG4gICAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBsRW50cnkpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcKSdcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdHRlcm5MaXN0U3RhY2sucG9wKClcblxuICAgICAgICAgIC8vIGNsb3NpbmcgYW4gZXh0Z2xvYlxuICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgICBwbCA9IHBsRW50cnlcbiAgICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgICAvLyBUaGUgb3RoZXJzIGFyZSAoPzo8cGF0dGVybj4pPHR5cGU+XG4gICAgICAgICAgcmUgKz0gcGwuY2xvc2VcbiAgICAgICAgICBpZiAocGwudHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgICBuZWdhdGl2ZUxpc3RzLnB1c2goT2JqZWN0LmFzc2lnbihwbCwgeyByZUVuZDogcmUubGVuZ3RoIH0pKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnfCc6IHtcbiAgICAgICAgICBjb25zdCBwbEVudHJ5ID0gcGF0dGVybkxpc3RTdGFja1twYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCAtIDFdXG4gICAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBsRW50cnkpIHtcbiAgICAgICAgICAgIHJlICs9ICdcXFxcfCdcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICAgIHJlICs9ICd8J1xuICAgICAgICAgIC8vIG5leHQgc3VicGF0dGVybiBjYW4gc3RhcnQgd2l0aCBhIGRvdD9cbiAgICAgICAgICBpZiAocGxFbnRyeS5zdGFydCA9PT0gMCAmJiBwbEVudHJ5LnR5cGUgIT09ICchJykge1xuICAgICAgICAgICAgZG90VHJhdkFsbG93ZWQgPSB0cnVlXG4gICAgICAgICAgICByZSArPSBzdWJQYXR0ZXJuU3RhcnQocGF0dGVybi5zbGljZShpICsgMSkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGVzZSBhcmUgbW9zdGx5IHRoZSBzYW1lIGluIHJlZ2V4cCBhbmQgZ2xvYlxuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZS10cmFja2luZyBjaGFyIGJlZm9yZSB0aGUgW1xuICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluQ2xhc3MgPSB0cnVlXG4gICAgICAgICAgY2xhc3NTdGFydCA9IGlcbiAgICAgICAgICByZUNsYXNzU3RhcnQgPSByZS5sZW5ndGhcbiAgICAgICAgICByZSArPSBjXG4gICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgLy8gIGEgcmlnaHQgYnJhY2tldCBzaGFsbCBsb3NlIGl0cyBzcGVjaWFsXG4gICAgICAgICAgLy8gIG1lYW5pbmcgYW5kIHJlcHJlc2VudCBpdHNlbGYgaW5cbiAgICAgICAgICAvLyAgYSBicmFja2V0IGV4cHJlc3Npb24gaWYgaXQgb2NjdXJzXG4gICAgICAgICAgLy8gIGZpcnN0IGluIHRoZSBsaXN0LiAgLS0gUE9TSVguMiAyLjguMy4yXG4gICAgICAgICAgaWYgKGkgPT09IGNsYXNzU3RhcnQgKyAxIHx8ICFpbkNsYXNzKSB7XG4gICAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGFuIGludmFsaWQgcmUuIGlmIHNvLCByZS13YWxrIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAgICAgICAvLyB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGUgYW55IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAgIC8vIHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICAgICAgICAvLyBUT0RPOiBJdCB3b3VsZCBwcm9iYWJseSBiZSBmYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoaXNcbiAgICAgICAgICAvLyB3aXRob3V0IGEgdHJ5L2NhdGNoIGFuZCBhIG5ldyBSZWdFeHAsIGJ1dCBpdCdzIHRyaWNreVxuICAgICAgICAgIC8vIHRvIGRvIHNhZmVseS4gIEZvciBub3csIHRoaXMgaXMgc2FmZSBhbmQgd29ya3MuXG4gICAgICAgICAgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVnRXhwKCdbJyArIGJyYUV4cEVzY2FwZShjaGFyVW5lc2NhcGUoY3MpKSArICddJylcbiAgICAgICAgICAgIC8vIGxvb2tzIGdvb2QsIGZpbmlzaCB1cCB0aGUgY2xhc3MuXG4gICAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIC8vIG91dCBvZiBvcmRlciByYW5nZXMgaW4gSlMgYXJlIGVycm9ycywgYnV0IGluIGdsb2Igc3ludGF4LFxuICAgICAgICAgICAgLy8gdGhleSdyZSBqdXN0IGEgcmFuZ2UgdGhhdCBtYXRjaGVzIG5vdGhpbmcuXG4gICAgICAgICAgICByZSA9IHJlLnN1YnN0cmluZygwLCByZUNsYXNzU3RhcnQpICsgJyg/OiQuKScgLy8gbWF0Y2ggbm90aGluZyBldmVyXG4gICAgICAgICAgfVxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUgY2hhciB0aGF0IHdhc24ndCBjb25zdW1lZFxuICAgICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICAgIGlmIChyZVNwZWNpYWxzW2NdICYmICEoYyA9PT0gJ14nICYmIGluQ2xhc3MpKSB7XG4gICAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgfSAvLyBzd2l0Y2hcbiAgICB9IC8vIGZvclxuXG4gICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAgIC8vIFwiW2FiY1wiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbYWJjXCJcbiAgICBpZiAoaW5DbGFzcykge1xuICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIGFuZCBlc2NhcGUgaXRcbiAgICAgIC8vIHRoaXMgaXMgYSBodWdlIHBpdGEuICBXZSBub3cgaGF2ZSB0byByZS13YWxrXG4gICAgICAvLyB0aGUgY29udGVudHMgb2YgdGhlIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZVxuICAgICAgLy8gYW55IGNoYXJhY3RlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgICBjcyA9IHBhdHRlcm4uc2xpY2UoY2xhc3NTdGFydCArIDEpXG4gICAgICBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgICAgcmUgPSByZS5zdWJzdHJpbmcoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXVxuICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBoYWQgYSArKCB0aGluZyBhdCB0aGUgKmVuZCpcbiAgICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgICAvLyBhbmQgZXNjYXBlIGFueSB8IGNoYXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pcyBmb3IgdGhlIHJlZ2V4cC5cbiAgICAvLyBHbyB0aHJvdWdoIGFuZCBlc2NhcGUgdGhlbSwgdGFraW5nIGNhcmUgbm90IHRvIGRvdWJsZS1lc2NhcGUgYW55XG4gICAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICAgIGZvciAocGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpOyBwbDsgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpKSB7XG4gICAgICBsZXQgdGFpbFxuICAgICAgdGFpbCA9IHJlLnNsaWNlKHBsLnJlU3RhcnQgKyBwbC5vcGVuLmxlbmd0aClcbiAgICAgIHRoaXMuZGVidWcoJ3NldHRpbmcgdGFpbCcsIHJlLCBwbClcbiAgICAgIC8vIG1heWJlIHNvbWUgZXZlbiBudW1iZXIgb2YgXFwsIHRoZW4gbWF5YmUgMSBcXCwgZm9sbG93ZWQgYnkgYSB8XG4gICAgICB0YWlsID0gdGFpbC5yZXBsYWNlKC8oKD86XFxcXHsyfSl7MCw2NH0pKFxcXFw/KVxcfC9nLCAoXywgJDEsICQyKSA9PiB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gc2hvdWxkIGFscmVhZHkgYmUgZG9uZSAqL1xuICAgICAgICBpZiAoISQyKSB7XG4gICAgICAgICAgLy8gdGhlIHwgaXNuJ3QgYWxyZWFkeSBlc2NhcGVkLCBzbyBlc2NhcGUgaXQuXG4gICAgICAgICAgJDIgPSAnXFxcXCdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5lZWQgdG8gZXNjYXBlIGFsbCB0aG9zZSBzbGFzaGVzICphZ2FpbiosIHdpdGhvdXQgZXNjYXBpbmcgdGhlXG4gICAgICAgIC8vIG9uZSB0aGF0IHdlIG5lZWQgZm9yIGVzY2FwaW5nIHRoZSB8IGNoYXJhY3Rlci4gIEFzIGl0IHdvcmtzIG91dCxcbiAgICAgICAgLy8gZXNjYXBpbmcgYW4gZXZlbiBudW1iZXIgb2Ygc2xhc2hlcyBjYW4gYmUgZG9uZSBieSBzaW1wbHkgcmVwZWF0aW5nXG4gICAgICAgIC8vIGl0IGV4YWN0bHkgYWZ0ZXIgaXRzZWxmLiAgVGhhdCdzIHdoeSB0aGlzIHRyaWNrIHdvcmtzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIGFtIHNvcnJ5IHRoYXQgeW91IGhhdmUgdG8gc2VlIHRoaXMuXG4gICAgICAgIHJldHVybiAkMSArICQxICsgJDIgKyAnfCdcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuZGVidWcoJ3RhaWw9JWpcXG4gICAlcycsIHRhaWwsIHRhaWwsIHBsLCByZSlcbiAgICAgIGNvbnN0IHQgPSBwbC50eXBlID09PSAnKicgPyBzdGFyXG4gICAgICAgIDogcGwudHlwZSA9PT0gJz8nID8gcW1hcmtcbiAgICAgICAgOiAnXFxcXCcgKyBwbC50eXBlXG5cbiAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgcmUgPSByZS5zbGljZSgwLCBwbC5yZVN0YXJ0KSArIHQgKyAnXFxcXCgnICsgdGFpbFxuICAgIH1cblxuICAgIC8vIGhhbmRsZSB0cmFpbGluZyB0aGluZ3MgdGhhdCBvbmx5IG1hdHRlciBhdCB0aGUgdmVyeSBlbmQuXG4gICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgIGlmIChlc2NhcGluZykge1xuICAgICAgLy8gdHJhaWxpbmcgXFxcXFxuICAgICAgcmUgKz0gJ1xcXFxcXFxcJ1xuICAgIH1cblxuICAgIC8vIG9ubHkgbmVlZCB0byBhcHBseSB0aGUgbm9kb3Qgc3RhcnQgaWYgdGhlIHJlIHN0YXJ0cyB3aXRoXG4gICAgLy8gc29tZXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgY2FwdHVyZSBhIGRvdFxuICAgIGNvbnN0IGFkZFBhdHRlcm5TdGFydCA9IGFkZFBhdHRlcm5TdGFydFNldFtyZS5jaGFyQXQoMCldXG5cbiAgICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGxhY2sgb2YgbmVnYXRpdmUgbG9va2JlaGluZCBpbiBKU1xuICAgIC8vIEEgcGF0dGVybiBsaWtlOiAqLiEoeCkuISh5fHopIG5lZWRzIHRvIGVuc3VyZSB0aGF0IGEgbmFtZVxuICAgIC8vIGxpa2UgJ2EueHl6Lnl6JyBkb2Vzbid0IG1hdGNoLiAgU28sIHRoZSBmaXJzdCBuZWdhdGl2ZVxuICAgIC8vIGxvb2thaGVhZCwgaGFzIHRvIGxvb2sgQUxMIHRoZSB3YXkgYWhlYWQsIHRvIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgcGF0dGVybi5cbiAgICBmb3IgKGxldCBuID0gbmVnYXRpdmVMaXN0cy5sZW5ndGggLSAxOyBuID4gLTE7IG4tLSkge1xuICAgICAgY29uc3QgbmwgPSBuZWdhdGl2ZUxpc3RzW25dXG5cbiAgICAgIGNvbnN0IG5sQmVmb3JlID0gcmUuc2xpY2UoMCwgbmwucmVTdGFydClcbiAgICAgIGNvbnN0IG5sRmlyc3QgPSByZS5zbGljZShubC5yZVN0YXJ0LCBubC5yZUVuZCAtIDgpXG4gICAgICBsZXQgbmxBZnRlciA9IHJlLnNsaWNlKG5sLnJlRW5kKVxuICAgICAgY29uc3QgbmxMYXN0ID0gcmUuc2xpY2UobmwucmVFbmQgLSA4LCBubC5yZUVuZCkgKyBubEFmdGVyXG5cbiAgICAgIC8vIEhhbmRsZSBuZXN0ZWQgc3R1ZmYgbGlrZSAqKCouanN8ISgqLmpzb24pKSwgd2hlcmUgb3BlbiBwYXJlbnNcbiAgICAgIC8vIG1lYW4gdGhhdCB3ZSBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGUgKSBpbiB0aGUgYml0IHRoYXQgaXMgY29uc2lkZXJlZFxuICAgICAgLy8gXCJhZnRlclwiIHRoZSBuZWdhdGVkIHNlY3Rpb24uXG4gICAgICBjb25zdCBjbG9zZVBhcmVuc0JlZm9yZSA9IG5sQmVmb3JlLnNwbGl0KCcpJykubGVuZ3RoXG4gICAgICBjb25zdCBvcGVuUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJygnKS5sZW5ndGggLSBjbG9zZVBhcmVuc0JlZm9yZVxuICAgICAgbGV0IGNsZWFuQWZ0ZXIgPSBubEFmdGVyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wZW5QYXJlbnNCZWZvcmU7IGkrKykge1xuICAgICAgICBjbGVhbkFmdGVyID0gY2xlYW5BZnRlci5yZXBsYWNlKC9cXClbKyo/XT8vLCAnJylcbiAgICAgIH1cbiAgICAgIG5sQWZ0ZXIgPSBjbGVhbkFmdGVyXG5cbiAgICAgIGNvbnN0IGRvbGxhciA9IG5sQWZ0ZXIgPT09ICcnICYmIGlzU3ViICE9PSBTVUJQQVJTRSA/ICcoPzokfFxcXFwvKScgOiAnJ1xuXG4gICAgICByZSA9IG5sQmVmb3JlICsgbmxGaXJzdCArIG5sQWZ0ZXIgKyBkb2xsYXIgKyBubExhc3RcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgcmUgaXMgbm90IFwiXCIgYXQgdGhpcyBwb2ludCwgdGhlbiB3ZSBuZWVkIHRvIG1ha2Ugc3VyZVxuICAgIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gICAgLy8gT3RoZXJ3aXNlIGEvKiB3aWxsIG1hdGNoIGEvLCB3aGljaCBpdCBzaG91bGQgbm90LlxuICAgIGlmIChyZSAhPT0gJycgJiYgaGFzTWFnaWMpIHtcbiAgICAgIHJlID0gJyg/PS4pJyArIHJlXG4gICAgfVxuXG4gICAgaWYgKGFkZFBhdHRlcm5TdGFydCkge1xuICAgICAgcmUgPSBwYXR0ZXJuU3RhcnQoKSArIHJlXG4gICAgfVxuXG4gICAgLy8gcGFyc2luZyBqdXN0IGEgcGllY2Ugb2YgYSBsYXJnZXIgcGF0dGVybi5cbiAgICBpZiAoaXNTdWIgPT09IFNVQlBBUlNFKSB7XG4gICAgICByZXR1cm4gW3JlLCBoYXNNYWdpY11cbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vY2FzZSwgYW5kIHRoZSBsY2FzZS91cHBlcmNhc2UgZG9uJ3QgbWF0Y2gsIGl0J3MgbWFnaWNcbiAgICBpZiAob3B0aW9ucy5ub2Nhc2UgJiYgIWhhc01hZ2ljKSB7XG4gICAgICBoYXNNYWdpYyA9IHBhdHRlcm4udG9VcHBlckNhc2UoKSAhPT0gcGF0dGVybi50b0xvd2VyQ2FzZSgpXG4gICAgfVxuXG4gICAgLy8gc2tpcCB0aGUgcmVnZXhwIGZvciBub24tbWFnaWNhbCBwYXR0ZXJuc1xuICAgIC8vIHVuZXNjYXBlIGFueXRoaW5nIGluIGl0LCB0aG91Z2gsIHNvIHRoYXQgaXQnbGwgYmVcbiAgICAvLyBhbiBleGFjdCBtYXRjaCBhZ2FpbnN0IGEgZmlsZSBldGMuXG4gICAgaWYgKCFoYXNNYWdpYykge1xuICAgICAgcmV0dXJuIGdsb2JVbmVzY2FwZShwYXR0ZXJuKVxuICAgIH1cblxuICAgIGNvbnN0IGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUmVnRXhwKCdeJyArIHJlICsgJyQnLCBmbGFncyksIHtcbiAgICAgICAgX2dsb2I6IHBhdHRlcm4sXG4gICAgICAgIF9zcmM6IHJlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcikgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBzaG91bGQgYmUgaW1wb3NzaWJsZSAqLyB7XG4gICAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAgIC8vIGFueXRoaW5nLiAgVGhpcyB0cmljayBsb29rcyBmb3IgYSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIHN0cmluZywgd2hpY2ggaXMgb2YgY291cnNlIGltcG9zc2libGUsIGV4Y2VwdCBpbiBtdWx0aS1saW5lXG4gICAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKCckLicpXG4gICAgfVxuICB9XG5cbiAgbWFrZVJlICgpIHtcbiAgICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKSByZXR1cm4gdGhpcy5yZWdleHBcblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAgIC8vIHBhdHRlcm4gc3RyaW5ncywgb3IgXCIqKlwiLlxuICAgIC8vXG4gICAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgICAvLyBiZSB1c2VkLCByZWFsbHksIGJ1dCBpdCdzIHByZXR0eSBjb252ZW5pZW50IHNvbWV0aW1lcyxcbiAgICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gICAgY29uc3Qgc2V0ID0gdGhpcy5zZXRcblxuICAgIGlmICghc2V0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgICAgcmV0dXJuIHRoaXMucmVnZXhwXG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAgIGNvbnN0IHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgICA6IG9wdGlvbnMuZG90ID8gdHdvU3RhckRvdFxuICAgICAgOiB0d29TdGFyTm9Eb3RcbiAgICBjb25zdCBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcblxuICAgIC8vIGNvYWxlc2NlIGdsb2JzdGFycyBhbmQgcmVnZXhwaWZ5IG5vbi1nbG9ic3RhciBwYXR0ZXJuc1xuICAgIC8vIGlmIGl0J3MgdGhlIG9ubHkgaXRlbSwgdGhlbiB3ZSBqdXN0IGRvIG9uZSB0d29TdGFyXG4gICAgLy8gaWYgaXQncyB0aGUgZmlyc3QsIGFuZCB0aGVyZSBhcmUgbW9yZSwgcHJlcGVuZCAoXFwvfHR3b1N0YXJcXC8pPyB0byBuZXh0XG4gICAgLy8gaWYgaXQncyB0aGUgbGFzdCwgYXBwZW5kIChcXC90d29TdGFyfCkgdG8gcHJldmlvdXNcbiAgICAvLyBpZiBpdCdzIGluIHRoZSBtaWRkbGUsIGFwcGVuZCAoXFwvfFxcL3R3b1N0YXJcXC8pIHRvIHByZXZpb3VzXG4gICAgLy8gdGhlbiBmaWx0ZXIgb3V0IEdMT0JTVEFSIHN5bWJvbHNcbiAgICBsZXQgcmUgPSBzZXQubWFwKHBhdHRlcm4gPT4ge1xuICAgICAgcGF0dGVybiA9IHBhdHRlcm4ubWFwKHAgPT5cbiAgICAgICAgdHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICAgIDogcCA9PT0gR0xPQlNUQVIgPyBHTE9CU1RBUlxuICAgICAgICA6IHAuX3NyY1xuICAgICAgKS5yZWR1Y2UoKHNldCwgcCkgPT4ge1xuICAgICAgICBpZiAoIShzZXRbc2V0Lmxlbmd0aCAtIDFdID09PSBHTE9CU1RBUiAmJiBwID09PSBHTE9CU1RBUikpIHtcbiAgICAgICAgICBzZXQucHVzaChwKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRcbiAgICAgIH0sIFtdKVxuICAgICAgcGF0dGVybi5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmIChwICE9PSBHTE9CU1RBUiB8fCBwYXR0ZXJuW2ktMV0gPT09IEdMT0JTVEFSKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBpZiAocGF0dGVybi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwYXR0ZXJuW2krMV0gPSAnKD86XFxcXFxcL3wnICsgdHdvU3RhciArICdcXFxcXFwvKT8nICsgcGF0dGVybltpKzFdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm5baV0gPSB0d29TdGFyXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IHBhdHRlcm4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHBhdHRlcm5baS0xXSArPSAnKD86XFxcXFxcL3wnICsgdHdvU3RhciArICcpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXR0ZXJuW2ktMV0gKz0gJyg/OlxcXFxcXC98XFxcXFxcLycgKyB0d29TdGFyICsgJ1xcXFxcXC8pJyArIHBhdHRlcm5baSsxXVxuICAgICAgICAgIHBhdHRlcm5baSsxXSA9IEdMT0JTVEFSXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gcGF0dGVybi5maWx0ZXIocCA9PiBwICE9PSBHTE9CU1RBUikuam9pbignLycpXG4gICAgfSkuam9pbignfCcpXG5cbiAgICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gICAgLy8gZW5kaW5nIGluIGEgKiBvciAqKiB3aWxsIG1ha2UgaXQgbGVzcyBzdHJpY3QuXG4gICAgcmUgPSAnXig/OicgKyByZSArICcpJCdcblxuICAgIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICAgIGlmICh0aGlzLm5lZ2F0ZSkgcmUgPSAnXig/IScgKyByZSArICcpLiokJ1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gICAgfSBjYXRjaCAoZXgpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gc2hvdWxkIGJlIGltcG9zc2libGUgKi8ge1xuICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWdleHBcbiAgfVxuXG4gIG1hdGNoIChmLCBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2gnLCBmLCB0aGlzLnBhdHRlcm4pXG4gICAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAgIC8vIGNvbW1lbnRzLCBldGMuXG4gICAgaWYgKHRoaXMuY29tbWVudCkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gICAgaWYgKGYgPT09ICcvJyAmJiBwYXJ0aWFsKSByZXR1cm4gdHJ1ZVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gICAgLy8gd2luZG93czogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gICAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgICB9XG5cbiAgICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc3BsaXQnLCBmKVxuXG4gICAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAgIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gICAgLy8gbWF0Y2ggbWVhbnMgdGhhdCB3ZSBoYXZlIGZhaWxlZC5cbiAgICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cblxuICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0XG4gICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzZXQnLCBzZXQpXG5cbiAgICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICAgIGxldCBmaWxlbmFtZVxuICAgIGZvciAobGV0IGkgPSBmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBmaWxlbmFtZSA9IGZbaV1cbiAgICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0dGVybiA9IHNldFtpXVxuICAgICAgbGV0IGZpbGUgPSBmXG4gICAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gICAgLy8gcGF0dGVybiwgZmFpbHVyZSBvdGhlcndpc2UuXG4gICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRoaXMubmVnYXRlXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdHMgKGRlZikge1xuICAgIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbiAgfVxufVxuXG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoXG4iXSwibmFtZXMiOlsibWluaW1hdGNoIiwibW9kdWxlIiwiZXhwb3J0cyIsInAiLCJwYXR0ZXJuIiwib3B0aW9ucyIsImFzc2VydFZhbGlkUGF0dGVybiIsIm5vY29tbWVudCIsImNoYXJBdCIsIk1pbmltYXRjaCIsIm1hdGNoIiwicGF0aCIsInJlcXVpcmUiLCJzZXAiLCJHTE9CU1RBUiIsIlN5bWJvbCIsImV4cGFuZCIsInBsVHlwZXMiLCJvcGVuIiwiY2xvc2UiLCJxbWFyayIsInN0YXIiLCJ0d29TdGFyRG90IiwidHdvU3Rhck5vRG90IiwiY2hhclNldCIsInMiLCJzcGxpdCIsInJlZHVjZSIsInNldCIsImMiLCJyZVNwZWNpYWxzIiwiYWRkUGF0dGVyblN0YXJ0U2V0Iiwic2xhc2hTcGxpdCIsImZpbHRlciIsImkiLCJsaXN0IiwiZXh0IiwiYSIsImIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrIiwiZGVmYXVsdHMiLCJkZWYiLCJsZW5ndGgiLCJvcmlnIiwibSIsImNvbnN0cnVjdG9yIiwibWFrZVJlIiwiYnJhY2VFeHBhbmQiLCJub2JyYWNlIiwidGVzdCIsIk1BWF9QQVRURVJOX0xFTkdUSCIsIlR5cGVFcnJvciIsIlNVQlBBUlNFIiwibW0iLCJmIiwibm9udWxsIiwicHVzaCIsImdsb2JVbmVzY2FwZSIsInJlcGxhY2UiLCJjaGFyVW5lc2NhcGUiLCJyZWdFeHBFc2NhcGUiLCJicmFFeHBFc2NhcGUiLCJ3aW5kb3dzUGF0aHNOb0VzY2FwZSIsImFsbG93V2luZG93c0VzY2FwZSIsInJlZ2V4cCIsIm5lZ2F0ZSIsImNvbW1lbnQiLCJlbXB0eSIsInBhcnRpYWwiLCJtYWtlIiwiZGVidWciLCJwYXJzZU5lZ2F0ZSIsImdsb2JTZXQiLCJhcmdzIiwiY29uc29sZSIsImVycm9yIiwiZ2xvYlBhcnRzIiwibWFwIiwic2kiLCJwYXJzZSIsImluZGV4T2YiLCJub25lZ2F0ZSIsIm5lZ2F0ZU9mZnNldCIsInNsaWNlIiwibWF0Y2hPbmUiLCJmaWxlIiwiZmkiLCJwaSIsImZsIiwicGwiLCJmciIsInByIiwiZG90Iiwic3dhbGxvd2VlIiwiaGl0IiwiRXJyb3IiLCJpc1N1YiIsIm5vZ2xvYnN0YXIiLCJyZSIsImhhc01hZ2ljIiwiZXNjYXBpbmciLCJwYXR0ZXJuTGlzdFN0YWNrIiwibmVnYXRpdmVMaXN0cyIsInN0YXRlQ2hhciIsImluQ2xhc3MiLCJyZUNsYXNzU3RhcnQiLCJjbGFzc1N0YXJ0IiwiY3MiLCJzcCIsImRvdFRyYXZBbGxvd2VkIiwiZG90RmlsZUFsbG93ZWQiLCJwYXR0ZXJuU3RhcnQiLCJzdWJQYXR0ZXJuU3RhcnQiLCJjbGVhclN0YXRlQ2hhciIsIm5vZXh0IiwicGxFbnRyeSIsInR5cGUiLCJzdGFydCIsInJlU3RhcnQiLCJwb3AiLCJhc3NpZ24iLCJyZUVuZCIsInN1YnN0cmluZyIsIlJlZ0V4cCIsImVyIiwidGFpbCIsIl8iLCIkMSIsIiQyIiwiYWRkUGF0dGVyblN0YXJ0IiwibiIsIm5sIiwibmxCZWZvcmUiLCJubEZpcnN0IiwibmxBZnRlciIsIm5sTGFzdCIsImNsb3NlUGFyZW5zQmVmb3JlIiwib3BlblBhcmVuc0JlZm9yZSIsImNsZWFuQWZ0ZXIiLCJkb2xsYXIiLCJub2Nhc2UiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiZmxhZ3MiLCJfZ2xvYiIsIl9zcmMiLCJ0d29TdGFyIiwiam9pbiIsImV4IiwiZmlsZW5hbWUiLCJtYXRjaEJhc2UiLCJmbGlwTmVnYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readdir-glob/node_modules/minimatch/minimatch.js\n");

/***/ })

};
;